{"text": "\\n\\nWeaviate 1.16 introduced the [Ref2Vec](/developers/weaviate/modules/retriever-vectorizer-modules/ref2vec-centroid) module. In this article, we give you an overview of what Ref2Vec is and some examples in which it can add value such as recommendations or representing long objects. ## What is Ref2Vec? The name Ref2Vec is short for reference-to-vector, and it offers the ability to vectorize a data object with its cross-references to other objects. The Ref2Vec module currently holds the name ref2vec-**centroid** because it uses the average, or centroid vector, of the cross-referenced vectors to represent the **referencing** object.\"\n        },\n        {\n          \"content\": \"In other words, the User vector is being updated in real-time here to take into account their preferences and actions, which helps to produce more relevant results at speed. Another benefit of Ref2Vec is that this calculation is not compute-heavy, leading to low overhead. With Ref2Vec, you can use Weaviate to provide Recommendation with \\\"user-as-query\\\". This is a very common and powerful way to build Home Feed style features in apps. This can be done by sending queries like this to Weaviate:\\n\\n```graphql\\n{\\n  Get {\\n    Product (\\n      nearObject: {\\n        id: \\\"8abc5-4d5...\\\" # id for the User object with vector defined by ref2vec-centroid\\n      }\\n    ) {\\n      product_name\\n      price\\n    }\\n  }\\n}\\n```\\n\\nThis short query encapsulates the power of Ref2Vec.\"\n        },\n        {\n          \"content\": \"![Cross-reference](./img/Weaviate-Ref2Vec_1.png)\\n\\nRef2Vec gives Weaviate another way to vectorize a class, such as the User class, based on their relationships to other classes. This allows Weaviate to quickly create up-to-date representations of users based on their relationships such as recent interactions. If a user clicks on 3 shoe images on an e-commerce store, it is a safe bet that they want to see more shoes. Ref2Vec captures this intuition by calculating vectors that aggregate each User's interaction with another class. The below animation visualizes a real example of this in e-Commerce images.\"\n        },\n        {\n          \"content\": \"The following image depicts how Ref2Vec aggregates the representations of 3 Product items to represent a User who has purchased a pair of boots, shorts, and Weaviate t-shirt!\\n\\n![Ref2Vec Image](./img/ref2vec.png)\\n\\nSuch a representation of the User, by an aggregation of their cross-references, allows Weaviate to conveniently and immediately learn from each User's preferences and actions to provide improved and up-to-date characterizations. Ref2Vec can in other words capture each User's interests and tendencies across multiple axes, such as product categories or even fashion styles! And by doing so, the resulting recommendations can more closely match the User's product and style preferences. We envision Ref2Vec to have great potential in multiple application areas. Let's take a look at a few of them in more detail, starting with recommendation systems. ## Recommendation in Weaviate\\nMany of you might primarily know Weaviate as a vector database and search engine, but Weaviate can also power high-quality, lightning-fast recommendations.\"\n        },\n        {\n          \"content\": \"## More Coming Soon\\nWe are very excited about the potential of Ref2Vec, and how it leverages existing symbolic data to augment vector searches in a new way. One of my favorite articles about Weaviate is Bob van Luijt's [\\\"The AI-First Database Ecosystem\\\"](/blog/semantic-search-with-wikipedia-and-weaviate). In this article, Bob describes emerging **waves** of database technology; from SQL, to NoSQL, and now, AI-first databases that focus \\\"on data that is processed by a machine learning model first, where the AI models help in processing, storing and searching through the data as opposed to traditional ways\\\". Although Weaviate puts Machine Learning data representations first, **this doesn't mean we discard symbolic data and many features of previous systems**. Rather, we are actively searching for how symbolic data can improve neural functionality and vice versa.\"\n        }\n      ]\n    }\n  }\n}\n```\n\n#### Query with Reranking\n\n```python\nresponse = (\n    client.query\n    .get(\"BlogsFineTuned\", [\"content\"])\n    .with_near_text({\n        \"concepts\": [\"Ref2Vec in Weaviate\"]\n    })\n    .with_additional(\"rerank(property: \\\"content\\\" query: \\\"Represent users based on their product interactions\\\") { score }\")\n    .with_limit(5)\n    .do()\n)\n\nprint(json.dumps(response, indent=2))\n```\n\n##### Output\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"BlogsFineTuned\": [\n        {\n          \"_additional\": {\n            \"rerank\": [\n              {\n                \"score\": 0.9261703\n              }\n            ]\n          },\n          \"content\": \"![Cross-reference](./img/Weaviate-Ref2Vec_1.png)\\n\\nRef2Vec gives Weaviate another way to vectorize a class, such as the User class, based on their relationships to other classes. This allows Weaviate to quickly create up-to-date representations of users based on their relationships such as recent interactions. If a user clicks on 3 shoe images on an e-commerce store, it is a safe bet that they want to see more shoes. Ref2Vec captures this intuition by calculating vectors that aggregate each User's interaction with another class. The below animation visualizes a real example of this in e-Commerce images.\"\n        },\n        {\n          \"_additional\": {\n            \"rerank\": [\n              {\n                \"score\": 0.34444344\n              }\n            ]\n          },\n          \"content\": \"The following image depicts how Ref2Vec aggregates the representations of 3 Product items to represent a User who has purchased a pair of boots, shorts, and Weaviate t-shirt!\\n\\n![Ref2Vec Image](./img/ref2vec.png)\\n\\nSuch a representation of the User, by an aggregation of their cross-references, allows Weaviate to conveniently and immediately learn from each User's preferences and actions to provide improved and up-to-date characterizations. Ref2Vec can in other words capture each User's interests and tendencies across multiple axes, such as product categories or even fashion styles! And by doing so, the resulting recommendations can more closely match the User's product and style preferences. We envision Ref2Vec to have great potential in multiple application areas. Let's take a look at a few of them in more detail, starting with recommendation systems. ## Recommendation in Weaviate\\nMany of you might primarily know Weaviate as a vector database and search engine, but Weaviate can also power high-quality, lightning-fast recommendations.\"\n        },\n        {\n          \"_additional\": {\n            \"rerank\": [\n              {\n                \"score\": 0.007121429\n              }\n            ]\n          },\n          \"content\": \"In other words, the User vector is being updated in real-time here to take into account their preferences and actions, which helps to produce more relevant results at speed. Another benefit of Ref2Vec is that this calculation is not compute-heavy, leading to low overhead. With Ref2Vec, you can use Weaviate to provide Recommendation with \\\"user-as-query\\\". This is a very common and powerful way to build Home Feed style features in apps. This can be done by sending queries like this to Weaviate:\\n\\n```graphql\\n{\\n  Get {\\n    Product (\\n      nearObject: {\\n        id: \\\"8abc5-4d5...\\\" # id for the User object with vector defined by ref2vec-centroid\\n      }\\n    ) {\\n      product_name\\n      price\\n    }\\n  }\\n}\\n```\\n\\nThis short query encapsulates the power of Ref2Vec.\"\n        },\n        {\n          \"_additional\": {\n            \"rerank\": [\n              {\n                \"score\": 5.5508026e-06\n              }\n            ]\n          },\n          \"content\": \"---\\ntitle: What is Ref2Vec and why you need it for your recommendation system\\nslug: ref2vec-centroid\\nauthors: [connor]\\ndate: 2022-11-23\\ntags: ['integrations', 'concepts']\\nimage: ./img/hero.png\\ndescription: \\\"Weaviate introduces Ref2Vec, a new module that utilises Cross-References for Recommendation!\\\"\\n---\\n![Ref2vec-centroid](./img/hero.png)\\n\\n\\n\\nWeaviate 1.16 introduced the [Ref2Vec](/developers/weaviate/modules/retriever-vectorizer-modules/ref2vec-centroid) module. In this article, we give you an overview of what Ref2Vec is and some examples in which it can add value such as recommendations or representing long objects. ## What is Ref2Vec? The name Ref2Vec is short for reference-to-vector, and it offers the ability to vectorize a data object with its cross-references to other objects. The Ref2Vec module currently holds the name ref2vec-**centroid** because it uses the average, or centroid vector, of the cross-referenced vectors to represent the **referencing** object.\"\n        },\n        {\n          \"_additional\": {\n            \"rerank\": [\n              {\n                \"score\": 4.7478566e-06\n              }\n            ]\n          },\n          \"content\": \"## More Coming Soon\\nWe are very excited about the potential of Ref2Vec, and how it leverages existing symbolic data to augment vector searches in a new way. One of my favorite articles about Weaviate is Bob van Luijt's [\\\"The AI-First Database Ecosystem\\\"](/blog/semantic-search-with-wikipedia-and-weaviate). In this article, Bob describes emerging **waves** of database technology; from SQL, to NoSQL, and now, AI-first databases that focus \\\"on data that is processed by a machine learning model first, where the AI models help in processing, storing and searching through the data as opposed to traditional ways\\\". Although Weaviate puts Machine Learning data representations first, **this doesn't mean we discard symbolic data and many features of previous systems**. Rather, we are actively searching for how symbolic data can improve neural functionality and vice versa.\"\n        }\n      ]\n    }\n  }\n}\n```\n\nMy query was about the Ref2Vec feature in Weaviate. Without reranking, the objects were about Ref2Vec, but it wasn\u2019t in detail about the module. In the reranking query, I first searched for concepts about Ref2Vec and then reranked the objects that were about how users are represented by their product interactions.\n\nAs you can see, the output is different for each query. The first object from pure vector search outputted the first chunk from the Ref2Vec blog post, which is relevant but doesn\u2019t answer my query. The query with reranking went into depth on how Ref2Vec gives Weaviate another way to vectorize a class.\n\n## Pointwise versus Listwise Reranking\n\nThe reranker model described in this blog post is a pointwise reranker. Pointwise rerankers take as input the query and each candidate document, **separately**, and output a relevance score. Another interesting opportunity for ranking models are listwise rerankers. Listwise rerankers take as input the query and **all** the candidate documents at once as input, and output a reranked list!\n\n![Pointwise](img/pointwise%20(2).png)\n![Listwise](img/listwise.jpeg)\n\nHere is a [quick summary](https://twitter.com/ecardenas300/status/1750237408459706554) I made on RankZephyr, where Pradeep et al. trained a 7 billion parameter LLM to copy outputs from a two-stage training process with GPT-3.5 and GPT-4.\n\nStay tuned as we continue to investigate supporting these models in Weaviate and the emerging research landscape!\n\n## Conclusion\n\nThis blog post walked you through how to generate synthetic data using DSPy, fine-tune Cohere\u2019s reranker, and run a vector search query with reranking in Weaviate!\n\nIf you\u2019d like to learn more about DSPy, check out this DSPy Explained([https://www.youtube.com/watch?v=41EfOY0Ldkc](https://www.youtube.com/watch?v=41EfOY0Ldkc)) video from Connor Shorten.\n\n\nimport WhatNext from '/_includes/what-next.mdx'\n\n\n", "type": "Blog", "name": "Blog Fine-tuning-cohere-reranker", "path": "blog/2024-02-13-fine-tuning-cohere-reranker/index.mdx", "link": "https://weaviate.io/blog/fine-tuning-coheres-reranker", "timestamp": "2024-05-08 10:51:57", "reader": "JSON", "meta": {}, "chunks": []}