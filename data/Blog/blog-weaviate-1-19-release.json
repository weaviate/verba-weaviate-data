{"text": "We are happy to announce the release of Weaviate `1.19`, which brings a set of great features, performance improvements, and fixes.\n\nIf you like your content brief and to the point, here is the TL;DR of this release:\n\n1. Group by arbitrary property \u2013 The groupBy option has been introduced to Get object retrieval, so you can group search results by any property.\n1. New (or improved) Data Types \u2013 Datatypes changes with text having faster filtering & more tokenization options while deprecating string to reduce complexity, and adding uuid to allow efficient uuid storage.\n1. Generative Cohere Module \u2013 Combines the best of Weaviate, retrieving and searching relevant documents with the generative capabilities of the models that Cohere is cooking up!\n1. Tunable Consistency for Vector Search and GraphQL Get Requests \u2013 Consistency tuning with replication is now available for vector search with Get requests.\n1. gRPC API support(experimental) \u2013 gRPC API support slowly being trialled, with some big potential for speedups.\n1. Other Improvements and Bug Fixes \u2013 fixes and improvements delivered since `1.18`.\n\nRead below to learn more about each of these points in more detail.\n\nKeep in mind that after upgrading to `v1.19` a downgrade to `v1.18` will **no longer be supported**. If you anticipate having to downgrade, please create a backup before upgrading! If a backup is done with `v1.18` before upgrading, you can always go back to `v1.18` if you wish.\n\n* With the `string`->`text` migration, downgrading after upgrading will not work.\n* With the prop tracker fixes (bm25), once migrated you can\u2019t downgrade again.\n\n## Group by arbitrary property\n\ngroup by arbitrary property\n\nWith the introduction of this feature, you can now group `Get` search results based on a specific property.\n\nTake a collection of `Passage` objects for example, each object belonging to a `Document`. If searching through `Passage` objects, you can group the results according to any property of the `Passage`, including the cross-reference property that represents the `Document` each `Passage` is associated with.\n\nThe `groups` and `objectsPerGroup` limits are customizable. So in this example, you could retrieve the top 1000 objects and group them to identify the 3 most relevant `Document` objects, based on the top 3 `Passage` objects from each `Document`.\n\nThis functionality offers the advantage of maintaining granular search results by searching through detailed or segmented objects (e.g., `Passage`), while also enabling you to step back and view the broader context of the objects (e.g., `Document`).\n\n\n  An example GraphQL query is shown below:\n\n```graphql\n{\n  Get{\n    Passage(\n      limit: 100\n      nearObject:{\n        id: \"00000000-0000-0000-0000-000000000001\"\n      }\n      groupBy:{\n        path:[\"content\"]\n        groups:2\n        objectsPerGroup:2\n      }\n    ){\n      _additional{\n        group{\n          id\n          count\n          groupValue\n          maxDistance\n          minDistance\n          hits{\n            content\n            ofDocument {\n              ... on Document{\n                _additional{\n                  id\n                }\n              }\n            }\n            _additional{\n              id\n              distance\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n\n\n  And a corresponding example response is also shown below:\n\n```graphql\n{\n  \"data\": {\n    \"Get\": {\n      \"Passage\": [\n        {\n          \"_additional\": {\n            \"group\": {\n              \"count\": 1,\n              \"groupValue\": \"Content of passage 1\",\n              \"hits\": [\n                {\n                  \"_additional\": {\n                    \"distance\": 0,\n                    \"id\": \"00000000-0000-0000-0000-000000000001\"\n                  },\n                  \"content\": \"Content of passage 1\",\n                  \"ofDocument\": [\n                    {\n                      \"_additional\": {\n                        \"id\": \"00000000-0000-0000-0000-000000000011\"\n                      }\n                    }\n                  ]\n                }\n              ],\n              \"id\": 0,\n              \"maxDistance\": 0,\n              \"minDistance\": 0\n            },\n            \"id\": \"00000000-0000-0000-0000-000000000001\"\n          }\n        },\n        {\n          \"_additional\": {\n            \"group\": {\n              \"count\": 1,\n              \"groupValue\": \"Content of passage 2\",\n              \"hits\": [\n                {\n                  \"_additional\": {\n                    \"distance\": 0.00078231096,\n                    \"id\": \"00000000-0000-0000-0000-000000000002\"\n                  },\n                  \"content\": \"Content of passage 2\",\n                  \"ofDocument\": [\n                    {\n                      \"_additional\": {\n                        \"id\": \"00000000-0000-0000-0000-000000000011\"\n                      }\n                    }\n                  ]\n                }\n              ],\n              \"id\": 1,\n              \"maxDistance\": 0.00078231096,\n              \"minDistance\": 0.00078231096\n            },\n            \"id\": \"00000000-0000-0000-0000-000000000002\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\nKeep in mind that specifying a `path` value that requires resolving a large number of objects may be computationally expensive. For instance, setting the `path` above to `[\"ofDocument\", \"Document\", \"title\"]` would require resolving all documents and may take considerably longer.\n\n## New (or improved) Data Types\n\nnew or improved data types\n\nWe've made several enhancements to the way we handle data, including upgrades to the `text` property and the introduction of dedicated `uuid` data types.\n\n### Text / String changes\nWe have upgraded the `text` property to offer more flexibility in tokenizing textual data for indexing. You can now choose from `word`, `whitespace`, `lowercase`, and `field` tokenization options. To simplify matters, we have deprecated the `string` data type.\n\nThe available tokenization options for `text` are:\n\n-   `word` (default): Keep alpha-numeric characters, lowercase them, and split by whitespace. _(Same as the current `text` behavior.)_\n-   `whitespace`: Split the text on whitespace. _(Same as `word` on `string` right now.)_\n-   `lowercase`: Lowercase the text and split on whitespace. _(New)_\n-   `field`: Index the whole field after trimming whitespace characters. _(Same as the current `string` behavior.)_\n\n#### Faster filtering & index changes\n\nWe have introduced a roaring bitmap index for `text` properties, which brings the fast filtering capabilities introduced in version `1.18` to text data. Internally, this is implemented using two separate (`filterable` & `searchable`) indexes, which replaces the existing index. You can configure the new `indexFilterable` and `indexSearchable` parameters to determine whether to create the roaring set index and the BM25-suitable Map index, respectively. (Both are enabled by default.)\n\nThe searchable index works also as fallback for text filtering, so filtering is still possible even if indexFilterable will be disabled. The downside, in this scenario is if you turn off the bitmap indexing, filtering by the text property will be slower.\n\n\n\n  How will upgrades work?\n\nAfter upgrading a pre-`v1.19` Weaviate to `v1.19`, `indexFilterable` + `indexSearchable` will be set based on the value of `indexInverted`, meaning `true` -> `true`+`true`, `false` -> `false`+`false`, `null` -> `null`+`null`. (A `null` will use the default, which is to turn it on.)\n`indexFilterable` and `indexSearchable` are available for all types of data, although searchable is only relevant for `text`/`text[]`, and in other cases it will be simply ignored.\n\nSince filterable & searchable are separate indexes, filterable does not exist in Weaviate instances upgraded from pre-`v1.19` to `v1.19`. The missing `filterable` index can be created though on startup for all `text/text[]` properties if env variable INDEX_MISSING_TEXT_FILTERABLE_AT_STARTUP is set (to `true`).\n\nWhile building the `filterable` index, Weaviate will work in readonly mode (similarly to reindexing sets to roaring sets on pre-`v1.18` to `v1.18` migration).\n\n\n\n#### Deprecation of `string`\n\nExisting `string` classes can be migrated according to the tokenization rules above during the first startup. If a user specifies `string` for a new class, it will be stored as `text` with `field` tokenization, and a deprecation warning will be shown.\n\n### Dedicated UUID Data Types\n\nWe have introduced dedicated `uuid` and `uuid[]` data types, reducing the storage space required by more than half.\n\n`uuid` details:\n\n-   Each `uuid` is a 128-bit (16-byte) number.\n-   The filterable index uses roaring bitmaps.\n-   Please note that it is currently not possible to aggregate or sort by `uuid` or `uuid[]` types.\n\n## Generative Cohere Module\n\ngenerative cohere module\n\nWith Weaviate `1.19.0` we are very excited to announce that the `generative-cohere` module is now available for use! This module, similar to our previous generative module, enables you to leverage the power of Large Language Models on your own customized datasets and for specific use cases.\n\nThe `generative-cohere` module combines the best of Weaviate, retrieving and searching relevant documents with the generative capabilities of the models that Cohere is cooking up! By integrating a general-purpose LLM with a vector database like Weaviate, you can utilize the model's power to carry out tasks in the context of your own data housed in Weaviate!\n\nThe `generative-cohere` module can be used to get Cohere\u2019s `command-xlarge-nightly` model to answer prompts grounded in the context of knowledge provided by Weaviate search results.\n\nThe process consists of two steps: first, we query Weaviate to extract context by filtering a subset of your data that has knowledge relevant to a specific prompt. Secondly, we send the prompt as well as the filtered subset of documents from step one directly to the LLM model using Cohere\u2019s API to accomplish the task specified in the prompt.\n\nTo get started with the module you simply need to include it when specifying the config for the Weaviate instance and provide you Cohere API key prior to querying. Other models that can be used with the module include `command-xlarge-beta` and `command-xlarge`. The module can be used to generate responses from the LLM for each returned document from Weaviate, using `singleResult`, or a grouped response that uses all returned documents together as context, using `groupedResult`.\n\nSee below for an example of how you can use the module. For more information on how to set up and use the module please refer to the documentation.\n\n\n  Example Query:\n\n```graphql\n{\n  Get{\n    Article(\n      nearText: {\n        concepts: [\"Italian food\"]\n      }\n      limit: 1\n    ) {\n      title\n      summary\n      _additional {\n        generate(\n          singleResult: {\n            prompt: \"\"\"\n              Describe the following as a Facebook Ad: {summary}\n            \"\"\"\n          }\n        ) {\n          singleResult\n          error\n        }\n      }\n    }\n  }\n}\n```\n\n\n\n  Corresponding Response:\n\n```\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"_additional\": {\n            \"generate\": {\n              \"error\": null,\n              \"singleResult\": \"Italian food, as we know it today, might be a relatively modern concept. But it's hard to deny that there's something special about it. It could be the way the pasta tastes or the way the sauce smells. It could be the way the cheese stretches or the way the bread soaks up the sauce. Whatever it is, Italian food has a way of capturing our hearts and our stomachs. So if you're looking for a way to spice up your meal routine, why not try Italian? You might just find that it's your new favorite cuisine.\"\n            }\n          },\n          \"summary\": \"Even the emoji for pasta isn't just pasta -- it's a steaming plate of spaghetti heaped with tomato sauce on top. But while today we think of tomatoes as inextricably linked to Italian food, that hasn't always been the case. \\\"People tend to think Italian food was always as it is now -- that Dante was eating pizza,\\\" says Dr Eva Del Soldato , associate professor of romance languages at the University of Pennsylvania, who leads courses on Italian food history. In fact, she says, Italy's complex history -- it wasn't unified until 1861 -- means that what we think of Italian food is, for the most part, a relatively modern concept. Diego Zancani, emeritus professor of medieval and modern languages at Oxford University and author of \\\"How We Fell in Love with Italian Food,\\\" agrees.\",\n          \"title\": \"How this fruit became the star of Italian cooking\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n## Tunable Consistency for Vector Search and GraphQL Get Requests\n\ntunable consistency\n\nTo help you optimize Weaviate according to your consistency and speed requirements, we provide the following consistency settings:\n\n* `ONE` - reads/writes return the result from the first node that responds\n* `QUORUM` - reads/writes succeed after a majority of nodes (`replication_factor/2 + 1`) respond\n* `ALL` - all replicas must respond\n\nWe initially introduced this consistency tuning feature in the [`1.17` release] (TODO - LINK TO 1.17 blog) and later expanded it to support all read and write REST operations in the [`1.18` release] (TODO - LINK TO 1.18 blog).\n\nIn the `1.19` release, we further extend tunable consistency support to include vector search and GraphQL Get requests.\n\n## gRPC API support (experimental)\n\ngrpc\n\nWe're excited to share an under-the-hood improvement that could make your experience even better.\n\nStarting with version `1.19`, Weaviate is introducing support for the gRPC (gRPC Remote Procedure Calls) API. While there won't be any user-facing API changes, you may notice that your queries are executed even faster than before.\n\nWithout diving too deep into technicalities, the sources of speedup include: reduced encoding/decoding compute requirements at the protocol level, improved parsing efficiency, and specific optimizations in certain Python implementations.\n\nOur internal tests indicate an approximate 2-3x speedup in queries where gRPC is implemented. We plan to gradually expand gRPC support, so if you notice your queries are running faster in the future, you'll know why. \ud83d\ude09\n\nBut we will be adding support to all clients going forward, as well as to additional endpoints.\n\n## Other Improvements and Bug Fixes\n\nimprovements and bug fixes\n\nSince Weaviate `1.18`, we have released four patches that include various changes and bug fixes.\n\n### Node Allocation\nWe\u2019ve introduced a new feature in Weaviate that offers a more efficient approach to node allocation. Rather than randomly selecting a node, Weaviate will now try to select the node with the most available resources. This only applies when creating a new class, rather than when adding more data to an existing single class. The current implementation only considers the disk space. In the future, we can add more data points like memory consumption and others.\n\nThis improvement was part of the `1.18.1` release.\n\n### Improved Multi-Class Support\nPreviously, Weaviate would struggle when adding many \u201c1,000s of\u201d classes. We identified and fixed various issues to fix this. Issues related to many-class can generally be grouped into three distinct areas of concern: 1. Higher than expected memory usage, 2. Cycle spam, 3. Lagging schema deletes. The overview of each section can be found here.\n\n### Fixes for BM25\nAs an ongoing effort to improve BM25, we realized there was an error when calculating the average length of a property. There are two issues:\n\n- If there are too many properties, the BM25 component has errors.\n- If there are zero-length properties, the BM25 component can return incorrect mean values.\n\nTo fix these problems, the property length tracker has been completely replaced. This is a non-breaking change that seamlessly migrates at startup. This change makes BM25 searches more accurate.\n\nThis change is part of the `1.19.0` release.\n\n### Release Notes for all Patches\nThe above features highlighted a few changes that were included in the patch releases. For more details on each release, you can check out the release notes:\n* Release v1.18.1\n* Release v1.18.2\n* Release v1.18.3\n* Release v1.18.4\n\nimport WhatNext from '/_includes/what-next.mdx'\n\n\n", "type": "Blog", "name": "blog-weaviate-1-19-release", "path": "blog/2023-05-04-weaviate-1-19-release/index.mdx", "link": "https://weaviate.io/blog/weaviate-1-19-release", "timestamp": "2023-11-02 11:59:26", "reader": "JSON", "meta": {}, "chunks": []}