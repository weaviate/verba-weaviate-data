{"text": "1. **Nested object storage** - store nested objects directly in Weaviate as property values\n2. **asynchronous vector indexing** - import large datasets faster by indexing vectors asynchronously\n3. **Additional gRPC support** - preparing for the future with more gRPC support\n4. **`v4` Python client beta** - try it out and let us know what you think!\n\n`1.22` is already available on Weaviate Cloud Services - so try it out!\n\nFor more details, keep scrolling \u2b07\ufe0f!\n\n## Nested object storage\n\nIllustration of nested objects being added into Weaviate\n\n`1.22` welcomes new members to the Weaviate data type family, with `object` and `object[]` joining the available list.\n\nThis allows you to store nested objects directly in Weaviate as property values. In other words, you can store them without having to flatten the object or use cross-references to other Weaviate classes.\n\nThis is particularly useful for storing data that is not easily represented in a flat structure. For example, nested properties let you work with an `address` value that has `number`, `street`, and city` properties of its own.\n\nAn example class definition is shown below, where a `Nested` class has a `parent` property with an `object` datatype. Because the `parent` property is an `object`, it can have its own properties (`nestedProperties`), such as `child` in this example, which is a `text` datatype.\n\n```json\n{\n    \"class\": \"Nested\",\n    \"properties\": [\n        {\n            \"dataType\": [\"object\"],\n            \"name\": \"parent\",\n            \"nestedProperties\": [\n                {\n                    \"dataType\": [\"text\"],\n                    \"name\": \"child\"\n                }\n            ]\n        }\n    ],\n}\n```\n\nAn example object of this class may look like this:\n\n```json\n{\n    \"parent\": {\"child\": \"I'm nested!\"}\n}\n```\n\nEach nested property has its own data type. A nested property can be an `object` itself. This allows you to create nested structures of arbitrary depth.\n\n\n  Two-level depth example\n\nThe following class definition shows a `DoublyNested` class with a `parent` property that is an `object` datatype, similarly to above. Here, hwoever, the `child` property is itself an `object` datatype, and has its own `nestedProperties` of `childname` and `grandchild`.\n\n```json\n{\n    \"class\": \"DoublyNested\",\n    \"properties\": [\n        {\n            \"dataType\": [\"object\"],\n            \"name\": \"parent\",\n            \"nestedProperties\": [\n                {\n                    \"dataType\": [\"object\"],\n                    \"name\": \"child\",\n                    \"nestedProperties\": [\n                        {\n                            \"dataType\": [\"text\"],\n                            \"name\": \"childname\",\n                        },\n                        {\n                            \"dataType\": [\"text\"],\n                            \"name\": \"grandchild\"\n                        },\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\nAn example object of this class may look like this:\n\n```json\n{\n    \"parent\": {\n        \"child\": {\n            \"childname\": \"Nested child\",\n            \"grandchild\": \"I'm doubly nested!\"\n        }\n    }\n},\n```\n\n\n\nMore practically, this type of structure may be applied to capture addresses, product information, or any other nested data structure. Take a look at the following example that shows a `Person` class with an `address` property that is an `object` datatype. The `address` property is able to store its own `nestedProperties` of `street` and `city`.\n\n```json\n{\n    \"class\": \"Person\",\n    \"properties\": [\n        {\n            \"dataType\": [\"text\"],\n            \"name\": \"last_name\",\n        },\n        {\n            \"dataType\": [\"object\"],\n            \"name\": \"address\",\n            \"nestedProperties\": [\n                {\"dataType\": [\"text\"], \"name\": \"street\"},\n                {\"dataType\": [\"text\"], \"name\": \"city\"}\n            ],\n        }\n    ],\n}\n```\n\nYou can create a nested object for this class:\n\n```json\n{\n    \"last_name\": \"Franklin\",\n    \"address\": {\n        \"city\": \"London\",\n        \"street\": \"King Street\"\n    }\n}\n```\n\n### Auto-schema support for nested properties\n\nGiven that the `object` data types allow nested properties of arbitrary depth, you will be pleased to know that auto-schema supports nested properties. This means that you can create a class with nested properties without having to manually define the class structure.\n\nIf you create a property with the `object` datatype, Weaviate can automatically create the nested properties for you at import time. This may allow you to create a class from a large number of nested properties with ease.\n\nThis can provide a level of convenience for experimentation or evaluation, although as always you will get the most granular and exact control over the schema by defining it manually.\n\nParsing objects at import time to infer the class definition may be slow for nested properties. Accordingly, we recommend that you manually specify the nested properties in the class definition as much as possible, especially in a production setting.\n\n### Future improvements\n\nPlease keep in mind that this is the first iteration of nested object storage in Weaviate, and we have further improvements planned.\n\nIn the current implementation, properties with `object` datatype do not affect the object vector, or the inverted index. Cross-reference properties have similar behavior whe the cross-referenced object is not indexed.\n\nFuture plans include the ability to index nested properties, for example to allow for filtering on nested properties and vectorization options.\n\n## Performance improvements\n\nThe following features unlock further performance improvements in Weaviate `1.22`. Note that these are opt-in features at this point.\n\nThe `asynchronous vector indexing` feature must be enabled in the Weaviate configuration file, and the gRPC API is currently only supported through the new `v4` Python client (which is in beta).\n\n### Asynchronous vector indexing (experimental)\n\nIndexing progress\n\nDue to the experimental nature of this feature, we recommend against using it in production environments.\n\nThis release includes an experimental preview of our asynchronous vector indexing feature. With this, Weaviate now offers you the option de-coupling vector indexing from object creation. You can enable this to optimize imports for speed where vector indexing is not required immediately.\n\nAs of `1.22`, this is an opt-in feature. To enable asynchronous index, set `ASYNC_INDEXING` to true in your `docker-compose.yml` or equivalent configuration file.\n\nIn earlier versions of Weaviate, the HNSW index builds synchronously with object creation. A benefit of the synchronous approach is that the user can perform a search immediately after import, as the data is already indexed. However, synchronous index creation slows down the import process.\n\nStarting with `1.22`, the vector indexing process can now be performed asynchronously to object creation. This means that the import process can go on independently to the indexing process and continue to create objects while the indexing process is ongoing.\n\nThe user can still perform vector searches as import progresses. Weaviate will search the vector index built to date as well as up to 100,000 un-indexed objects using brute force.\n\nCurrently, if async indexing is enabled, importing geo properties is slower than before. We expect to improve import speeds in an upcoming patch release.\n\n#### Updated `nodes` endpoint\n\nThe `nodes` REST endpoint reflects these changes.\n\nThe `nodes` endpoint now has a new `INDEXING` status. The `stats` field now includes a `vectorQueueLength` field that contains the number of objects currently being indexed.\n\n### Official gRPC support\n\ngRPC & Weaviate\n\nThe team continues to add gRPC support under the hood, with a big part of the equivalent GraphQL `Get` queries, and batch import functionality now available via gRPC.\n\nWith these changes, we have seen improvements in import speeds of around ~60-80% for batch imports, `Get` queries are many times faster, too. A big part of this speedup is because gRPC sends binary payloads over HTTP/2, and this provides improvements over GraphQL which uses JSON-based payloads over HTTP/1.\n\nThe upcoming `v4` Python client, supporting gRPC, will enable you to leverage these performance improvements.\n\nIf you are interested in the gRPC API, you can find the documentation including links to the proto files on this page.\n\n\nThis release changes the implementation under the hood. If you were trying out gRPC in the past, this version may not be compatible with your existing code.\n\n\n## `v4` Python client beta\n\nPython client\n\nIf you are wondering how to use the new gRPC functionality, we have you covered with the new Python client.\n\nThis client marks the first beta release of the `v4` client, with not only gRPC support but also an improved API. The new API is more Pythonic, with a focus on improving the user/developer experience. Custom classes and methods now trigger IDE auto-completion in place of untyped dictionaries.\n\nAs one example, an older collection creation requests that used to look like:\n\n```python\n# Existing (v3) Python client syntax\ndefinition = {\n    \"class\": \"Question\",\n    \"vectorizer\": \"text2vec-openai\",\n    \"moduleConfig\": {\n        \"generative-openai\": {}\n    }\n}\n\nclient.schema.create_class(definition)\n```\n\nNow looks like:\n\n```python\n# New (v4) Python client syntax\nimport weaviate.classes as wvc\n\nclient.collections.create(\n    name=\"Question\",\n    vectorizer_config=wvc.Configure.Vectorizer.text2vec_openai(),\n    generative_config=wvc.Configure.Generative.openai()\n)\n```\n\nAnd an older `near text` query like the following:\n\n```python\n# Existing (v3) Python client syntax\nresponse = (\n    client.query\n    .get(\"Question\", [\"question\", \"answer\", \"category\"])\n    .with_near_text({\"concepts\": [\"biology\"]})\n    .with_limit(2)\n    .do()\n)\n```\n\nNow looks like:\n\n```python\n# New (v4) Python client syntax\nquestions = client.collections.get(\"Question\")\nquestions.query.near_text(query=\"biology\", limit=2)\n```\n\nYou may already have seen a blog post about this new client, but we are excited to announce that it is now available in beta!\n\nThe documentation can be found on this page\n\nGiven that this is a beta, please try it and let us know of any feedback on this forum thread.\n\nFeedback can range from minor typos to missing features and everything in between. It can also be a positive comment, of course! We really look forward to hearing from you.\n\n## Summary\n\nThat's all from us - we hope you enjoy the new features and improvements in Weaviate `1.22`. This release is already available on WCS. So you can try it out yourself on a free sandbox, or by upgrading!\n\nThanks for reading, and see you next time \ud83d\udc4b!\n\nimport WhatNext from '/_includes/what-next.mdx'\n\n\n\n", "type": "Blog", "name": "blog-weaviate-1-22-release", "path": "blog/2023-10-31-weaviate-1-22-release/index.mdx", "link": "https://weaviate.io/blog/weaviate-1-22-release", "timestamp": "2023-11-02 11:59:41", "reader": "JSON", "meta": {}, "chunks": []}