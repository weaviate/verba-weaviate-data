{"text": "\n![The pre-release Weaviate TypeScript client](./img/hero.png)\n\n\nWe've released a beta version of our new TypeScript client. It's available for you to try out [on npm](https://www.npmjs.com/package/weaviate-client) under the new name: `weaviate-client`. We\u2019d also love any feedback you can share on the client and your experience using it. Please open an issue on the [client GitHub repository](https://github.com/weaviate/typescript-client/tree/collections/main). Besides the package name change, we\u2019ve made a lot of changes that mirror our client refresh in Python to bring the two closer to each other. We have better TypeScript support, a collections-first approach, and performance improvements.\n\n\n\nYou can try it here - [Experimental clients](/developers/weaviate/client-libraries/typescript).\n\n\n## Introduction\n\nWith first-hand developer experience in mind, we\u2019re committed to making sure that the client libraries we provide are true to the optimum developer experience of each community. We got a lot of feedback on things we could do better in our TypeScript client and we\u2019re thrilled to share this beta version with you.\n\nWe recently released an update to our [Python client](https://weaviate.io/blog/collections-python-client-preview). With TypeScript being the second most popular language choice for developers we felt it only fair to bring the enhancements from the Python client to the TypeScript ecosystem.\n\nWe shared a few messages and have tested the client internally and we\u2019re finally ready to have the wider community try out the new client and the API it offers. \n\n### Installation\n\nFirst things first, you probably want to install the new client beta. You can do that in your terminal with the following command.\n```bash\nnpm install weaviate-client --tag next  # Or yarn add weaviate-client@beta\n```\n\nUsing the beta tag is the best way to ensure you're using the latest version of the client.\n\nIf you\u2019re using TypeScript, your tsconfig.json file must be specified with (at least) `\"module\": \"Node16\"` and `\"moduleResolution\": \"Node16\"`.\n\nYou might be curious to know what a query looks like in the new client, let's answer that for you.\n\nA `nearText` query looks like this in the previous TypeScript client.\n\n```typescript\n// nearText in v2 TypeScript Client\nresult = await client.graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withNearText({ concepts: ['animals in movies'] })\n  .withLimit(2)\n  .withFields('question answer _additional { distance }')\n  .do();\n\n```\n\nIn the new TypeScript client beta, the `nearText` you've grown to love becomes:\n\n\n```typescript\n// nearText in v3 TypeScript Client\nconst myCollection = client.collections.get('JeopardyQuestion');\n\nconst result = await myCollection.query.nearText(['animals in movies'],{\n  limit: 2,\n  returnProperties: ['question', 'answer'],\n  returnMetadata: ['distance']\n})\n```\n\n\n\nIf you're keen to try it, please head over to our [Experimental clients](/developers/weaviate/client-libraries/typescript) page. There, you'll find the installation, usage, and feedback instructions.\n\nLet's dive into the inspiration and core concepts behind this innovation.\n\nGoing forward, to bring consistency to all our clients, we will use the term `collection` instead of `class` to refer to the sets of objects to be stored in Weaviate. This is to avoid confusion with the generic word `class` in object-oriented programming.\n\n## Key changes\n\n![lets get into the changes!](https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZzlkdHAxamlxZDZ6cndkZzVldDI0ZWtzdGltMnhwYXNzeDY5ZzZtYyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/WEeCwilDffnwu2fVRK/giphy.gif)\n\n> **Highlights: Strong typing through custom TS types, focus on individual collections for interaction**\n\nThere are two key changes to the way the `collections` client works in comparison to the existing TS client (let's call this the `Classic` client). They relate to the object typing and the way you interact with the data.\n\n| **Aspect** | **`Classic` Client** | **`Collections` Client** |\n| --- | --- | --- |\n| **Object Typing** | Primarily relied on untyped objects and deep data structures. | Utilizes strong typing through custom TS types and user-defined generics. |\n| **Unit of Interaction** | Interacts with the entire database. | Focuses on individual collections for interaction. |\n\nLet's look at each of these in more detail.\n\n### Better Type Support \n\nAs with previous clients, we're enabling both JavaScript and TypeScript Developers with this client. Written in TypeScript you have the benefits of strong typing out of the box. However, we have method types available for JavaScript developers as well. This makes for a better more intuitive experience in your IDE and beyond. This means you do not have to remember the exact API parameter names, as the IDE will show you the available options. This can be a hurdle when you are working with less often-used options, trying new APIs, or when you are new to Weaviate.\n\n\n\n\nTypes are introduced for the data objects as well at creation time, as well as when retrieving them from the database. This means that you can access the properties of the data object directly.\n\nSo syntax that is currently like this:\n\n```typescript\nresponse.data?.Get?.Article?.[0].title  // Get the `title` property of the first object\nresponse.data?.Get?.Article?.[0]['_additional']?.id  // Get the ID of the first object\nresponse.data?.Get?.Article?.[0]['_additional']?.generate?.singleResult  // Get the generated text from a `singlePrompt` request\nresponse.data?.Get?.Article?.[0]['_additional']?.generate.groupedResult  // Get the generated text from a `groupedTask` request\nresponse.data?.Get?.Article?.[0]['_additional']?.creationTimeUnix // Get the timestamp when the object was created\n```\nLook at all those `?` operators and the necessary `['_additional']` index due to the `_` in the key name!\n\n\nBecomes:\n\n\n```typescript\nresponse.objects[0].properties.title  // Get the `title` property of the first object\nresponse.objects[0].uuid  // Get the ID of the first object\nresponse.objects[0].generated  // Get the generated text from a `singlePrompt` request\nresponse.generated  // Get the generated text from a `groupedTask` request\nresponse.metadata?.creationTime // Get the creation time as a native JS Date value\n```\n\n\nWe think that these changes will reduce errors, increase productivity, and make the code easier to read and understand.\n\n\n### Separated Node and Web Versions\n\nFor a long time, we've used a single client to interact with Weaviate from both the Web and Node.js. This made sense in the world of REST and GraphQL, which are both HTTP/1.1 protocols, but with the advent of gRPC into Weaviate since `1.24`, we now have the HTTP/2 protocol to contend with. As it transpires, gRPC and HTTP/2 don't play nicely with browsers so we've chosen to break up the new TypeScript client into Node and Web versions.\n\nDuring this open community-driven beta, you'll only have access to the Node version that can be accessed from `weaviate-client`:\n```typescript\n```\nHow we incorporate the browser version will be understood better during the open beta as we develop the capability. Until then, you can only use the beta in a Node environment.\n\nThe intention is to provide dedicated bundles optimized for each environment. The web bundle focuses on providing an easy-to-use API for browser/frontend applications using only REST and GraphQL endpoints. The Node.js bundle leverages Node.js-specific capabilities for building server applications, APIs, and CLIs, with the full gRPC functionality available.\n\nThis change is to encourage safer access and best practices as people interact with their Weaviate instances.\n\nAll CRUD (Create, Read, Update, and Delete) operations. Powered by gRPC and REST.\n\nOnly Read operations powered by GraphQL.\n\n\n\n### Collections-first approach\n\nThe other big change is that the `collections` client focuses on individual collections for interaction.\n\nThis means that you will no longer need to specify the collection name in every request. Instead, you will create an object for each collection that you want to interact with, and then use that object for all subsequent requests.\n\nFor example, take the following syntax for performing a simple request to retrieve a few objects from the database:\n\n\n```typescript\nconst response = await client.graphql\n  .get()\n  .withClassName('Article')\n  .withLimit(2)\n  .withFields('title body url')\n  .do();\n```\n\n\nBecomes:\n\n\n```typescript\nconst articles = client.collection.get('Article');\nconst response = articles.query.fetchObjects({\n  limit: 2,\n  returnProperties: ['title','body','url']\n});\n```\n\n\nYou'll see that a search is now a method that originates from the collection object.\n\nWe have observed that in most cases, you will be working with a single collection at a time. So, we think that this change will improve your efficiency and make the code more readable.\n\nThis is the same for all searches, retrieval augmented generations, and data operations such as insertion, deletion, and updating. You can access these methods through submodules like:\n\n```typescript\narticles.data  // For data operations\narticles.query  // For searches\narticles.generate  // For retrieval augmented generations\narticles.aggregate  // For aggregating results\n```\n\nWe think that these changes will make the code more readable and intuitive.\n\n## Quality-of-life improvements\n\n![As enjoyable as a nice drink at the beach](https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2dsY3gwZTUybWVmeTJ0OG1lanM0czVrb2czdWpkZXpjMW56MTR1ciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/5xtDarqlsEW6F7F14Fq/giphy.gif)\n\n> **Highlights: Simplified methods, easier defaults, batch import error handling**\n\nAs well as making these big philosophical changes, we've also made several quality-of-life improvements to the API.\n\n### Simplified methods\n\nStandalone methods with parameters now replace the builder pattern (`.with` methods) for queries. So what used to be a chain of methods like this:\n\n\n```typescript\ngeneratePrompt = 'Convert this quiz question: {question} and answer: {answer} into a trivia tweet.';\n\nresult = await client.graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withGenerate({\n    singlePrompt: generatePrompt,\n  })\n  .withNearText({\n    concepts: ['World history'],\n  })\n  .withFields('round _additional { distance }')\n  .withLimit(2)\n  .do();\n```\n\n\nBecomes:\n\n\n```typescript\nconst generatePrompt = `Convert this quiz question: {question} and answer: {answer} into a trivia tweet.`;\n\nconst myCollection = client.collections.get('JeopardyQuestion');\nconst result = await myCollection.generate.nearText(['World history'], {\n  singlePrompt: generatePrompt\n}, {\n  limit: 2,\n  returnMetadata: ['distance']\n\n})\n```\n\n\n### Property/metadata return defaults\n\nYou might have noticed that the above examples do not specify properties to be returned!\n\nWe have changed the default behavior to return all non-reference properties, e.g. `text` and `object` types, and the IDs of the objects. We think this will make it easier to get started, and for production use cases where you want to optimize the response size, you can still specify the properties you want to return.\n\nTo request additional metadata and any cross-references, you can use the `returnMetadata` and `returnReferences` options for each of the search queries.\n\n### Batch import typing\n\nBatch object, now called `insertMany()`, also gets a refresh with the introduction of a `DataObject` class. This class is used to define the properties of the object to be inserted and is then passed to the `insertMany()` method.\n\n\n```typescript\n// highlight-start\nconst articlesData: DataObject[] = dataSource.map((row) => {\n  return {\n    properties: {\n      title: row.title,\n      body: row.body,\n    },\n    vector: vectors[i],\n    uuid: generateUuid5(row.title), \n  }\n});\n// highlight-end\n\nconst articles = client.collections.get('Articles');\nconst response = await articles.data.insertMany(articlesData);\nconsole.log(response);\n```\n\nThis allows your imports to be fully type-checked by the TS compiler without fear of developer error!\n\nOh, and if you don't need to manually specify an object ID or a vector, you can just pass in a list of dictionaries!\n\n```typescript\nimport weaviate, { generateUuid5, DataObject } from 'weaviate-client'\n\n// highlight-start\nconst articlesData: DataObject[] = dataSource.map((row) => {\n  return {\n    title: row.title,\n    body: row.body,\n  };\n});\n// highlight-end\n\nconst articles = client.collections.get('Articles');\nconst response = await articles.data.insertMany(articlesData);\nconsole.log(response);\n```\n\n### Batch import error handling\n\nAnother big improvement is how we handle errors during batch data import. Many of you let us know that you would like to get more information about any errors at a macro and micro level. So, we've added a couple of features to help with this.\n\nOne is the introduction of an `Error` class that will be returned amongst the successful ID response. Here's one that we triggered by supplying an incorrect datatype:\n\n```typescript\nError(message=\"invalid text property 'url' on class 'TestArticle': not a string, but float64\", code=None, original_uuid=None)\n```\n\nThe other is that the overall response object will indicate whether there were any errors (`hasErrors` Boolean), and where they occurred (`errors` dictionary).\n\n### `Collection`-level iterator\n\nThe `cursor` API has been a popular tool for iterating through an entire collection, for example, to create manual backups or retrieve the entire set of IDs.\n\nWe've simplified the API here with a more intuitive iterator, so the syntax to extract all objects from a collection is now as simple as:\n\n```typescript\nconst articles = client.collections.get('Article')\nfor await (const article of articles.iterator()) {\n  // do something with article\n}\n```\n\nYou can also choose what properties/metadata to return, although all properties are returned by default!\n\n```typescript\nconst articles = client.collections.get('Article')\nfor await (const article of articles.iterator({ returnProperties: ['title'] })) {\n  // do something with article\n}\n```\n\n## Performance improvements\n\n![we just keep getting better and better!](https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExem9jd21oc2EwZnBmMHR5OXB6bHlnc3VoeGN5M3FoM3FyZWZ4NmVuOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/kXhXIJRLsMaTlFHYfM/giphy.gif)\n\n> **Highlights: Up to 60-80% faster imports, 3-4x faster queries**\n\nWhile a big part of this `collections` client release has been about improving the developer experience, there have been some significant performance improvements as well.\n\nUnder the hood, we expand on Weaviate's gRPC [(what is it?)](https://grpc.io/) capabilities that has been ongoing since [`v1.19` release](/blog/weaviate-1-19-release#grpc-api-support-experimental).\n\nThe short story is that your query performance and import performance will be significantly improved.\n\n### Import speeds\n\nWe've internally seen that batch data import with the new client using gRPC achieves a 60-80% speedup compared to the current client. For production use cases involving tens or hundreds of millions of objects, this can mean a significant reduction in the hours spent getting your database ready.\n\n### Query speeds\n\nBut that's not all. Even a query will execute much faster when using gRPC in comparison with GraphQL. We've seen that a small query executes 3-4 times faster(!) which is no small feat.\n\n### How was this achieved?\n\nThese speed-ups come from two benefits of using gRPC, which is a binary protocol. This means that the data is sent in a compact binary format, rather than as text, which reduces the volume of data to be sent. The other factor is that to send data as text, it needs to be processed into JSON format which is a computationally expensive process. With gRPC, the data is sent in a binary format, which is much faster to process at both the sender and receiver ends.\n\nWe won't get into the details of gRPC here, but if you are interested, you can read more about it [here](https://grpc.io/docs/what-is-grpc/introduction/). We will also be writing more about it in the future.\n\n## Object typing in focus\n\nTypeScript is a fully-featured strongly-typed language that comes with a plethora of features for the manipulation of user-defined types. This has allowed us to design and create an API where your specific types can merge with our general Weaviate types to enhance user experience and developer efficiency. Even when writing some of the tests, the IDE auto-completion and static type-checking provided by the API have been immensely helpful!\n\n> **Highlights: User-defined generics, strong typing in collections API, retrieval augmented generation, ...**\n\nWe've mentioned object typing a few times already, but let's take a closer look at a few more concrete examples. Here you can see the new syntax for collection definition, queries, and retrieval augmented generation, as well as types for each of these tasks.\n\nAll the types of the API are exported from the root file. So, when it comes to using any generic, you can access them all like so:\n```typescript\nconst collection: Collection = client.collections.get('MyCollection');\n```\n\nYou might think that exporting all the types from a single location is cumbersome. However, due to modern IDE auto-completion, all you need to do is enter the first few letters of the type into the IDE and it will prompt you to import it from where it lives! However, you will also be able to inspect some web-hosted documentation of the typing system soon!\n\n### Providing your own Generics\n\nSo, let's get into it! Providing your own generics is as simple as this:\n```typescript\ntype Article = {\n  title: string;\n  body: string;\n  wordcount: number;\n}\n\nconst collection = client.collections.get('Article');\n```\n\nThen, when you query for your articles like so:\n```typescript\nconst res = await collection.query.fetchObjects();\n```\nthen you can manipulate the objects and their properties like so:\n```typescript\nres.objects.forEach((obj) => {\n  const title = obj.title; // has type 'string'\n  const wordcount = obj.wordcount; // has type 'number'\n  const compilerError = title / wordcount // string / number not allowed by TS!\n})\n```\n\nWhen you insert objects into your collection, you get compile-time checks too!\n```typescript\nawait collection.insert({\n  title: 'TS is awesome!',\n  wordcount: 9001\n})\n// compiler error since 'body' field is missing in '.insert'\n// but is not optional in 'Article' type!\n```\n\nThere's much more to the typing system than just this and it will take you much development to discover it all! Stay tuned for a future blog post where we dive into the generics system in much more depth showing all the areas where it works to improve the Developer Experience!\n\n\n### Collection Definition\nFor many (including us), the collection definition step required multiples visit to the documentation. This was unsurprising, given that it required writing out a complex and deeply nested object that had very little type-hinting owing to the dependence on the auto-generated OpenAPI swagger types, which are not particularly instructive!\n```python\nconst classObj = {\n  'class': 'Article',\n  vectorizer: 'text2vec-openai',\n  vectorIndexConfig: {\n    distance: 'cosine',\n  },\n  moduleConfig: {\n    'generative-openai': {}\n  },\n  properties: [\n    {\n      name: 'title',\n      dataType: ['text']\n    },\n    # ...\n    {\n      name: 'url',\n      dataType: ['text'],\n      tokenization: 'field',\n      moduleConfig: {\n        'text2vec-openai': {\n          skip: true\n        },\n      }\n    },\n  ],\n};\nclient.schema\n  .classCreator()\n  .withClass(classObj)\n  .do();\n```\nWell, no more! Now, every field is strongly typed relevant to its allowed values, with your IDE guiding the way, and we are introducing a [factory class](https://en.wikipedia.org/wiki/Factory_method_pattern) so that you don't need to remember specific objects and their schemas.\n\n```typescript\nclient.collections.create({\n  name: 'Article',\n  vectorizerConfig: weaviate.configure.vectorizer.text2vecOpenai(),\n  vectorIndexConfig: weaviate.configure.vectorIndex.hnsw({\n    distanceMetric: weaviate.configure.vectorDistances.COSINE\n  }),\n  generative_config: weaviate.configure.generative.openai(),\n  properties: [\n    {\n      name: 'title',\n      dataType: weaviate.configure.dataType.TEXT,\n      tokenization: weaviate.configure.tokenization.FIELD\n    },\n    # ...\n    {\n      name: 'url',\n      dataType: 'text',\n      tokenization: 'word',\n      skipVectorization: true,\n    },\n  ]\n})\n```\n\n### Retrieval Augmented Generation\n\nAs you saw briefly earlier, we have a `.generate` submodule for retrieval augmented generation.\n\nThe structure of these mirrors those of the queries, with additional parameters added for the generation task. For example, this query:\n```typescript\nconst response = questions.query.nearText(['the space race'], {\n  limit: 2,\n})\n```\nThis can be converted to a retrieval augmented generation task by switching the submodule to `.generate` and providing the required `GenerateOptions` as the second parameter to the method:\n```typescript\n// highlight-start\nconst response = questions.generate.nearText(['the space race'], {\n  groupedTask: 'Write a haiku about these facts!' \n}, {\n// highlight-end\n  limit: 2,\n})\n```\n\n## Resources and Links\n\nAt the moment we have documented the use of the client across these sections of our documentation:\n\n- [Introduction](https://weaviate.io/developers/weaviate/introduction) \n- [Quickstart](https://weaviate.io/developers/weaviate/quickstart) \n- [Start Guides](https://weaviate.io/developers/weaviate/starter-guides) \n- [How-to: Search](https://weaviate.io/developers/weaviate/search) \n- [How-to: Manage Data](https://weaviate.io/developers/weaviate/manage-data) \n\nIf there's a section you'd like added, or see something weird in the documentation, reach out! \n\nAs a bonus, we have a bunch of really useful recipes in our [recipes-ts](https://github.com/weaviate/recipes-ts/tree/main) repository. They're meant to cover most Weaviate use cases. You can use them to see how the new client fits into your workflow. \n\n## Time to build!\n\n\n![open your laptop and tell us what you think!](https://media1.tenor.com/m/5RQ2N_m5hv8AAAAC/start-working-resident-evil-infinite-darkness.gif)\n\nAll these changes are very exciting for us and we\u2019re really eager to have you try them out and see what you build. \n\nWe have our [Experimental clients](/developers/weaviate/client-libraries/typescript) page detailing all the setup and use instructions for the new client. If something is missing, let us know by opening an issue on the Weaviate documentation repo. We\u2019d also love any feedback you might have on the client added as issues to the client repo.\n\nLet us know what you think and happy building!\n\n\n\n", "type": "Blog", "name": "Blog Typescript-client-beta", "path": "blog/2024-03-20-typescript-client-beta/index.mdx", "link": "https://weaviate.io/blog/typescript-client-beta", "timestamp": "2024-05-08 10:52:01", "reader": "JSON", "meta": {}, "chunks": []}