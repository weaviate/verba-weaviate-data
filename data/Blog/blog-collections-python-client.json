{"text": "\nThe pre-release Weaviate Python client with a new API\n\nThe `v4` client has since been officially released! Thank you to everyone who provided feedback and helped shape the client. You can find the official release announcement here.\n\n\nWe've released a pre-release version of our new Python client API. It's available for you to try out and provide feedback through this form. We've made a number of major improvements, including strong typing, a collections-first approach, and performance improvements.\n\n\n\nYou can try it here - Experimental clients.\n\n\n## Introduction\n\nWe want to ensure that Weaviate is not just powerful, but also user-friendly.\n\nAfter all, the best tools are those that are accessible and easy to integrate into your projects. This is why we prioritize client libraries for different programming languages.\n\nToday, we're thrilled to unveil our pre-release `collections` Python client API. We've designed it to be more Pythonic, leveraging modern IDE features like code completion and type hints. Moreover, we've revamped the way you work with your data.\n\nWhile our internal tests have yielded positive results, we are excited to see what you, the community, think. So, we invite you to explore this new API, share your insights, and contribute to its evolution by providing feedback.\n\nIf you're keen to try it, please head over to our Experimental clients page. There, you'll find the installation, usage and feedback instructions.\n\nLet's dive into the inspiration and core concepts behind this innovation.\n\nGoing forward, we will use the term `collection` instead of `class` to refer to the sets of objects to be stored in Weaviate. This is to avoid confusion with the generic word `class` in object-oriented programming, and in Python.\n\n## Key changes\n\nHere are the big changes!\n\n> **Highlights: Strong typing through custom Python classes, focus on individual collections for interaction**\n\nThere are two key changes to the way the `collections` client works in comparison to the existing Python client (let's call this the `Classic` client). They relate to the object typing and the way you interact with the data.\n\n| **Aspect** | **`Classic` Client** | **`Collections` Client** |\n| --- | --- | --- |\n| **Object Typing** | Primarily relied on untyped `dict` / JSONs. | Utilizes strong typing through custom Python classes. |\n| **Unit of Interaction** | Interacts with the entire database. | Focuses on individual collections for interaction. |\n\nLet's look at each of these in more detail.\n\n### Object typing\n\nThe `Classic` client primarily relied on untyped data structures like dictionaries and JSONs. While this approach offered flexibility, we saw this lead to runtime errors. Recognizing this, the collections client takes a leap forward by adding strong typing through custom Python classes in many places.\n\nThis in turn enables the things we all appreciate in our coding life - like code completion and type hints in the IDE.\nTake a look at how little actual typing is required to create a collection definition, thanks to the IDE support:\n\n\n\n\nAs a user, you will now only interact with the Python API itself and its surface rather than needing know the underlying API's surface as well. In other words, you do not have to remember the exact API parameter names, as the IDE will show you the available options. This can be a boon when you are working with less often-used options or when you are new to Weaviate.\n\nTake a look at the next example, where we are configuring the `invertedIndexConfig` for a property. The IDE shows us the available options and their descriptions.\n\n\n\n\nTypes are introduced for the data objects as well at creation time, as well as when retrieving them from the database. This means that you can access the properties of the data object directly.\n\nSo syntax that is currently like this:\n\n```python\nresponse['data']['Get']['Article'][0]['title']  # Get the `title` property of the first object\nresponse['data']['Get']['Article'][0]['_additional']['id']  # Get the ID of the first object\nresponse['data']['Get']['Article'][0]['_additional']['generate']['singleResult']  # Get the generated text from a `singlePrompt` request\nresponse['data']['Get']['Article'][0]['_additional']['generate']['groupedResult']  # Get the generated text from a `groupedTask` request\n```\n\n\nBecome:\n\n\n```python\nresponse.objects[0].properties['title']  # Get the `title` property of the first object\nresponse.objects[0].uuid  # Get the ID of the first object\nresponse.objects[0].generated  # Get the generated text from a `singlePrompt` request\nresponse.generated  # Get the generated text from a `groupedTask` request\n```\n\n\nWe think that these changes will reduce errors, increase productivity, and make the code easier to read and understand.\n\n### Collections-first approach\n\nThe other big change is that the `collections` client focuses on individual collections for interaction.\n\nThis means that you will no longer need to specify the collection name in every request. Instead, you will create an object for each collection that you want to interact with, and then use that object for all subsequent requests.\n\nFor example, take the following syntax for performing a simple request to retrieve a few objects from the database:\n\n\n```python\nresponse = (\n    client.query.get(\n        class_name=\"Article\",\n        properties=[\"title\", \"body\", \"url\"]\n    )\n    .with_limit(2)\n    .do()\n)\n```\n\n\nBecomes:\n\n\n```python\narticles = client.collection.get(\"Article\")\nresponse = articles.query.fetch_objects(limit=2)\n```\n\n\nYou'll see that a search is now a method that originates from the collection object.\n\nWe have observed that in most cases, you will be working with a single collection at a time. So, we think that this change will improve your efficiency and make the code more readable.\n\nThis is the same for all searches, retrieval augmented generations, and data operations such as insertion, deletion, and updating. You can access these methods through submodules like:\n\n```python\narticles.data  # For data operations\narticles.query  # For searches\narticles.generate  # For retrieval augmented generations\narticles.aggregate  # For aggregating results\n```\n\nWe think that these changes will make the code more readable and intuitive.\n\n## Quality-of-life improvements\n\nLook how comfortable this guy is in the hammock\n\n> **Highlights: Simplified methods, easier defaults, batch import error handling**\n\nAs well as making these big philosophical changes, we've also made a number of quality-of-life improvements to the API.\n\n### Simplified methods\n\nStandalone methods with parameters now replace the builder pattern (`with_` methods) for queries. So what used to be a chain of methods like this:\n\n\n```python\nresponse = (\n    client.query.get(\n        class_name=\"JeopardyQuestion\",\n        properties=[\"question\", \"answer\"]\n    )\n    .with_near_text({\"concepts\": [\"the space race\"]})\n    .with_generate(\n        grouped_task=\"Write a haiku about these facts!\",\n    )\n    .with_limit(2)\n    .do()\n)\n```\n\n\nBecomes:\n\n\n```python\nquestions = client.collection.get(\"JeopardyQuestion\")\nresponse = questions.generate.near_text(\n    query=\"the space race\",\n    limit=2,\n    grouped_task=\"Write a haiku about these facts!\"\n)\n```\n\n\n### Property/metadata return defaults\n\nYou might have noticed that above examples do not specify properties to be returned!\n\nWe have changed the default behavior to return most properties and metadata such as the object ID, creation time, vector search distance and so on. We think this will make it easier to get started, and for production use-cases where you want to optimize the response size, you can still specify the properties you want to return.\n\n### Batch import typing\n\nBatch object, now called `insert_many`, also gets a refresh with the introduction of a `DataObject` class. This class is used to define the properties of the object to be inserted, and is then passed to the `insert_many` method.\n\n```python\nfrom weaviate.util import generate_uuid5\n\narticles_to_add = list()\nfor i, row in enumerate(data_source):\n    # highlight-start\n    article_obj = wvc.data.DataObject(\n        properties={\n            \"title\": row[\"title\"],\n            \"body\": row[\"title\"],\n        },\n        vector=vectors[i],\n        uuid=generate_uuid5(row[\"title\"])\n    )\n    # highlight-end\n    articles_to_add.append(article_obj)\n\nresponse = articles.data.insert_many(articles_to_add)\nprint(response)\n```\n\nThis provides a more intuitive and structured way to define objects, where each object can be validated through the `DataObject` class.\n\nOh, and if you don't need to manually specify an object ID or a vector, you can just pass in a list of dictionaries!\n\n```python\nfor i, row in enumerate(data_source):\n    # highlight-start\n    article_obj = {\n        \"title\": row[\"title\"],\n        \"body\": row[\"title\"],\n    }\n    # highlight-end\n    articles_to_add.append(article_obj)\n\nresponse = articles.data.insert_many(articles_to_add)\nprint(response)\n```\n\n### Batch import error handling\n\nAnother big improvement is how we handle errors during batch data import. Many of you let us know that you would like to get more information around any errors at a macro and micro level. So, we've added a couple of features to help with this.\n\nOne is the introduction of an `Error` class that will be returned amongst the successful ID response. Here's one that we triggered by supplying an incorrect datatype:\n\n```python\nError(message=\"invalid text property 'url' on class 'TestArticle': not a string, but float64\", code=None, original_uuid=None)\n```\n\nThe other is that the overall response object will indicate whether there were any errors (`has_errors` Boolean), and where they occurred (`errors` dictionary).\n\n### `Collection`-level iterator\n\nThe `cursor` API has been a popular tool for iterating through an entire collection, for example to create manual backups or retrieving the entire set of IDs.\n\nWe've simplified the API here with a Pythonic iterator, so the syntax to extract all objects from a collection is now as simple as:\n\n```python\nall_objects = [article for article in articles.iterator()]\n```\n\nYou can also choose what properties/metadata to return.\n\n## Performance improvements\n\nTop Gun - Tom Cruise feels the need for speed\n\n> **Highlights: Up to 60-80% faster imports, 3-4x faster queries**\n\nWhile a big part of this `collections` client release has been about improving the developer experience, there has been some significant performance improvements as well.\n\nUnder the hood, we expand on Weaviate's gRPC (what is it?) capabilities that has been ongoing since `v1.19` release.\n\nThe short story is that your query performance and import performance will be significantly improved.\n\n### Import speeds\n\nWe've internally seen that batch data import with new client using gRPC achieves a 60-80% speedup compared to the current client. For production use cases involving tens or hundreds of millions of objects, this can mean significant reduction in the hours spent getting your database ready.\n\n### Query speeds\n\nBut that's not all. Even a query will execute much faster when using gRPC in comparison with GraphQL. We've seen that a small query executes 3-4 times faster(!) which is no small feat.\n\n### How was this achieved?\n\nThese speed-ups come from two benefits of using gRPC, which is a binary protocol. This means that one, the data is sent in a compact binary format, rather than as text, which reduces the volume of data to be sent. The other factor is that to send data as text, it needs to be processed into JSON format which is a computationally expensive process. With gRPC, the data is sent in a binary format, which is much faster to process at both the sender and receiver ends.\n\nWe won't get into the details of gRPC here, but if you are interested, you can read more about it here. We will also be writing more about it in the future.\n\n## Object typing in focus\n\n> **Highlights: Strong typing in queries, retrieval augmented generation, data operations, ...**\n\nWe've mentioned object typing a few times already, but let's take a closer look at a few more concrete examples. Here you can see the new syntax for collection definition, queries and retrieval augmented generation, as well as types for each of thees tasks.\n\nTo get started you can import the set of submodules like shown below, and use them as needed.\n\n```python\nimport weaviate.classes as wvc  # \n\n### Retrieval augmented generation\n\nAs you saw briefly earlier, we have a `.generate` submodule for retrieval augmented generation.\n\nThe structure of these mirror those of the queries, with additional parameters added for the generation task. For example, this query:\n\n```python\nresponse = questions.query.near_text(\n    query=\"the space race\",\n    limit=2,\n)\n```\n\nCan be converted to a retrieval augmented generation task by switching the submodule to `.generate` and adding the `grouped_task` parameter:\n\n```python\n# highlight-start\nresponse = questions.generate.near_text(\n# highlight-end\n    query=\"the space race\",\n    limit=2,\n    # highlight-start\n    grouped_task=\"Write a haiku about these facts!\"\n    # highlight-end\n)\n```\n\n## Now it's your turn\n\nTell us what you think\n\nIf you've made it this far, you're probably excited to try out the new client. We're soo excited for you to try it out too!\n\nWe have prepared a dedicated page with instructions on how to install and use the new client. The page also includes a link to the feedback form where you can share your thoughts and suggestions.\n\nWe can't wait to hear what you think.\n\nPlease reach out to us on Slack or Twitter, or on the community forum to tell us what you think.\n", "type": "Blog", "name": "blog-collections-python-client", "path": "blog/2023-09-26-collections-python-client/index.mdx", "link": "https://weaviate.io/blog/collections-python-client-preview", "timestamp": "2024-02-08 20:24:36", "reader": "JSON", "meta": {}, "chunks": []}