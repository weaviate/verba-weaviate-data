{"text": "\nUsing Weaviate with Non-English Languages, such as Hindi, Chinese, or Japanese\n\n\n\n\nRecently, many embedding models and large language models (LLMs) have shown great benefits, especially in English-centric contexts. As English is the most spoken language in the world, many language models excel in English. However, as semantic search and Generative AI applications need to be able to handle languages other than English, many language models with multilingual capabilities have already been released.\nThis blog is inspired by a recent question in our forum asking if you can use Weaviate with the Japanese language.\n\nforum_question\n\nGenerally speaking: Yes, using a Weaviate vector database for semantic and generative search in non-English languages is possible if the embedding models and LLMs used support your language of choice.\n\nThis blog explores how you can use Weaviate in your search and generative AI applications with non-English languages. Specifically, this blog discusses the challenges of non-English languages, such as the necessity of capable language models and the intricacies of languages that cannot be ASCII encoded, such as Chinese, Hindi, or Japanese. Finally, it discusses the current limitations of Weaviate when using non-English languages.\n\n## Challenges of Using Weaviate with Non-English Languages\n\nDifferent languages, such as vocabulary, grammar, and alphabets, differ in many aspects. These differences result in two key challenges when working with non-English languages in search or generative AI applications.\n\n### Language models\n\nWhether you are using English or any other language, you need to make sure the embedding model and LLM you are using support your specific language. For example, `text2vec-cohere`\u2019s `embed-multilingual-v3.0` or `text2vec-openai`\u2019s `text-embedding-ada-002` both support multiple languages. Make sure to check the chosen vectorizer module\u2019s documentation to ensure the embedding model supports your language of choice. The same applies to the generator modules.\n\n### Character encoding\n\nDifferent languages can use different alphabets, which are represented differently in computer science. The Standard ASCII format can represent the English alphabet, which encodes 128 specified characters within one byte. However, you will require the Unicode encoding standard to represent alphabets with a wider variety of characters.\n\nUnicode is a widely used encoding standard representing characters in so-called code points. You might have already seen a string like the following before:\n\n```python\n'\\u8da3\\u5473\\u306f\\u91ce\\u7403\\u3067\\u3059\\u3002'\n```\n\nThis is a sequence of escaped Unicode characters and can be easily converted to human-readable Japanese characters (\u201d\u8da3\u5473\u306f\u91ce\u7403\u3067\u3059\u3002\u201d, which means \u201cMy hobby is baseball.\u201d).\n\n## How to use Weaviate with Non-English Languages\n\nThis section uses our standard Quickstart tutorial to showcase a simple semantic search query on Japanese text data instead of English. The sample data points are taken from the forum question. You can find the related Notebook in our GitHub repository.\n\n### Step 1: Create a Weaviate database and install a client library\n\nThe first couple of steps are exactly the same for any language. \n\nFirst, you need to create a Weaviate instance to work with. For testing purposes, we recommend creating a free cloud sandbox instance on\u00a0Weaviate Cloud Services (WCS) by following the WCS quickstart\u00a0instructions. \n\nNext, you need to install your preferred Weaviate client to work with your preferred programming language.\n\n```powershell\npip install \"weaviate-client==3.*\"\n```\n\n### Step 2: Connect to Weaviate and define a data collection\n\nTo connect to your Weaviate instance, you need the\u00a0URL\u00a0and API key for your Weaviate instance (get it from WCS\u00a0`Details`\u00a0tab). Also, you will need the API key for the inferencing services you are going to use. As discussed in \"Language models,\" make sure your model supports the language you intend to use. In this case, OpenAI\u2019s `text-embedding-ada-002` model supports Japanese.\n\nRun the following example code to connect to Weaviate. You can re-use the resulting\u00a0`client`\u00a0object in the following steps.\n\n```python\nimport weaviate\nimport json\nimport os\n\nclient = weaviate.Client(\n    url = os.environ[\"WEAVIATE_URL\"],\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.environ[\"WEAVIATE_API_KEY\"]),\n    additional_headers = {\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n```\n\nNext, we define a data collection to store objects in. The following schema configures a class object with the name\u00a0`MyCollection` and a vectorizer module\u00a0`text2vec-openai`, which configures OpenAI\u2019s `text-embedding-ada-002` model by default. Additionally, the schema defines one text property `content`. Finally, you can use this schema to create the class.\n\n```python\nschema = {\n    \"class\": \"MyCollection\",\n    \"vectorizer\": \"text2vec-openai\",\n    \"moduleConfig\": {\n        \"text2vec-openai\": {},\n    },\n    \"properties\" : [\n        {\n            \"name\" : \"content\",\n            \"dataType\" : [\"text\"],\n        }\n    ]\n}\n\nclient.schema.create_class(schema)\n```\n\n### Step 3: Add data objects in Japanese\n\nYou can now add objects to Weaviate. The defined `vectorizer` automatically creates a vector embedding for each object during import. The following code loads the sample data and individually adds the data objects to the target class (`MyCollection`).\n\n```python\n\ndata = [\n    \"\u79c1\u306e\u540d\u524d\u306f\u9234\u6728(Suzuki)\u3067\u3059\u3002\u8da3\u5473\u306f\u91ce\u7403\u3067\u3059\u3002\", # My name is Suzuki. My hobby is baseball.\n    \"\u79c1\u306e\u540d\u524d\u306f\u4f50\u85e4(Sato)\u3067\u3059\u3002\u8da3\u5473\u306f\u30b5\u30c3\u30ab\u30fc\u3067\u3059\u3002\", # My name is Sato. My hobby is soccer.\n    \"\u79c1\u306e\u540d\u524d\u306f\u7530\u4e2d(Tanaka)\u3067\u3059\u3002\u8da3\u5473\u306f\u30c6\u30cb\u30b9\u3067\u3059\u3002\" # My name is Tanaka. My hobby is tennis.\n]\n\nclient.batch.configure(batch_size=10)  # Configure batch\n\n# Batch import all objects\n# (Yes, batch import is an overkill for 3 objects, but it is recommended for large volumes of data)\nwith client.batch as batch:\n    for item in data:\n        properties = {\n         \"content\": item\n        }\n\n        # the call that performs data insert\n        batch.add_data_object(\n            class_name=\"MyCollection\",\n            data_object=properties,\n        )\n```\n\n### Step 4: Semantic search query\n\nFinally, you can run a simple semantic search query on your Weaviate instance. In this case, a `nearText` search looks for objects in Weaviate with vectors most similar to those for the given input text. Run the following code to search for objects whose vectors are most similar to that of \u30d0\u30c8\u30df\u30f3\u30c8\u30f3(badminton).\n\n```python\nresponse = (\n    client.query\n    .get(\"MyCollection\", [\"content\"])\n    .with_near_text({\"concepts\": [\"\u30d0\u30c8\u30df\u30f3\u30c8\u30f3\"]})\n    .with_limit(2)\n    .do()\n)\n\nprint(json.dumps(response, indent=4, ensure_ascii=False))\n```\n\nIf you have set `ensure_ascii=False` in your `json.dumps()` function when printing the response, you should see results like this:\n\n```json\n{\n    \"data\": {\n        \"Get\": {\n            \"MyCollection\": [\n                {\n                    \"content\": \"\u79c1\u306e\u540d\u524d\u306f\u9234\u6728(Suzuki)\u3067\u3059\u3002\u8da3\u5473\u306f\u91ce\u7403\u3067\u3059\u3002\"\n                },\n                {\n                    \"content\": \"\u79c1\u306e\u540d\u524d\u306f\u7530\u4e2d(Tanaka)\u3067\u3059\u3002\u8da3\u5473\u306f\u30c6\u30cb\u30b9\u3067\u3059\u3002\"\n                }\n            ]\n        }\n    }\n}\n```\n\nThe response includes a list of objects whose vectors are most similar to the word\u00a0\u30d0\u30c8\u30df\u30f3\u30c8\u30f3. \n\nNote that if you don\u2019t set `ensure_ascii=False`, the default will be `ensure_ascii=True` and thus, you will see the results in escaped Unicode:\n\n```json\n{\n    \"data\": {\n        \"Get\": {\n            \"MyCollection\": [\n                {\n                    \"content\": \"\\u79c1\\u306e\\u540d\\u524d\\u306f\\u9234\\u6728(Suzuki)\\u3067\\u3059\\u3002\\u8da3\\u5473\\u306f\\u91ce\\u7403\\u3067\\u3059\\u3002\"\n                },\n                {\n                    \"content\": \"\\u79c1\\u306e\\u540d\\u524d\\u306f\\u7530\\u4e2d(Tanaka)\\u3067\\u3059\\u3002\\u8da3\\u5473\\u306f\\u30c6\\u30cb\\u30b9\\u3067\\u3059\\u3002\"\n                }\n            ]\n        }\n    }\n}\n```\n\nTo explore different queries, such as semantic search with filters or generative search, check out the related Jupyter Notebook on GitHub.\n\n# Current Limitations of Using Weaviate with Non-English Languages\n\nAs you saw, you can use the Weaviate vector database for semantic and generative search applications in non-English languages. However, we currently don\u2019t have any official support/policy for non-English languages, which leads to some limitations.\n\nThis limitation mainly affects Weaviate\u2019s keyword-based search functionality BM25, as we currently only have the standard English tokenizer. This means the BM25 search will return an error for most non-English languages, especially ones requiring Unicode encoding.\n\nThis limitation also affects Weaviate\u2019s hybrid search functionality. While you can conduct hybrid search queries without getting an error, all hybrid search queries with an `alpha\u00a0!= 0` will return the same results as pure semantic search. Hybrid search with an `alpha = 0` (pure keyword-based search) will return an empty result list.\n\nAs you can see, Weaviate currently doesn\u2019t cover full support for non-English languages. However, we would love to support other languages in the future. Currently, we are experimenting with implementing tokenisers for Japanese and Chinese. Please contact us on Slack if you are interested in contributing to adding non-English language support.\n\n## Summary\n\nThis blog showcased that you can use Weaviate for semantic and generative searches with non-English languages, such as Japanese, in your search and generative AI applications. To enable this functionality, you need to consider the following two points:\n\n- Ensure your embedding model (and LLM for generative searches) supports the chosen language.\n- Ensure to convert the escaped Unicode characters to human-readable characters by adding `ensure_ascii=False` to the `json.dumps()` function when printing the responses.\n\nYou can jump in and explore different queries with the related Jupyter Notebook on GitHub.\n\nPlease contact us on Slack if you are interested in contributing to adding non-English language support.\n\nimport WhatNext from '/_includes/what-next.mdx'\n\n\n", "type": "Blog", "name": "blog-weaviate-non-english-unicode", "path": "blog/2024-01-30-weaviate-non-english-unicode/index.mdx", "link": "https://weaviate.io/blog/weaviate-non-english-languages", "timestamp": "2024-02-08 20:24:44", "reader": "JSON", "meta": {}, "chunks": []}