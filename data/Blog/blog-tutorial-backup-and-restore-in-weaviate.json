{"text": "\nMaintaining data integrity is one of the key goals for database users. So it should come as no surprise that backing up the data is an important part of database best practices.\n\nAlthough it has always been possible to back up Weaviate data, doing so used to require many manual and inelegant steps. So, we have introduced a backup feature in Weaviate `v1.15` that streamlines the backup process, whether it be to a **local file system** or to a **cloud storage provider**.\n\nIf you have not yet had a chance to use this cool feature, don't worry! This tutorial will show you how to use this feature to back up your data and restore it to another Weaviate instance.\n\n## Objectives\n\nBy the end of this tutorial, you will have:\n- Spun up two instances of Weaviate,\n- Populated one Weaviate instance with a new schema & data,\n- Backed up the Weaviate instance, and\n- Restored the backup data to the other instance.\n\n## Preparations\nTo get started, clone github.com/weaviate-tutorials/weaviate-backup repository and spin up Weaviate:\n\n```bash\ndocker compose up -d\n```\n\nThe Docker Compose file (`docker-compose.yml`) has been set up to spin up two Weaviate instances for this tutorial. You should be able to connect to them at `http://localhost:8080` and `http://localhost:8090` respectively. We'll call them **W1** and **W2** from this point on for convenience.\n\nThink of **W1** as the source instance you want to back up, while **W2** is the destination instance you want to restore the backup to.\n\n### Local backups\n\nThe `docker-compose.yml` also specifies the below parameters to enable local backups.\n```yaml\nenvironment:\n  \u2026\n  ENABLE_MODULES: 'backup-filesystem'\n  BACKUP_FILESYSTEM_PATH: '/tmp/backups'\nvolumes:\n  - ./backups:/tmp/backups\n```\n\nThis enables the `backup-filesystem` module to back up data from Weaviate to the filesystem, and sets `/tmp/backups` as the `BACKUP_FILESYSTEM_PATH`, which is the backup path within the Docker container.\n\nThe `volumes` parameter mounts a volume from outside the container such that Weaviate can save data to it. Setting it to `./backups:/tmp/backups` maps `./backups` on the local device to `/tmp/backups` within the container, so the generated backup data will end up in the `./backups` directory as you will see later on.\n\nNow let's dive into it to see the backup functionality in action!\n\n### Utility scripts\nTo begin with, both Weaviate instances **W1** and **W2** should be empty. In order to get straight to the point of this tutorial, we've prepared a set of scripts (located in the `scripts` folder) that will help you prepare your Weaviate instances and test them out.\n\n\nThe tutorial text refers to shell scripts (e.g. `0_query_instances.sh`), but we also provide code examples in other languages including **Python** and **JavaScript**. These files are located in `scripts` subdirectory and we encourage you to try them out yourself using your favorite client.\n\nIf you run the `0_query_instances` script, you should see that neither instances contain a schema.\n\n```bash\nscripts/0_query_instances.sh\n```\n\nIf it is not empty, or if at any point you would like to reset your Weaviate instances, you can run the `9_delete_all` script, which will delete all of the existing schema and data at those locations.\n\n```bash\nscripts/9_delete_all.sh\n```\n\n### Populate **W1** with data\n\nAs our first order of action, we will populate **W1** with data. Run the following to create a schema and import data:\n\n```bash\nscripts/1_create_schema.sh\nscripts/2_import.sh\n```\n\nNow, running the `0_query_instances` script will return results showing the `Author` and `Book` classes in the schema as well as the objects. Great! We are ready to get to the main point of this tutorial \u2013> back up and restore.\n\n```bash\nscripts/0_query_instances.sh\n```\n\n## Back up & restore data\nNow let's move on to creating our first backup. Initiating a backup involves just a short bit of code.\n\nThe below `curl` command will back up all classes in **W1**, and call the backup `my-very-first-backup`.\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n     \"id\": \"my-very-first-backup\"\n    }' \\\nhttp://localhost:8080/v1/backups/filesystem\n```\n\nThe ID value is used to create a subdirectory in the backup location, and attempting to reuse an existing ID will cause Weaviate to throw an error. Delete the existing directory if one already exists.\n\nNow try running `3_backup` yourself to back up data from **W1**.\n\n```bash\nscripts/3_backup.sh\n```\n\nIf you check the contents of the backup directory again, you should see a new directory called `my-very-first-backup` containing the backup data files.\n\nRestoring this data can be done with a similarly short piece of code. The `curl` command below will restore our backup:\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n     \"id\": \"my-very-first-backup\"\n    }' \\\nhttp://localhost:8090/v1/backups/filesystem/my-very-first-backup/restore\n```\n\nTry running `4_restore` yourself to restore the **W1** backup data to **W2**.\n\n```bash\nscripts/4_restore.sh\n```\n\nNow, check the schemas again for **W1** and **W2**.\n\n```bash\nscripts/0_query_instances.sh\n```\n\nDo they *both* now contain the same schema? What about the data objects? They should be identical.\n\nGreat. You have successfully backed up data from **W1** and restored it onto **W2**!\n\n## Backup features\nBefore we finish, let's go back to talk a little more about additional backup options, and some important notes.\n\n### Local backup location\nIf you wish to back up your data to a different location, edit the `volumes` parameter in `docker-compose.yml` to replace `./backups` with the desired location.\n\nFor example, changing it from `./backups:/tmp/backups` to `./my_archive:/tmp/backups` would change the backup destination from `./backups` to `./my_archive/`.\n\n### Cloud storage systems\nNote, you can also configure Weaviate backup to work with **cloud storage systems** like **Google Cloud Storage** (**GCS**) and **S3-compatible blob storage** (like **AWS S3** or **MinIO**).\n\nEach requires a different Weaviate backup module (`backup-gcs` and `backup-s3`), configuration parameters and authentication.\n\n### Learn more\nCheck our documentation to learn more about:\n\n* Local backup\n* GCS backup\n* S3 backup\n\n### Partial backup and restore\nWeaviate's backup feature allows you to back up or restore a subset of available classes. This might be very useful in cases where, for example, you may wish to partially export a subset of data to a development environment or import an updated class.\n\nFor example, the below `curl` command will restore only the `Author` class regardless of whether any other classes have been also included in `my-very-first-backup`.\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n     \"id\": \"my-very-first-backup\",\n     \"include\": [\"Author\"]\n    }' \\\nhttp://localhost:8090/v1/backups/filesystem/my-very-first-backup/restore\n```\n\nDelete everything in **W2** first with `8_delete_w2`, and try out the partial restore with `4a_partial_restore`.\n\n```bash\nscripts/8_delete_w2.sh\nscripts/4a_partial_restore.sh\n```\n\nYou should see that **W2** will only contain one class even though its data was restored from a backup that contains multiple classes.\n\nThe restore function allows you to restore a class as long as the target Weaviate instance does not already contain that class. So if you run another operation to restore the `Book` class to **W2**, it will result in an instance containing both `Author` and `Book` classes.\n\n### Asynchronous operations\nIn some cases, Weaviate's response to your `backup` or `restore` request may have  `\"status\":\"STARTED\"`.\n*Isn't it interesting that the status was not indicative of a completion?*\n\nThat is because Weaviate's backup operation can be initiated and monitored asynchronously.\n\nThis means that you don't need to maintain a connection to the server for the operation to complete. And you can look in on the status of a restore operation with a command like:\n```bash\ncurl http://localhost:8090/v1/backups/filesystem/my-very-first-backup/restore\n```\n\nWeaviate remains available for read and write operations while backup operations are ongoing. And you can poll the endpoint to check its status, without worrying about any potential downtime.\n\nCheck out `3a_check_backup_status.sh` and `4b_check_restore_status.sh` for examples of how to query **W1** for the backup status, or **W2** for the restore status respectively.\n\n## Wrap-up\nThat's it for our quick overview of the new backup feature available in Weaviate. We are excited about this feature as it will make it easier and faster for you to back up your data, which will help make your applications more robust.\n\nTo recap, Weaviate's new backup feature allows you to back up one or more classes from an instance of Weaviate to a backup, and to restore one or more classes from a backup to Weaviate. Weaviate remains functional during these processes, and you can poll the backup or restore operation status periodically if you wish.\n\nWeaviate currently supports backing up to your local filesystem, AWS or GCS. But as the backup orchestration is decoupled from the remote backup storage backends, it is relatively easy to add new providers and use them with the existing backup API.\n\nIf you would like to use another storage provider to use with Weaviate, we encourage you to open a feature request or consider contributing it yourself. For either option, join our Slack community to have a quick chat with us on how to get started.\n\nimport StayConnected from '/_includes/stay-connected.mdx'\n\n\n", "type": "Blog", "name": "blog-tutorial-backup-and-restore-in-weaviate", "path": "blog/2022-11-15-tutorial-backup-and-restore-in-weaviate/index.mdx", "link": "https://weaviate.io/blog/tutorial-backup-and-restore-in-weaviate", "timestamp": "2023-11-02 11:59:09", "reader": "JSON", "meta": {}, "chunks": []}