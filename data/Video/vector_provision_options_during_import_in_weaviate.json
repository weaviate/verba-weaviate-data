{"text": "Discover different vector provision options possible in Weaviate. In this 5 minute video, we explore the various methods to provide ... \nhey there we'll have a look at some different ways in which we can provide vectors to your objects in web8 we'll show you these options by using end-to-end examples in a jupyter notebook you'll need a weeviate instance and a python environment even though the examples are in Python the concepts are Universal first of all you should note there are a few different options for getting vectors during import you can have waviate get the vector for you with a vectorized module or you can provide your own Vector we'll be covering both examples in this video first we'll instantiate the Eva client in this particular instance we'll provide the API key for the open AI API and the URL for our instance and here we've got a simple helper function to display our outputs and we'll test it out by just grabbing the metric Mission about our instance and let's quickly check the schema just to show you that it's an empty instance perfect now we'll load our data the details here are important just keep in mind that what we're loading is our set of wine reviews with a body title country and so on so this is a helper function for loading our data and now ready to import objects let's start adding some objects with previous obtained vectors we'll add a class called wine review to the schema like so with the open AI vectorizer set and if we check the schema again you'll see that the one review class has been added here and you see them down the bottom that the vectorizer is specified as the openai module and already we're ready to start adding objects so what we need to do next is to set up a batch process and load our objects one by one and to add it to the batch notice that all we're adding is a data object and the class name and we're done and just as a reminder the data object looks like that with no vectors in it so did it work let's take a look let's run an aggregate query with a count it looks like we've got 50 objects in our database that looks pretty good let's try a vector search let's try a near text query to look for some reviews relating to some fruity French wines that I enjoy so how did we do well it looks pretty good looking at these results the first review talks about some juiciness the second one talks about fruits so it's all looking pretty good let's move on to next part now we can try importing objects with our own vectors we'll go through the same steps We'll add the objects to schema we'll call this the other wine review added to the schema as the new class just note that there's no vectorizer specified here and we can add objects now we'll leave some arbitrary meaningless vectors for the demonstration here you'll notice that we've got a list comprehension that generates these vectors they don't mean anything but you'll get some unique vectors for each object so we can run that to import data into our database and we'll try our Vector search again now we can't use near text as we don't have a vectorizer but we can't use near vector and search against an arbitrary Vector of Our Own and when we do we get a series of results and you can see that the top result here is quite close to our source vector and when we scroll down the vector at the far end or the last of our search results is the furthest way which is the result that we expect fantastic what if we use another case where we provide the input vectors and use a vectorizer how would we do that and why would we do that well let's have a look at the how first we'll create a class called the other otherwise review we'll go through the same process of adding it we've added the vectorizer back in here we'll add objects and in this instance we're going to create a string out of our data object we're going to go to open Ai and get vectors back and we'll pass that Vector onto ev8 manually let's try another Vector search with this setup we'll use the same data object as the last one in the for Loop and we'll use the same Vector that was generated from it it looks like the searches work just fine with the top result being the same as our query object and the rest of them looking pretty sensible as well but more importantly this setup is useful because we can still use near text while making use of our own vectors and we see exactly that here we've run the same near text search but with our own vectors and we're able to do that because the vectors come from the same model which in this case is open AI so in summary you've seen that you can provide your vector to aviate or have weeviate handle the vectorization as to which one you use it really depends on what you're after if you provide a vector with the object that's the one that wev8 will use keep in mind that if a vectorize is not specified you cannot use near text so in some cases using a vectorizer and uploading your own Vector might give you the best of both worlds thanks for watching we'll see you next time ", "type": "Video", "name": "vector_provision_options_during_import_in_weaviate", "path": "", "link": "https://www.youtube.com/watch?v=x9ztOHUxALg", "timestamp": "", "reader": "JSON", "meta": {}, "chunks": []}