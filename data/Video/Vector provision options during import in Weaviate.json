{"text": "Discover different vector provision options possible in Weaviate. In this 5 minute video, we explore the various methods to provide ... \nhey there we'll have a look at somedifferent ways in which we can providevectors to your objects in web8we'll show you these options by usingend-to-end examples in a jupyternotebook you'll need a weeviate instanceand a python environment even though theexamples are in Python the concepts areUniversalfirst of all you should note there are afew different options for gettingvectors during import you can havewaviate get the vector for you with avectorized module or you can provideyour own Vector we'll be covering bothexamples in this videofirst we'll instantiate the Eva clientin this particular instance we'llprovide the API key for the open AI APIand the URL for our instanceand here we've got a simple helperfunction to display our outputs andwe'll test it out by just grabbing themetric Mission about our instanceand let's quickly check the schema justto show you that it's an empty instanceperfectnow we'll load our data the details hereare important just keep in mind thatwhat we're loading is our set of winereviews with a body title country and soonso this is a helper function for loadingour dataand now ready to import objects let'sstart adding some objects with previousobtained vectorswe'll add a class called wine review tothe schema like so with the open AIvectorizer set and if we check theschema again you'll see that the onereview class has been added here and yousee them down the bottom that thevectorizer is specified as the openaimodule and already we're ready to startadding objects so what we need to donext is to set up a batch processand load our objects one by one and toadd it to the batchnotice that all we're adding is a dataobject and the class name and we're doneand just as a reminder the data objectlooks like that with no vectors in it sodid it work let's take a looklet's run an aggregate query with acount it looks like we've got 50 objectsin our database that looks pretty goodlet's try a vector searchlet's try a near text query to look forsome reviews relating to some fruityFrench wines that I enjoyso how did we dowell it looks pretty good looking atthese results the first review talksabout some juiciness the second onetalks about fruitsso it's all looking pretty good let'smove on to next partnow we can try importing objects withour own vectors we'll go through thesame steps We'll add the objects toschema we'll call this the other winereview added to the schema as the newclass just note that there's novectorizer specified hereand we can add objects now we'll leavesome arbitrary meaningless vectors forthe demonstration here you'll noticethat we've got a list comprehension thatgenerates these vectors they don't meananything but you'll get some uniquevectors for each objectso we can run that to import data intoour databaseand we'll try our Vector search againnow we can't use near text as we don'thave a vectorizer but we can't use nearvector and search against an arbitraryVector of Our Ownand when we do we get a series ofresults and you can see that the topresult here is quite close to our sourcevector and when we scroll down thevector at the far end or the last of oursearch results is the furthest way whichis the result that we expect fantasticwhat if we use another case where weprovide the input vectors and use avectorizer how would we do that and whywould we do thatwell let's have a look at the how firstwe'll create a class called the otherotherwise reviewwe'll go through the same process ofadding it we've added the vectorizerback in here we'll add objectsand in this instance we're going tocreate a string out of our data objectwe're going to go to open Ai and getvectors back and we'll pass that Vectoronto ev8 manually let's try anotherVector search with this setupwe'll use the same data object as thelast one in the for Loop and we'll usethe same Vector that was generated fromit it looks like the searches work justfine with the top result being the sameas our query object and the rest of themlooking pretty sensible as well but moreimportantly this setup is useful becausewe can still use near text while makinguse of our own vectors and we seeexactly that here we've run the samenear text search but with our ownvectors and we're able to do thatbecause the vectors come from the samemodel which in this case is open AI soin summary you've seen that you canprovide your vector to aviate or haveweeviate handle the vectorization as towhich one you use it really depends onwhat you're after if you provide avector with the object that's the onethat wev8 will use keep in mind that ifa vectorize is not specified you cannotuse near text so in some cases using avectorizer and uploading your own Vectormight give you the best of both worldsthanks for watching we'll see you nexttime", "type": "Video", "name": "Vector provision options during import in Weaviate", "path": "", "link": "https://www.youtube.com/watch?v=x9ztOHUxALg", "timestamp": "", "reader": "JSON", "meta": {}, "chunks": []}