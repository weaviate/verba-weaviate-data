{"text": "Weaviate Academy Unit 2: A Look Inside. \nhey and welcome back in this section let's dive deeper into Vector searches to see how wavy it helps to make the magic happen behind the curtains we've covered a lot of ground in this unit already we've learned how to use get and aggregate functions to retrieve objects or compile information you've seen different ways of Performing Vector searches like near Vector a new object and near text and learn how to use filters such as wear limit and offset now let's take a moment to explore the vector search process in a little bit more detail you might have noticed that even though all three of them near Vector new object and near text are vector search parameters you don't actually provide a vector to aviate with near object or near text but regardless of whether you use near Vector near object or near text the actual search is always based on a vector the difference with new object or near text is that the input is converted to a vector by waviate when using the near object parameter waviate retrieves the associated Vector for the object which then becomes the input vector on the other hand when using the near text parameter where the 8 converts the input text to a vector based on the applicable vectorizer module depending on your settings it might be using an external API or a local model we'll cover more on vectorizers very soon but for now just know that they are what we V8 uses to convert objects like text or image to a vector you'll see in this section a demonstration of this by taking near object or near text searches and converting them to equivalent near Vector searches and we also talked about filtering but when does the filtering exactly happen does wavy feel to the data before the vector search or after we V8 implements pre-filtering what this means is that the specified filters are applied first result in an allowed list of objects the vector search then Returns the most relevant objects from this allow list this approach combined with efficient filtering methods enables wevia to return the right number of results and fast even when restrictive built is applied to large databases so a visualization of the vector search process might look something like this an input is provided containing filters and Vector search parameters with the filters wavier performs a pre-filtering step to obtain an allow list of objects on the other hand the vector search parameter is used to determine an input Vector which may involve an additional step such as retrieving the object's Vector with near object or vectorizing the input text with near text the input Vector is then used to perform a vector search from the objects in the allow list returning the most relevant objects or an aggregation to the user now this is something of an simplification but hopefully this gives you a good mental model of how a vector search works in leviate in terms of both how filtering Works in conjunction with the vector search and how those Vector search parameters work that's it for this video thanks for watching and we'll see you soon ", "type": "Video", "name": "Queries - A Look Inside", "path": "", "link": "https://www.youtube.com/watch?v=HTCENuuK3FU", "timestamp": "", "reader": "JSON", "meta": {}, "chunks": []}