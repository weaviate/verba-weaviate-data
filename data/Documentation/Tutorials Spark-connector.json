{"text": "\n\n## Overview\n\nThis tutorial is designed to show you an example of how to use the [Spark Connector](https://github.com/weaviate/spark-connector) to import data into Weaviate from Spark.\n\nBy the end of this tutorial, you'll be able to see how to you can import your data into [Apache Spark](https://spark.apache.org/) and then use the Spark Connector to write your data to Weaviate.\n\n## Installation\n\nWe recommend reading the [Quickstart tutorial](../quickstart/index.md) first before tackling this tutorial.\n\nWe will install the python `weaviate-client` and also run Spark locally for which we need to install the python `pyspark` package. Use the following command in your terminal to get both:\n```bash\npip3 install pyspark weaviate-client\n```\n\nFor demonstration purposes this tutorial runs Spark locally. Please see the Apache Spark docs or consult your cloud environment for installation and deploying a Spark cluster and choosing a language runtime other than Python.\n\nWe will also need the Weaviate Spark connector. You can download this by running the following command in your terminal:\n\n```bash\ncurl https://github.com/weaviate/spark-connector/releases/download/v||site.spark_connector_version||/spark-connector-assembly-||site.spark_connector_version||.jar --output spark-connector-assembly-||site.spark_connector_version||.jar\n```\n\nFor this tutorial, you will also need a Weaviate instance running at `http://localhost:8080`. This instance does not need to have any modules and can be setup by following the [Quickstart tutorial](../quickstart/index.md).\n\nYou will also need Java 8+ and Scala 2.12 installed. You can get these separately setup or a more convenient way to get both of these set up is to install [IntelliJ](https://www.jetbrains.com/idea/).\n\n## What is the Spark connector?\n\nThe Spark Connector gives you the ability to easily write data from Spark data structures into Weaviate. This is quite useful when used in conjunction with Spark extract, transform, load (ETLs) processes to populate a Weaviate vector database.\n\nThe Spark Connector is able to automatically infer the correct Spark DataType based on your schema for the class in Weaviate. You can choose to vectorize your data when writing to Weaviate, or if you already have vectors available, you can supply them. By default, the Weaviate client will create document IDs for you for new documents but if you already have IDs you can also supply those in the dataframe. All of this and more can be specified as options in the Spark Connector.\n\n## Initializing a Spark session\n\nOften a Spark Session will be created as part of your Spark environment (such as a Databricks notebook) and the only task is to add the Weaviate Spark Connector jar as a library to your cluster.\n\nIf you want to create a local Spark Session manually, use the following code to create a session with the connector:\n\n```python\nfrom pyspark.sql import SparkSession\nimport os\n\nspark = (\n    SparkSession.builder.config(\n        \"spark.jars\",\n        \"spark-connector-assembly-||site.spark_connector_version||.jar\",  #specify the spark connector JAR\n    )\n    .master(\"local[*]\")\n    .appName(\"weaviate\")\n    .getOrCreate()\n)\n\nspark.sparkContext.setLogLevel(\"WARN\")\n```\n\nYou should now have a Spark Session created and will be able to view it using the **Spark UI** at `http://localhost:4040`.\n\nYou can also verify the local Spark Session is running by executing:\n\n```python\nspark\n```\n\n## Reading data into Spark\n\nFor this tutorial we will read in a subset of the Sphere dataset, containing 100k lines, into the Spark Session that was just started.\n\nYou can download this dataset from [here](https://storage.googleapis.com/sphere-demo/sphere.100k.jsonl.tar.gz). Once downloaded extract the dataset.\n\nThe following line of code can be used to read the dataset into your Spark Session:\n\n```python\ndf = spark.read.load(\"sphere.100k.jsonl\", format=\"json\")\n```\n\nTo verify this is done correctly we can have a look at the first few records:\n\n```python\ndf.limit(3).toPandas().head()\n```\n\n## Writing to Weaviate\n\nPrior to this step, make sure your Weaviate instance is running at `http://localhost:8080`. You can refer to the [Quickstart tutorial](../quickstart/index.md) for instructions on how to set that up.\n\nTo quickly get a Weaviate instance running you can save the following `docker-compose.yml` file to your local machine:\n\n```yaml\n---\nversion: '3.4'\nservices:\n  weaviate:\n    command:\n    - --host\n    - 0.0.0.0\n    - --port\n    - '8080'\n    - --scheme\n    - http\n    image: cr.weaviate.io/semitechnologies/weaviate:||site.weaviate_version||\n    ports:\n    - 8080:8080\n    - 50051:50051\n    volumes:\n    - weaviate_data:/var/lib/weaviate\n    restart: on-failure:0\n    environment:\n      QUERY_DEFAULTS_LIMIT: 25\n      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'\n      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'\n      DEFAULT_VECTORIZER_MODULE: 'none'\n      ENABLE_MODULES: ''\n      CLUSTER_HOSTNAME: 'node1'\nvolumes:\n  weaviate_data:\n...\n```\n\nThen, navigate to the directory and start Weaviate according to the `docker-compose.yml` using:\n\n```bash\ndocker compose up -d\n```\n\nThe Spark Connector assumes that a schema has already been created in Weaviate. For this reason we will use the Python client to create this schema. For more information on how we create the schema see this [tutorial](../starter-guides/schema.md).\n\n```python\nimport weaviate\n\nclient = weaviate.Client(\"http://localhost:8080\")\n\nclient.schema.delete_all()\n\nclient.schema.create_class(\n    {\n        \"class\": \"Sphere\",\n        \"properties\": [\n            {\n                \"name\": \"raw\",\n                \"dataType\": [\"text\"]\n            },\n            {\n                \"name\": \"sha\",\n                \"dataType\": [\"text\"]\n            },\n            {\n                \"name\": \"title\",\n                \"dataType\": [\"text\"]\n            },\n            {\n                \"name\": \"url\",\n                \"dataType\": [\"text\"]\n            },\n        ],\n    }\n)\n```\n\nNext we will write the Spark dataframe to Weaviate. The `.limit(1500)` could be removed to load the full dataset.\n\n```python\ndf.limit(1500).withColumnRenamed(\"id\", \"uuid\").write.format(\"io.weaviate.spark.Weaviate\") \\\n    .option(\"batchSize\", 200) \\\n    .option(\"scheme\", \"http\") \\\n    .option(\"host\", \"localhost:8080\") \\\n    .option(\"id\", \"uuid\") \\\n    .option(\"className\", \"Sphere\") \\\n    .option(\"vector\", \"vector\") \\\n    .mode(\"append\").save()\n```\n\n## Spark connector options\n\nLet's examine the code above to understand exactly what's happening and all the settings for the Spark Connector.\n\n- Using `.option(\"host\", \"localhost:8080\")` we specify the Weaviate instance we want to write to\n\n- Using `.option(\"className\", \"Sphere\")` we ensure that the data is written to the class we just created.\n\n- Since we already have document IDs in our dataframe, we can supply those for use in Weaviate by renaming the column that is storing them to `uuid` using `.withColumnRenamed(\"id\", \"uuid\")` followed by the `.option(\"id\", \"uuid\")`.\n\n- Using `.option(\"vector\", \"vector\")` we can specify for Weaviate to use the vectors stored in our dataframe under the column named `vector` instead of re-vectorizing the data from scratch.\n\n- Using `.option(\"batchSize\", 200)` we specify how to batch the data when writing to Weaviate. Aside from batching operations, streaming is also allowed.\n\n- Using `.mode(\"append\")` we specify the write mode as `append`. Currently only the append write mode is supported.\n\nBy now we've written our data to Weaviate, and we understand the capabilities of the Spark connector and its settings. As a last step, we can query the data via the Python client to confirm that the data has been loaded.\n\n```python\nclient.query.get(\"Sphere\", \"title\").do()\n```\n\n## Additional options\n\nIf using an authenticated cluster such as on [WCS](../../wcs/quickstart.mdx) you can provide `.option(\"apiKey\", WEAVIATE_API_KEY)` for api key authentication like below:\n\n```python\ndf.limit(1500).withColumnRenamed(\"id\", \"uuid\").write.format(\"io.weaviate.spark.Weaviate\") \\\n    .option(\"batchSize\", 200) \\\n    .option(\"scheme\", \"https\") \\\n    .option(\"host\", \"demo-env.weaviate.network\") \\\n    .option(\"apiKey\", WEAVIATE_API_KEY) \\\n    .option(\"id\", \"uuid\") \\\n    .option(\"className\", \"Sphere\") \\\n    .option(\"vector\", \"vector\") \\\n    .mode(\"append\").save()\n```\n\n- Using `.option(\"retries\", 2)` will set the number of retries (default 2). Note that Spark will also retry failed stages.\n\n- Using `.option(\"retriesBackoff\", 2)` time to wait in seconds between retries (default 2 seconds).\n\n- Using `.option(\"timeout\", 60)` will set the timeout for a single batch (default 60 seconds).\n\n- Arbitrary headers can be supplied with the option prefix `header:`. For example to provide an `OPENAI_APIKEY` header the following can be used `.option(\"header:OPENAI_APIKEY\", ...)`.\n\n- Additionally OIDC options are supported `.option(\"oidc:username\", ...)`, `.option(\"oidc:password\", ...)`, `.option(\"oidc:clientSecret\", ...)`, `.option(\"oidc:accessToken\", ...)`, `.option(\"oidc:accessTokenLifetime\", ...)`, `.option(\"oidc:refreshToken\", ...)`. For more information on these options please refer to the [Java client documentation](../client-libraries/java.md#oidc-authentication).\n\n\n\n", "type": "Documentation", "name": "Tutorials Spark-connector", "path": "developers/weaviate/tutorials/spark-connector.md", "link": "https://weaviate.io/developers/weaviate/tutorials/spark-connector", "timestamp": "2024-05-08 10:51:06", "reader": "JSON", "meta": {}, "chunks": []}