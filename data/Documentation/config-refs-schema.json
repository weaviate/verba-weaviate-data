{"text": "\n\n## Introduction\n\nThis page includes details related to the collection schema, such as parameters and available configurations.\n\n\n\n\n## Collection schema creation\n\n### Mutability\n\nPlease note that only the following parameters are mutable after creation.\n\n- `description`\n- `invertedIndexConfig`\n  - `bm25`\n    - `b`\n    - `k1`\n  - `cleanupIntervalSeconds`\n  - `stopwords`\n    - `additions`\n    - `preset`\n    - `removals`\n- `replicationConfig`\n  - `factor`\n- `vectorIndexConfig`\n  - `dynamicEfFactor`\n  - `dynamicEfMin`\n  - `dynamicEfMax`\n  - `flatSearchCutoff`\n  - `skip`\n  - `vectorCacheMaxObjects`\n  - `pq`\n    - `bitCompression`\n    - `centroids`\n    - `enabled`\n    - `segments`\n    - `trainingLimit`\n    - `encoder`\n      - `type`\n      - `distribution`\n\nOther parameters cannot be changed after class creation. If you wish to change these parameters, you must delete the class and create it again.\n\nProperties can be added to a class after creation, but existing properties cannot be modified after creation.\n\n### Auto-schema\n\n\nIf you don't create a schema manually before adding data, a schema will be generated automatically. This feature is on by default, but can be disabled (e.g. in `docker-compose.yml`) by setting `AUTOSCHEMA_ENABLED: 'false'`.\n\nIt has the following characteristics:\n\n* If an object being added contains a property that does not exist in the schema, a corresponding property will be added prior to import.\n* If an object being added contains a property that conflicts with an existing schema type, an error is thrown. (e.g. trying to import text into a field that exists in the schema as `int`).\n* When an object is imported to a new collection, the collection is created including all properties.\n* The auto-schema also automatically recognizes array datatypes, such as `int[]`, `text[]`, `number[]`, `boolean[]` and `date[]`.\n* Auto-schema can automatically create nested properties for `object` and `object[]` datatypes (introduced in `v1.22.0`).\n\nGenerally speaking, we recommend that you disable auto-schema for production use. For one, a manual class definition will provide more precise control. Another reasons is that there is a performance penalty associated with inferring the data structure at import time. This may be small in most cases, but in some cases such as with complex nested properties, this may be a costly operation.\n\n### Datatypes\n\nAdditional configurations are available to help the auto-schema infer properties to suit your needs.\n\n* `AUTOSCHEMA_DEFAULT_NUMBER=number` - create `number` columns for any numerical values (as opposed to `int`, etc).\n* `AUTOSCHEMA_DEFAULT_DATE=date` - create `date` columns for any date-like values.\n\nThe following are not allowed:\n* Any map type is forbidden, unless it clearly matches one of the two supported types `phoneNumber` or `geoCoordinates`.\n* Any array type is forbidden, unless it is clearly a reference-type. In this case, Weaviate needs to resolve the beacon and see what collection the resolved beacon is from, since it needs the ClassName to be able to alter the schema.\n\n### Collection\n\nA collection describes a data object.\n\nCollection names are always written with an initial **capital letter**. This helps to distinguish collections from primitive data types when the name is used as a property value. Consider these examples using the `dataType` property:\n\n- `dataType: [\"text\"]` is `text`\n- `dataType: [\"Text\"]` is a cross-reference type to a collection named `Text`.\n\nAfter the first letter, collection names may use any GraphQL-compatible characters. The collection name validation regex is `/^[A-Z][_0-9A-Za-z]*$/`.\n\nimport initialCaps from '/_includes/schemas/initial-capitalization.md'\n\n\n\n### Properties\n\nEvery collection has properties. Properties define the kinds of data that you add to an object in Weaviate. For each property in the schema, you define at least the name and its dataType.\n\nProperty names can contain the following characters: `/[_A-Za-z][_0-9A-Za-z]*/`.\n\n## Collection object\n\nAn example of a complete collection object including properties:\n\n```json\n{\n  \"class\": \"Article\",                       // The name of the collection in string format\n  \"description\": \"An article\",              // A description for your reference\n  \"vectorIndexType\": \"hnsw\",                // Defaults to hnsw, can be omitted in schema\n                                            //    definition since this is the only available type\n                                            //    for now\n  \"vectorIndexConfig\": {\n    ...                                     // Vector index type specific settings, including distance metric\n  },\n  \"vectorizer\": \"text2vec-contextionary\",   // Vectorizer to use for data objects added to this class\n  \"moduleConfig\": {\n    \"text2vec-contextionary\": {\n      \"vectorizeClassName\": true            // Include the collection name in vector calculation (default true)\n    }\n  },\n  \"properties\": [                           // An array of the properties you are adding, same as a Property Object\n    {\n      \"name\": \"title\",                     // The name of the property\n      \"description\": \"title of the article\",              // A description for your reference\n      \"dataType\": [                         // The data type of the object as described above. When\n                                            //    creating cross-references, a property can have\n                                            //    multiple data types, hence the array syntax.\n        \"text\"\n      ],\n      \"moduleConfig\": {                     // Module-specific settings\n        \"text2vec-contextionary\": {\n          \"skip\": true,                     // If true, the whole property will NOT be included in\n                                            //    vectorization. Default is false, meaning that the\n                                            //    object will be NOT be skipped.\n          \"vectorizePropertyName\": true,    // Whether the name of the property is used in the\n                                            //    calculation for the vector position of data\n                                            //    objects. Default false.\n        }\n      },\n      \"indexFilterable\": true,              // Optional, default is true. By default each property\n                                            //    is indexed with a roaring bitmap index where\n                                            //     available for efficient filtering.\n      \"indexSearchable\": true               // Optional, default is true. By default each property\n                                            //    is indexed with a searchable index for\n                                            //    BM25-suitable Map index for BM25 or hybrid\n                                            //    searching.\n    }\n  ],\n  \"invertedIndexConfig\": {                  // Optional, index configuration\n    \"stopwords\": {\n      ...                                   // Optional, controls which words should be ignored in the inverted index, see section below\n    },\n    \"indexTimestamps\": false,               // Optional, maintains inverted indices for each object by its internal timestamps\n    \"indexNullState\": false,                // Optional, maintains inverted indices for each property regarding its null state\n    \"indexPropertyLength\": false            // Optional, maintains inverted indices for each property by its length\n  },\n  \"shardingConfig\": {\n    ...                                     // Optional, controls behavior of the collection in a\n                                            //    multi-node setting, see section below\n  },\n  \"multiTenancyConfig\": {\"enabled\": true}   // Optional, for enabling multi-tenancy for this\n                                            //    collection (default: false)\n}\n```\n\n### vectorizer\n\nThe vectorizer (`\"vectorizer\": \"...\"`) can be specified per collection in the schema object. Check the modules page for available vectorizer modules.\n\n#### Weaviate without a vectorizer\n\nYou can use Weaviate without a vectorizer by setting `\"vectorizer\": \"none\"`. This is useful if you want to upload your own vectors from a custom model (see how here), or if you want to create a collection without any vectors.\n\n### vectorIndexType\n\nThe vectorIndexType defaults to `hnsw` since this is the only available vector indexing algorithm implemented at the moment.\n\n### vectorIndexConfig\n\nCheck the `hnsw` page for `hnsw` parameters that you can configure. This includes setting the distance metric to be used with Weaviate.\n\n### shardingConfig\n\nIntroduced in v1.8.0.\n\nThe `\"shardingConfig\"` controls how a collection is sharded and distributed across multiple nodes. All values are optional and default to the following settings:\n\n```json\n  \"shardingConfig\": {\n    \"virtualPerPhysical\": 128,\n    \"desiredCount\": 1,           // defaults to the amount of Weaviate nodes in the cluster\n    \"actualCount\": 1,\n    \"desiredVirtualCount\": 128,\n    \"actualVirtualCount\": 128,\n    \"key\": \"_id\",\n    \"strategy\": \"hash\",\n    \"function\": \"murmur3\"\n  }\n```\n\nThe meaning of the individual fields in detail:\n\n* `\"desiredCount\"`: *integer, immutable, optional*, defaults to the number of nodes in the\n  cluster. This value controls how many shards should be created for this collection\n  index. The typical setting is that a collection should be distributed across all\n  the nodes in the cluster, but you can explicitly set this value to a lower\n  value. If the `\"desiredCount\"` is larger than the amount of physical nodes in the cluster, then some nodes will contain multiple shards.\n\n* `\"actualCount\"`: *integer, read-only*. Typically matches desired count, unless there was\n  a problem initiating the shards at creation time.\n\n* `\"virtualPerPhysical\"`: *integer, immutable, optional*, defaults to `128`.\n  Weaviate uses virtual shards. This helps in reducing the amount of data\n  moved when resharding.\n\n* `\"desiredVirtualCount\"`: *integer, readonly*. Matches `desiredCount *\n  virtualPerPhysical`\n\n* `\"actualVirtualCount\"`: *integer, readonly*. Like `actualCount`, but for\n  virtual shards, instead of physical.\n\n* `\"strategy\"`: *string, optional, immutable*. As of `v1.8.0` only supports `\"hash\"`. This\n  value controls how Weaviate should decide which (virtual - and therefore\n  physical) shard a new object belongs to. The hash is performed on the field\n  specified in `\"key\"`.\n\n* `\"key\"`: *string, optional, immutable*. As of `v1.8.0` only supports `\"_id\"`.\n  This value controls the partitioning key that is used for the hashing function\n  to determine the target shard. As of now, only the internal id-field\n  (containing the object's UUID) can be used to determine the target shard.\n  Custom keys may be supported at a later point.\n\n* `\"function\"`: *string, optional, immutable*. As of `v1.8.0` only `\"murmur3\"` is\n  supported as a hashing function. It describes the hashing function used on\n  the `\"key\"` property to determine the hash which in turn determines the\n  target (virtual - and therefore physical) shard. `\"murmur3\"` creates a 64bit\n  hash making hash collisions very unlikely.\n\n### replicationConfig\n\nReplication configurations can be set using the schema, through the `replicationConfig` parameter.\n\nThe `factor` parameter sets the number of copies of to be stored for objects in this collection.\n\n```json\n{\n  \"class\": \"Article\",\n  \"vectorizer\": \"text2vec-openai\",\n  // highlight-start\n  \"replicationConfig\": {\n    \"factor\": 3,\n  },\n  // highlight-end\n}\n```\n\n### invertedIndexConfig > stopwords (stopword lists)\n\nThis feature was introduced in `v1.12.0`.\n\n`text` properties may contain words that are very common and don't contribute to search results. Ignoring them speeds up queries that contain stopwords, as they can be automatically removed from queries as well. This speed up is very notable on scored searches, such as `BM25`.\n\nThe stopword configuration uses a preset system. You can select a preset to use the most common stopwords for a particular language. If you need more fine-grained control, you can add additional stopwords or remove stopwords that you believe should not be part of the list. Alternatively, you can create your custom stopword list by starting with an empty (`\"none\"`) preset and adding all your desired stopwords as additions.\n\n```json\n  \"invertedIndexConfig\": {\n    \"stopwords\": {\n      \"preset\": \"en\",\n      \"additions\": [\"star\", \"nebula\"],\n      \"removals\": [\"a\", \"the\"]\n    }\n  }\n```\n\nThis configuration allows stopwords to be configured by collection. If not set, these values are set to the following defaults:\n\n| Parameter | Default value | Acceptable values |\n| --- | --- | --- |\n| `\"preset\"` | `\"en\"` | `\"en\"`, `\"none\"` |\n| `\"additions\"` | `[]` | *any list of custom words* |\n| `\"removals\"` | `[]` | *any list of custom words* |\n\n- If `preset` is `none`, then the collection only uses stopwords from the `additions` list.\n- If the same item is included in both `additions` and `removals`, Weaviate returns an error.\n\nAs of `v1.18`, stopwords are indexed, but are skipped in BM25. Meaning, stopwords are included in the inverted index, but when the BM25 algorithm is applied, they are not considered for relevance ranking.\n\nStopwords can now be configured at runtime. You can use the RESTful API to update the list of stopwords after your data has been indexed.\n\nBelow is an example request on how to update the list of stopwords:\n\n```python\nimport weaviate\n\nclient = weaviate.Client(\"http://localhost:8080\")\n\nclass_obj = {\n    \"invertedIndexConfig\": {\n        \"stopwords\": {\n            \"preset\": \"en\",\n            \"additions\": [\"where\", \"is\", \"the\"]\n        }\n    }\n}\n\nclient.schema.update_config(\"Article\", class_obj)\n```\n\n### invertedIndexConfig > indexTimestamps\n\nThis feature was introduced in `v1.13.0`.\n\nTo perform queries that are filtered by timestamps, configure the target collection to maintain an inverted index based on the objects' internal timestamps. Currently the timestamps include `creationTimeUnix` and `lastUpdateTimeUnix`.\n\nTo configure timestamp based indexing, set `indexTimestamps` to `true` in the `invertedIndexConfig` object.\n\n```json\n  \"invertedIndexConfig\": {\n    \"indexTimestamps\": true\n  }\n```\n\n### invertedIndexConfig > indexNullState\n\nThis feature was introduced in `v1.16.0`.\n\nTo perform queries that filter on `null`, configure the target collection to maintain an inverted index that tracks `null` values for each property in a collection .\n\nTo configure `null` based indexing, setting `indexNullState` to `true` in the `invertedIndexConfig` object.\n\n```json\n  \"invertedIndexConfig\": {\n    \"indexNullState\": true\n  }\n```\n\n### invertedIndexConfig > indexPropertyLength\n\nThis feature was introduced in `v1.16.0`.\n\nTo perform queries that filter by the length of a property, configure the target collection to maintain an inverted index based on the length of the properties.\n\nTo configure indexing based on property length, set `indexPropertyLength` to `true` in the `invertedIndexConfig` object.\n\n```json\n  \"invertedIndexConfig\": {\n    \"indexPropertyLength\": true\n  }\n```\n\nUsing these features requires more resources. The additional inverted indices must be created and maintained for the lifetime of the collection.\n\n### invertedIndexConfig > bm25\n\nThe settings for BM25 are the free parameters `k1` and `b`, and they are optional. The defaults (`k1` = 1.2 and `b` = 0.75) work well for most cases.\n\nIf necessary, they can be configured in the schema per collection, and can optionally be overridden per property:\n\n```json\n{\n  \"class\": \"Article\",\n  # Configuration of the sparse index\n  \"invertedIndexConfig\": {\n    \"bm25\": {\n      \"b\": 0.75,\n      \"k1\": 1.2\n    }\n  },\n  \"properties\": [\n    {\n      \"name\": \"title\",\n      \"description\": \"title of the article\",\n      \"dataType\": [\n        \"text\"\n      ],\n      # Property-level settings override the class-level settings\n      \"invertedIndexConfig\": {\n        \"bm25\": {\n          \"b\": 0.75,\n          \"k1\": 1.2\n        }\n      },\n      \"indexFilterable\": true,\n      \"indexSearchable\": true,\n    }\n  ]\n}\n```\n\n### multiTenancyConfig\n\n\nThe `multiTenancyConfig` value determines if multi-tenancy is enabled for this collection. If enabled, objects of this collection will be isolated for each tenant. It is disabled by default.\n\nTo enable it, set the `enabled` key to `true`, as shown below:\n\n```json\n{\n  \"class\": \"MultiTenancyClass\",\n  // highlight-start\n  \"multiTenancyConfig\": {\"enabled\": true}\n  // highlight-end\n}\n```\n\n## Property object\n\nProperty names allow `/[_A-Za-z][_0-9A-Za-z]*/` in the name.\n\nAn example of a complete property object:\n\n```json\n{\n    \"name\": \"title\",                     // The name of the property\n    \"description\": \"title of the article\",              // A description for your reference\n    \"dataType\": [                         // The data type of the object as described above. When\n                                          //    creating cross-references, a property can have\n                                          //    multiple dataTypes.\n      \"text\"\n    ],\n    \"tokenization\": \"word\",               // Split field contents into word-tokens when indexing\n                                          //    into the inverted index. See \"Property\n                                          //    Tokenization\" below for more detail.\n    \"moduleConfig\": {                     // Module-specific settings\n      \"text2vec-contextionary\": {\n          \"skip\": true,                   // If true, the whole property is NOT included in\n                                          //    vectorization. Default is false, meaning that the\n                                          //    object will be NOT be skipped.\n          \"vectorizePropertyName\": true   // Whether the name of the property is used in the\n                                          //    calculation for the vector position of data\n                                          //    objects. Default false.\n      }\n    },\n    \"indexFilterable\": true,              // Optional, default is true. By default each property is\n                                          //    indexed with a roaring bitmap index where available\n                                          //    for efficient filtering.\n    \"indexSearchable\": true               // Optional, default is true. By default each property is\n                                          //    indexed with a searchable index for BM25-suitable\n                                          //    Map index for BM25 or hybrid searching.\n}\n```\n\n### Property tokenization\n\nThis feature was introduced in `v1.12.0`.\n\nYou can customize how `text` data is tokenized and indexed in the inverted index. Tokenization influences the results returned by the `bm25` and `hybrid` operators, and `where` filters.\n\nThe tokenization of `text` properties can be customized via the `tokenization` field in the property definition:\n\n```json\n{\n  \"classes\": [\n    {\n      \"class\": \"Question\",\n      \"properties\": [\n        {\n          \"dataType\": [\"text\"],\n          \"name\": \"question\",\n          // highlight-start\n          \"tokenization\": \"word\"\n          // highlight-end\n        },\n      ],\n      ...\n      \"vectorizer\": \"text2vec-openai\"\n    }\n  ]\n}\n```\n\nEach token will be indexed separately in the inverted index. For example, if you have a `text` property with the value `Hello, (beautiful) world`, the following table shows how the tokens would be indexed for each tokenization method:\n\n| Tokenization Method | Explanation                                                                  | Indexed Tokens                   |\n|---------------------|------------------------------------------------------------------------------|----------------------------------|\n| `word` (default)    | Keep only alpha-numeric characters, lowercase them, and split by whitespace. | `hello`, `beautiful`, `world`    |\n| `lowercase`         | Lowercase the entire text and split on whitespace.                           | `hello,`, `(beautiful)`, `world` |\n| `whitespace`        | Split the text on whitespace. Searches/filters become case-sensitive.        | `Hello,`, `(beautiful)`, `world` |\n| `field`             | Index the whole field after trimming whitespace characters.                  | `Hello, (beautiful) world`       |\n\n### Tokenization and search / filtering\n\nTokenization will impact how filters or keywords searches behave. This is because the filter or keyword search is also tokenized before being matched against the inverted index.\n\nThe following table shows an example scenario showing whether a filter or keyword search would identify a `text` property with value `Hello, (beautiful) world` as a hit.\n\n- **Row**: Various tokenization methods.\n- **Column**: Various search strings.\n\n|   | `Beautiful` | `(Beautiful)` | `(beautiful)` | `Hello,\u2007(beautiful)\u2007world` |\n|---|-------------|---------------|---------------|----------------------------|\n| `word` (default)    | \u2705 | \u2705 | \u2705 | \u2705 |\n| `lowercase`         | \u274c | \u2705 | \u2705 | \u2705 |\n| `whitespace`        | \u274c | \u274c | \u2705 | \u2705 |\n| `field`             | \u274c | \u274c | \u274c | \u2705 |\n\nThe `string` data type has been deprecated from Weaviate `v1.19` onwards. Please use `text` instead.\n\n\n  \n    Pre v1.19 tokenization behavior\n  \n\n**Tokenization with `text`**\n\n`text` properties are always tokenized, and by all non-alphanumerical characters. Tokens are then lowercased before being indexed. For example, a `text` property value `Hello, (beautiful) world`, would be indexed by tokens `hello`, `beautiful`, and `world`.\n\nEach of these tokens will be indexed separately in the inverted index. This means that a search for any of the three tokens with the `Equal` operator under `valueText` would return this object regardless of the case.\n\n**Tokenization with `string`**\n\n`string` properties allow the user to set whether it should be tokenized, by setting the `tokenization` collection property.\n\nIf `tokenization` for a `string` property is set to `word`, the field will be tokenized. The tokenization behavior for `string` is different from `text`, however, as `string` values are only tokenized by white spaces, and casing is not altered.\n\nSo, a `string` property value `Hello, (beautiful) world` with `tokenization` set as `word` would be split into the tokens `Hello,`, `(beautiful)`, and `world`. In this case, the `Equal` operator would need the exact match including non-alphanumerics and case (e.g. `Hello,`, not `hello`) to retrieve this object.\n\n`string` properties can also be indexed as the entire value, by setting `tokenization` as `field`. In such a case the `Equal` operator would require the value `Hello, (beautiful) world` before returning the object as a match.\n\n**Default behavior**\n\n`text` and `string` properties default to `word` level tokenization for backward-compatibility.\n\n\n\n### Inverted indexing\n\nThe `indexInverted` parameter has been deprecated from Weaviate `v1.19` onwards in lieu of `indexFilterable` and `indexSearchable`.\n\nThe `indexFilterable` and `indexSearchable` parameters control whether a property is going to be indexed for filtering and searching, respectively.\n\n`indexFilterable` determines whether a property is to be indexed with a Roaring Bitmap index for fast filtering.\n`indexSearchable` determines whether a property is to be indexed with a searchable index for BM25-suitable Map index for BM25 or hybrid searching.\n\n## Configure semantic indexing\n\n\n\n\nFor example, this data object,\n\n```js\nArticle = {\n  summary: \"Cows lose their jobs as milk prices drop\",\n  text: \"As his 100 diary cows lumbered over for their Monday...\"\n}\n```\n\nwill be vectorized as:\n\n```md\narticle cows lose their jobs as milk prices drop as his diary cows lumbered over for their monday...\n```\n\nBy default, the calculation includes the  `collection name` and all property `values`, but the property `names` *are not* indexed.\n\nTo configure vectorization behavior on a per-collection basis, use `vectorizeClassName`.\n\nTo configure vectorization on a per-property basis, use `skip` and `vectorizePropertyName`.\n\n### Default distance metric\n\nWeaviate allows you to configure the `DEFAULT_VECTOR_DISTANCE_METRIC` which will be applied to every collection unless overridden individually. You can choose from: `cosine` (default), `dot`, `l2-squared`, `manhattan`, `hamming`.\n\n```python\nclass_obj = {\n    \"class\": \"Article\",\n    \"vectorIndexConfig\": {\n        \"distance\": \"dot\",\n    },\n}\n\nclient.schema.create_class(class_obj)\n```\n\n## Related pages\n- Tutorial: Schema\n- How to: Configure a schema\n- References: REST API: Schema\n- Concepts: Data Structure\n\n\n\n\n", "type": "Documentation", "name": "config-refs-schema", "path": "developers/weaviate/config-refs/schema.md", "link": "https://weaviate.io/developers/weaviate/config-refs/schema", "timestamp": "2023-11-02 10:52:55", "reader": "JSON", "meta": {}, "chunks": []}