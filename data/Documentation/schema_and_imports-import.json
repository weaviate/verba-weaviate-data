{"text": "\n\n## &nbsp;&nbsp;Overview\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nSo far, you've learned that data in Weaviate is represented by objects, which belong to a `class`, and have a set of `properties`. In the previous section on the `schema`, you learned how to create a framework for this structure.\n\nIn this section, you will learn how to import data into Weaviate, including our recommended best practices, and some key considerations. Once you're done with this section, you will be ready to import a real dataset into Weaviate by putting together what we've learned about the schema and imports.\n\n## &nbsp;&nbsp;Imports: A high-level view\n\n### &nbsp;&nbsp;Object creation\n\nTo create a Weaviate object, you must:\n\n- Load your source data,\n- Build a data object with any desired properties, and\n- Add it to your desired class in Weaviate.\n\nOptionally, you can manually specify:\n\n- An object ID, and\n- A vector\n\n\n- An object ID is required. So, if one is not specified, Weaviate will create one.\n- If a vector is not specified, Weaviate will create one if a vectorizer is set for the class.\n\nWe'll cover these in more detail later on.\n\n### &nbsp;&nbsp;Use batch imports\n\nWeaviate offers a \"batch import\" process to maximize the import speed. Take a look at this diagram that shows the object creation process:\n\n\n\n\nIn the figure, a request is made to create an object based on the provided data.\n\nIf the vector is not provided and a vectorizer is specified, Weaviate (core) will send a request to the vectorizer module for a vector embedding. If that module is an inference-API based module, such as `text2vec-cohere`, it must then contact the inference API to request the appropriate vector.\n\nYou can imagine that in such a configuration, the network latencies may add a significant amount of time for large datasets, or become a bottleneck.\n\nA batch import significantly reduces the impact of network latencies by processing multiple objects per request, and our clients (e.g. the Python client) can parallelize the process as well. You should use batch imports unless you have a good reason not to, as it will significantly improve the speed of data ingestion.\n\n### &nbsp;&nbsp;Batch import syntax\n\nThe batch syntax is shown below, with some of the parameters:\n\n\n\n\n\n\n\nNote that here, each `data_object` would be a Python dictionary whose keys correspond to the class properties.\n\nVectors should be specified separately so that Weaviate knows it to be **the** object vector and it can be indexed. See below for the right syntax on how to specify the vector.\n\n### &nbsp;&nbsp;Error handling\n\nThe batch import process is configured to handle errors at a batch level, and at individual object level.\n\n#### Batch-level errors\n\nAny batch-level errors are indicated via the HTTP response code for the batch request.\n- A 200 response code indicates that batch was successfully sent, connected and processed.\n- A 4xx status code indicates that the request was malformed.\n\n#### Object-level errors\n\nSince a batch contains multiple objects, individual errors may occur during import even when the request was successful.\n\nAccordingly, object-level errors are returned as a part of the response the batch creation requests.\n\n### &nbsp;&nbsp;Error handling syntax\n\nIf there are any object-level errors during import, they will be visible in the returned responses to `batch.create_objects()` or `batch.create_references()`.\n\nIn the response, each object's `result[\"result\"][\"errors\"]` value can be inspected to see if there were any errors.\n\nA convenient way to do so is to define a callback function and specifying it while initializing the batch:\n\n\n\n\n\n\n\nThis pattern would capture and print any object-level errors found during the import process.\n\n## &nbsp;&nbsp;Optional parameters\n\n### &nbsp;&nbsp;ID\n\nEach object in Weaviate has a unique identifier. This ID must be a UUID, and can be user-provided, but if not, Weaviate will generate a random UUID.\n\nWeaviate does not check if a duplicate object is being created. As a result, using a deterministic uuid may prevent accidental creation of duplicate objects.\n\n### &nbsp;&nbsp;Vector\n\nEach object in Weaviate can have a vector embedding to represent it, although this is not mandatory.\n\n- If a vector is specified at creation time, Weaviate will use that vector to represent the object.\n- If a vector is not specified, Weaviate will check to see if a vectorizer setting applies to the relevant class.\n    - If so, Weaviate will send a request to that vectorizer module for a vector embedding.\n    - If not, the object will not have a vector representation.\n\n- If a vectorizer was set in the schema for the class, this vectorizer will be used.\n- If not, Weaviate will check for a default vectorizer setting for that Weaviate instance.\n\nIt is possible to both upload your own vectors and specify a vectorizer for Weaviate. For example, if you are importing a large dataset and have vectorized the data using a vectorizer that is also available through Weaviate, this may be a useful approach. This will allow you to use Weaviate to vectorize any updates to the dataset, as well as to vectorize queries as necessary.\n\nWe will explore these options in more detail in another unit.\n\n### &nbsp;&nbsp;Example with id & vector\n\nTo manually specify the object ID and vector, the syntax is as follows.\n\n\n\n\n\n\n\nWith these parameters, you have the option of manually specifying the object ID and vector.\n\n## &nbsp;&nbsp;Review\n\n### &nbsp;&nbsp;Review exercise\n\n- After studying the batch import process, try to explain it in your own words.\n    - Include in your explanation what the batch import process is, why it is used, and how it improves the speed of data ingestion.\n- Can you recall which parameters were optional in the object creation process?\n    - Can you imagine scenarios in which you might want to, or not want to, specify these parameters?\n\n### &nbsp;&nbsp;Key takeaways\n\n- To create a Weaviate object, you need to build a data object with properties, and add it to your desired class.\n- Use batch imports to maximize import speed and minimize network latency. Batch import processes multiple objects per request, and clients can parallelize the process.\n- Error handling during import can be done at the batch level or individual object level.\n- You can manually specify an object ID and vector for each object in Weaviate.\n    - If an ID is not specified, Weaviate will create one.\n    - If a vector is not specified, Weaviate will create one if a vectorizer is specified.\n    - The vectorizer setting can be set in the schema.\n\n\n\n", "type": "Documentation", "name": "schema_and_imports-import", "path": "developers/academy/zero_to_mvp/103_schema_and_imports/30_import.mdx", "link": "https://weaviate.io/developers/academy/zero_to_mvp/schema_and_imports/import", "timestamp": "2023-11-13 10:39:25", "reader": "JSON", "meta": {}, "chunks": []}