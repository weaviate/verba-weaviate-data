{"text": "\nWeaviate offers an optional authentication scheme using API keys and OpenID Connect (OIDC), which can enable various [authorizations](authorization.md) levels.\n\nWhen authentication is disabled, all anonymous requests will be granted access.\n\nIn this documentation, we cover all scenarios for your convenience:\n- [Configuring Weaviate and the client for API key use](#api-key)\n- [Configuring Weaviate and the client for OIDC](#oidc---a-systems-perspective)\n- [Configuring Weaviate for anonymous access](#anonymous-access)\n\nNote that API key and OIDC authentication can be both enabled at the same time.\n\nFor most use cases, the API key option offers a balance between security and ease of use. Give it a try first, unless you have specific requirements that necessitate a different approach.\n\nSee [this page](../installation/kubernetes.md#authentication-and-authorization) for how to set up `values.yaml` for authentication & authorization.\n\n## WCS authentication\n\n[Weaviate Cloud Services (WCS)](https://console.weaviate.cloud/) instances are pre-configured for API key [authentication](/developers/wcs/authentication.mdx).\n\n## API key\n\nTo configure Weaviate for API key-based authentication, add the following environment variables to your configuration file. \n\nAn example `docker-compose.yml` file looks like this:\n\n```yaml\nservices:\n  weaviate:\n    ...\n    environment:\n      ...\n      # Enables API key authentication.\n      AUTHENTICATION_APIKEY_ENABLED: 'true'\n\n      # List one or more keys, separated by commas. Each key corresponds to a specific user identity below.\n      AUTHENTICATION_APIKEY_ALLOWED_KEYS: 'jane-secret-key,ian-secret-key'\n\n      # List one or more user identities, separated by commas. Each identity corresponds to a specific key above.\n      AUTHENTICATION_APIKEY_USERS: 'jane@doe.com,ian-smith'\n```\n\nThe example associates API keys and users. \n\n| API key | User| \n| :- | :- |\n| `jane-secret-key` | `jane@doe.com` |\n| `ian-secret-key` | `ian-smith` |\n\nThere are two options for configuring the number of keys and users:\n- Option 1: There is exactly one user specified and any number of keys (all keys will end up using the same user).\n- Option 2: The lengths match, then key `n` will map to user `n`.\n\nThese users' permissions will be determined by the [authorization](./authorization.md) settings. Below is one such example configuration.\n\n```yaml\nservices:\n  weaviate:\n    ...\n    environment:\n      ...\n      AUTHORIZATION_ADMINLIST_ENABLED: 'true'\n      AUTHORIZATION_ADMINLIST_USERS: 'jane@doe.com,john@doe.com'\n      AUTHORIZATION_ADMINLIST_READONLY_USERS: 'ian-smith,roberta@doe.com'\n```\n\nThe example associates permissions with users. \n\n| User| User type | Permission | \n| :- | :- | :- |\n| `jane-secret-key` | Admin | Read, write |\n| `john@doe.com` | Admin | Read, write |\n| `ian-smith` | Read Only | Read |\n| `roberta@doe.com` | Read Only | Read |\n\nIn the example, `jane-secret-key` is an `admin` key, and `ian-secret-key` is a `read-only` key.\n\nYou might notice that the authorization list includes `john@doe.com` and `roberta@doe.com`. Weaviate supports a combination of API key and OIDC-based authentication. Thus, the additional users might be OIDC users.\n\n### API key: Client-side usage\n\n\n\nThe cURL command looks like this:\n\n```bash\ncurl https://${WEAVIATE_INSTANCE_URL}/v1/meta -H \"Authorization: Bearer ${WEAVIATE_API_KEY}\" | jq\n```\n\n\n\n## OIDC - A systems perspective\n\nOIDC authentication involves three parties.\n\n1. A **user** who wants to access a resource.\n1. An **identity provider (a.k.a token issuer)** (e.g. Okta, Microsoft, or WCS) that authenticates the user and issues tokens.\n1. A **resource** (in this case, Weaviate) who validates the tokens to rely on the identity provider's authentication.\n\nFor example, a setup may involve a Weaviate instance as a resource, Weaviate Cloud Services (WCS) as an identity provider, and the Weaviate client acting on behalf of the user. This document attempts to provide some perspective from each one to help you use Weaviate with authentication.\n\n\n  \n    More about OIDC\n  \n\nWith [OpenID Connect](https://openid.net/connect/) (based on OAuth2), an\nexternal identity provider and token issuer ('token issuer' hereafter) is responsible for managing users.\n\nOIDC authentication requires obtaining a valid token from the token issuer so that it can be sent in the header of any request to Weaviate. This applies to both REST and GraphQL requests.\n\nWhen Weaviate receives a token (JSON Web Token or JWT), it verifies\nthat it was indeed signed by the configured token issuer. If the signature is\ncorrect, all contents of the token are trusted, which authenticates the user based on the information in the token.\n\n\n\n## OIDC - Configuring Weaviate as the resource\n\nThis applies to anyone who is running their own Weaviate instance.\n\n### Requirements and defaults\n\nAny \"OpenID Connect\" compatible token issuer implementing OpenID Connect Discovery can be used with Weaviate. Configuring the OIDC token issuer is outside the scope of this document, but here are a few options as a starting point:\n\n- For simple use-cases such as for a single user, you can use Weaviate Cloud Services (WCS) as the OIDC token issuer. To do so:\n    - Make sure you have a WCS account (you can [sign up here](https://console.weaviate.cloud/)).\n    - In the Docker Compose file (e.g. `docker-compose.yml`), specify:\n      - `https://auth.wcs.api.weaviate.io/auth/realms/SeMI` as the issuer (in `AUTHENTICATION_OIDC_ISSUER`),\n      - `wcs` as the client id (in `AUTHENTICATION_OIDC_CLIENT_ID`), and\n      - enable the adminlist (`AUTHORIZATION_ADMINLIST_ENABLED: 'true'`) and add your WCS account email as the user (in `AUTHORIZATION_ADMINLIST_USERS`) .\n      - `email` as the username claim (in `AUTHENTICATION_OIDC_USERNAME_CLAIM`).\n\n- If you need a more customizable setup you can use commercial OIDC providers like [Okta](https://www.okta.com/).\n- As another alternative, you can run your own OIDC token issuer server, which may be the most complex but also configurable solution. Popular open-source solutions include Java-based [Keycloak](https://www.keycloak.org/) and Golang-based [dex](https://github.com/dexidp/dex).\n\nBy default, Weaviate will validate that the token includes a specified client id in the audience claim. If your token issuer does not support this feature, you can turn it off as outlined in the configuration section below.\n\n### Setting configuration options\n\nTo use OpenID Connect (OIDC), the **respective environment variables** must be correctly configured in the configuration yaml for Weaviate.\n\nAs of November 2022, we were aware of some differences in Microsoft Azure's OIDC implementation compared to others. If you are using Azure and experiencing difficulties, [this external blog post](https://xsreality.medium.com/making-azure-ad-oidc-compliant-5734b70c43ff) may be useful.\n\nThe OIDC-related Docker Compose environment variables are shown below. Please see the inline-yaml comments for details around the respective fields:\n\n```yaml\nservices:\n  weaviate:\n    ...\n    environment:\n      ...\n      # enabled (optional - defaults to false) turns OIDC auth on. All other fields in\n      # this section will only be validated if enabled is set to true.\n      AUTHENTICATION_OIDC_ENABLED: 'true'\n\n      # issuer (required) tells weaviate how to discover the token issuer. This\n      # endpoint must implement the OpenID Connect Discovery spec, so that weaviate\n      # can retrieve the issuer's public key.\n      #\n      # The example URL below uses the path structure commonly found with keycloak\n      # where an example realm 'my-weaviate-usecase' was created. The exact\n      # path structure will depend on the token issuer of your choice. Please\n      # see the respective documentation of your issuer about which endpoint\n      # implements OIDC Discovery.\n      AUTHENTICATION_OIDC_ISSUER: 'http://my-token-issuer/auth/realms/my-weaviate-usecase'\n\n      # client_id (required unless skip_client_id_check is set to true) tells\n      # Weaviate to check for a particular OAuth 2.0 client_id in the audience claim.\n      # This is to prevent that a token which was signed by the correct issuer\n      # but never intended to be used with Weaviate can be used for authentication.\n      #\n      # For more information on what clients are in OAuth 2.0, see\n      # https://tools.ietf.org/html/rfc6749#section-1.1\n      AUTHENTICATION_OIDC_CLIENT_ID: 'my-weaviate-client'\n\n      # username_claim (required) tells Weaviate which claim in the token to use for extracting\n      # the username. The username will be passed to the authorization plugin.\n      AUTHENTICATION_OIDC_USERNAME_CLAIM: 'email'\n\n      # skip_client_id_check (optional, defaults to false) skips the client_id\n      # validation in the audience claim as outlined in the section above.\n      # Not recommended to set this option as it reduces security, only set this\n      # if your token issuer is unable to provide a correct audience claim\n      AUTHENTICATION_OIDC_SKIP_CLIENT_ID_CHECK: 'false'\n\n      # scope (optional) these will be used by clients as default scopes for authentication\n      AUTHENTICATION_OIDC_SCOPES: ''\n```\n\n#### Weaviate OpenID endpoint\n\nIf you have OIDC authentication enabled, you can obtain Weaviate's OIDC configuration from the following endpoint:\n\n```bash\ncurl ${WEAVIATE_INSTANCE_URL}/v1/.well-known/openid-configuration\n```\n\nEdit ${WEAVIATE_INSTANCE_URL} to provide your instance URL.\n\n## OIDC - A client-side perspective\n\nThe OIDC standard allows for many different methods *(flows)* of obtaining tokens. The appropriate method can vary depending on your situation, including configurations at the token issuer, and your requirements.\n\nOIDC authentication flows are outside the scope of this documentation, but here are some options to consider:\n1. Use the `client credentials flow` for machine-to-machine authorization. (Note that this authorizes an app, not a user.)\n    - Validated using Okta and Azure as identity providers; GCP does not support client credentials grant flow (as of December 2022).\n    - Weaviate's Python client directly supports this method.\n    - Client credential flows usually do not come with a refresh token and the credentials are saved in the respective clients to acquire a new access token on expiration of the old one.\n1. Use the `resource owner password flow` for trusted applications like [Weaviate Cloud Services](/developers/wcs/authentication.mdx).\n1. Use `hybrid flow` if Azure is your token issuer or if you would like to prevent exposing passwords.\n\n### OIDC support for Weaviate clients\n\nIf Weaviate core is configured to use the `client credentials grant` flow or the `resource owner password flow`, a Weaviate client can instantiate a connection to Weaviate core that incorporates the authentication flow.\n\n\n\n### Manually obtaining and passing tokens\n\n\n  \n    Manually obtaining and passing tokens\n  \n\nFor cases or workflows where you may wish to manually obtain a token, we outline below the steps to do so, for the resource owner password flow and hybrid flow.\n\n#### Resource owner password flow\n\n1. Send a GET request to `WEAVIATE_INSTANCE_URL/v1/.well-known/openid-configuration` to fetch Weaviate's OIDC configuration (`wv_oidc_config`). Replace WEAVIATE_INSTANCE_URL with your instance URL.\n1. Parse the `clientId` and `href` from `wv_oidc_config`.\n1. Send a GET request to `href` to fetch the token issuer's OIDC configuration (`token_oidc_config`).\n1. If `token_oidc_config` includes the optional `grant_types_supported` key, check that `password` is in the list of values.\n    - If `password` is not in the list of values, the token issuer is likely not configured for `resource owner password flow`. You may need to reconfigure the token issuer or use another method.\n    - If the `grant_types_supported` key is not available, you may need to contact the token issuer to see if `resource owner password flow` is supported.\n1. Send a POST request to the `token_endpoint` of `token_oidc_config` with the body:\n    - `{\"grant_type\": \"password\", \"client_id\": client_id, \"username\": USERNAME, \"password\": PASSWORD`. Replace `USERNAME` and `PASSWORD` with the actual values.\n1. Parse the response (`token_resp`), and look for `access_token` in `token_resp`. This is your Bearer token.\n\n#### Hybrid flow\n\n1. Send a GET request to `WEAVIATE_INSTANCE_URL/v1/.well-known/openid-configuration` to fetch Weaviate's OIDC configuration (`wv_oidc_config`). Replace WEAVIATE_INSTANCE_URL with your instance URL.\n2. Parse the `clientId` and `href` from `wv_oidc_config`\n3. Send a GET request to `href` to fetch the token issuer's OIDC configuration (`token_oidc_config`)\n4. Construct a URL (`auth_url`) with the following parameters, based on `authorization_endpoint` from `token_oidc_config`. This will look like the following:\n    - `{authorization_endpoint}`?client_id=`{clientId}`&response_type=code%20id_token&response_mode=fragment&redirect_url=`{redirect_url}`&scope=openid&nonce=abcd\n    - the `redirect_url` must have been [pre-registered](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) with your token issuer.\n5. Go to the `auth_url` in your browser, and log in if prompted. If successful, the token issuer will redirect the browser to the `redirect_url`, with additional parameters that include an `id_token` parameter.\n6. Parse the `id_token` parameter value. This is your Bearer token.\n\n#### Code example\n\nFor those who wish to obtain OIDC tokens manually, we include an illustrative code example below in Python for demonstrating how to obtain an OIDC token.\n\n```python\nimport requests\nimport re\n\nurl = \"http://localhost:8080\"  # \n\n### Add a Bearer to a Request\n\n\n\nFor example, the cURL command looks like this:\n\n```bash\ncurl https://localhost:8080/v1/objects -H \"Authorization: Bearer ${WEAVIATE_API_KEY}\" | jq\n```\n\n\n\n## Anonymous access\nBy default, Weaviate is configured to accept requests without any authentication headers or parameters. Users that send requests without explicit authentication are authenticated as `user: anonymous`.\n\nYou can use the authorization plugin to specify which\npermissions to apply to anonymous users. If anonymous access is disabled altogether,\nany request without an allowed authentication scheme returns `401 Unauthorized`.\n\n### Configuration\nAnonymous access can be enabled or disabled in the configuration yaml using the environment variable shown below:\n\n```yaml\nservices:\n  weaviate:\n    ...\n    environment:\n      ...\n      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'\n```\n\n### How to use\n\nSend REST requests to Weaviate without any additional authentication headers or parameters.\n\n\n\n", "type": "Documentation", "name": "Configuration Authentication", "path": "developers/weaviate/configuration/authentication.md", "link": "https://weaviate.io/developers/weaviate/configuration/authentication", "timestamp": "2024-05-08 10:49:58", "reader": "JSON", "meta": {}, "chunks": []}