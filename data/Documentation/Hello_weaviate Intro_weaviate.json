{"text": "\n##  What is Weaviate?\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nWeaviate is an open-source [vector database](https://weaviate.io/blog/what-is-a-vector-database). But what does that mean? Let's unpack it here.\n\n###  Vector database\n\nWeaviate is a fantastic tool for retrieving the information you need, quickly and accurately. It does this by being an amazing **vector database**.\n\nYou may be familiar with traditional databases such as relational databases that use SQL. A database can catalog, store and retrieve information. A **vector** database can carry out these tasks also, with the key difference being that they can perform these tasks based on similarity.\n\n####  How traditional searches work\n\nImagine that you are searching a relational database containing articles on cities, to retrieve a list of \"major\" European cities. Using SQL, you might construct a query like this:\n\n```sql\nSELECT city_name wiki_summary\nFROM wiki_city\nWHERE (wiki_summary LIKE '%major European city%' OR\n       wiki_summary LIKE '%important European city%' OR\n       wiki_summary LIKE '%prominent European city%' OR\n       wiki_summary LIKE '%leading European city%' OR\n       wiki_summary LIKE '%significant European city%' OR\n       wiki_summary LIKE '%top European city%' OR\n       wiki_summary LIKE '%influential European city%' OR\n       wiki_summary LIKE '%notable European city%')\n    (\u2026 and so on)\n```\n\nWhich would return cities that contained any of these strings (`major`, `important`, `prominent`, ... etc) in the `wiki_summary` column.\n\nThis works well in many circumstances. However, there are two significant limitations with this approach.\n\n####  Limitations of traditional search\n\nUsing this type of search requires you to identify terms that *may* have been used to describe the concept, which is no easy feat.\n\nWhat's more, this doesn't solve the problem of how to rank the list of resulting objects.\n\nWith the above search query, an entry merely containing a mention of a different European city (i.e. not very relevant) would be given equal weighting to an entry for Paris, or Rome, which would be highly relevant.\n\nA vector database makes this job simpler by enabling searches based on similarity.\n\n####  Examples of vector search\n\nInstead of searching for an exact match, you could perform a query to find objects that are \"nearest\" to \"Major European city\".\n\nWhat it would then return is a list of entries that are *ranked by their similarity* to the query.\n\nIn other words, the results would reflect their similarity to the idea, or meaning, of \"Major European city\".\n\nWhat's more, Weaviate \"indexes\" the data based on their similarity, making this type of data retrieval lightning-fast.\n\nWeaviate can help you to do all this, and actually a lot more. Another way to think about Weaviate is that it supercharges the way you use information.\n\nA vector search is also referred to as a \"semantic search\" because it returns results based on the similarity of meaning (therefore \"semantic\").\n\n###  Open-source\n\nWeaviate is open-source. In other words, its [codebase is available online](https://github.com/weaviate/weaviate) for anyone to see and use[(1)](#1).\n\nAnd that is *the* codebase, regardless of how you use it. So whether you run Weaviate on your own computer, on a cloud computing environment, or through our managed service [Weaviate Cloud Services (WCS)](https://console.weaviate.cloud/), you are using the exact same technology.\n\nSo, if you want, you can run Weaviate for free on your own device, or use our managed service for convenience. You can also take comfort in that you can see exactly what you are running, and be a part of the open-source community, as well as to shape its development.\n\nIt also means that your knowledge about Weaviate is fungible, between local, cloud, or managed instances of Weaviate. So anything you learn here about Weaviate using WCS will be equally applicable to running it locally, and vice versa. \ud83d\ude09\n\n###  Information, made dynamic\n\nWe are used to thinking of information as static, like a book. But with Weaviate and modern AI-driven language models, we can do much more than just retrieve static information but easily build on top of it. Take a look at these examples:\n\n####  Question answering\n\nGiven a list of Wikipedia entries, you could ask Weaviate:\n\nWhen was Lewis Hamilton born?\n\nAnd it would answer with:\n\nLewis Hamilton was born on January 7, 1985. ([check for yourself](https://en.wikipedia.org/wiki/Lewis_Hamilton))\n\n####  Generative search\n\nOr you can synthesize passages using retrieved information with Weaviate:\n\nHere is one, where we searched Weaviate for an entry on a \"racing driver\", and produce the result in the format of:\n\nWrite a fun tweet encouraging people to read about this: ## {title} by summarizing highlights from: ## {wiki_summary}\n\nWhich produces:\n\nCheck out the amazing story of Lewis Hamilton, the 7-time Formula One World Drivers' Championship winner! From his humble beginnings to becoming one of the world's most influential people, his journey is an inspiring one. #LewisHamilton #FormulaOne #Motorsport #Racing\n\nWe will cover these and many more capabilities, such as vectorization, summarization and classification, in our units.\n\nFor now, keep in mind that Weaviate is a vector database at its core which can also leverage AI tools to do more with the retrieved information.\n\n##  Review\n\nIn this section, you learned about what Weaviate is and how it works at a very high level. You have also been introduced to what vector search is at a high level, that it is a similarity-based search method.\n\n###  Review exercises\n\n\n\n\n\n\n\n###  Key takeaways\n\n- Weaviate is an open source vector database.\n- The core Weaviate library is the same whether you run it locally, on the cloud, or with WCS.\n- Vector searches are similarity-based searches.\n- Weaviate can also transform your data after retrieving it before returning it to you.\n\n##  Notes\n\n(1) Subject to terms of its license, of course.\n\n\n\nimport Quiz from '/src/components/Academy/quiz.js'\nconst weaviateOpenSource = [\n  {\n    questionText: 'What is the difference in the Weaviate codebase between local and cloud deployments?',\n    answerOptions: [\n      { answerText: 'Cloud deployments always include additional modules.', isCorrect: false, feedback: 'Cloud deployments of Weaviate do not include any special, or additional, modules.'},\n      { answerText: 'Local deployments are optimized for GPU use.', isCorrect: false, feedback: 'GPU usage can be enabled for inference whether locally or remotely deployed.'},\n      { answerText: 'Cloud deployments are optimized for scalability.', isCorrect: false, feedback: 'We agree that cloud deployments should be optimized for scalability. But the Weaviate codebase is built for scalability regardless of deployment location.'},\n      { answerText: 'None, they are the same.', isCorrect: true, feedback: 'They are the same, open-source codebase available on GitHub.'},\n    ],\n  },\n];\nconst vectorSearchDefinition = [\n  {\n    questionText: 'What is the best description of vector search?',\n    answerOptions: [\n      { answerText: 'Vector search is a directional search.', isCorrect: false, feedback: 'The definition of \"vector\" in this context is not direction-related.'},\n      { answerText: 'Vector search is a similarity-based search.', isCorrect: true, feedback: 'It searches a data collection or database for proximity in its representation of \"meaning\".'},\n      { answerText: 'Vector search is a number-based search.', isCorrect: false, feedback: 'This is partially true, but not the best answer. While there are numbers involved, that description does not quite capture the key concept of vector searches.'},\n    ],\n  },\n];\n", "type": "Documentation", "name": "Hello_weaviate Intro_weaviate", "path": "developers/academy/theory/101_hello_weaviate/10_intro_weaviate.mdx", "link": "https://weaviate.io/developers/academy/theory/hello_weaviate/intro_weaviate", "timestamp": "2024-05-08 10:48:57", "reader": "JSON", "meta": {}, "chunks": []}