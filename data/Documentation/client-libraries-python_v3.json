{"text": "\n\nThe current Python client version is `v||site.python_client_version||`\n\nThe Python client is available in two versions: `v3` and `v4`. The `v4` client (currently in beta) is the latest version and is recommended for new projects. The `v3` client is still available for backwards compatibility, but will not be updated with new features. The documentation on this page is for the `v3` client. For the `v4` client, see this page.\n\n## Installation and setup\n\n### Requirements\n\nThe `v3` client is only compatible with Weaviate `1.21.x` and lower (i.e `\n\n### WCS authentication\n\nimport ClientAuthWCS from '/developers/weaviate/client-libraries/_components/client.auth.wcs.mdx'\n\n\n\n### API key authentication\n\n\nimport ClientAuthApiKey from '/developers/weaviate/client-libraries/_components/client.auth.api.key.mdx'\n\n\n\n```python\nimport weaviate\n\nauth_config = weaviate.AuthApiKey(api_key=\"YOUR-WEAVIATE-API-KEY\")  # Replace w/ your Weaviate instance API key\n\n# Instantiate the client with the auth config\nclient = weaviate.Client(\n    url=\"https://some-endpoint.weaviate.network\",  # Replace w/ your endpoint\n    auth_client_secret=auth_config\n)\n```\n\n### OIDC authentication\n\nimport ClientAuthOIDCIntro from '/developers/weaviate/client-libraries/_components/client.auth.oidc.introduction.mdx'\n\n\n\n####  Resource Owner Password Flow\n\nimport ClientAuthFlowResourceOwnerPassword from '/developers/weaviate/client-libraries/_components/client.auth.flow.resource.owner.password.mdx'\n\n\n\n```python\nimport weaviate\n\nresource_owner_config = weaviate.AuthClientPassword(\n  username = \"user\",\n  password = \"pass\",\n  scope = \"offline_access\" # optional, depends on the configuration of your identity provider (not required with WCS)\n  )\n\n# Initiate the client with the auth config\nclient = weaviate.Client(\"http://localhost:8080\", auth_client_secret=resource_owner_config)\n```\n\n####  Client Credentials flow\n\nimport ClientAuthFlowClientCredentials from '/developers/weaviate/client-libraries/_components/client.auth.flow.client.credentials.mdx'\n\n\n\n```python\nimport weaviate\n\nclient_credentials_config = weaviate.AuthClientCredentials(\n  client_secret = \"client_secret\",\n  scope = \"scope1 scope2\" # optional, depends on the configuration of your identity provider (not required with WCS)\n  )\n\n# Initiate the client with the auth config\nclient = weaviate.Client(\"https://localhost:8080\", auth_client_secret=client_credentials_config)\n```\n\n####  Refresh Token flow\n\nimport ClientAuthBearerToken from '/developers/weaviate/client-libraries/_components/client.auth.bearer.token.mdx'\n\n\n\n```python\nimport weaviate\n\nbearer_config = weaviate.AuthBearerToken(\n  access_token=\"some token\"\n  expires_in=300 # in seconds, by default 60s\n  refresh_token=\"other token\" # Optional\n)\n\n# Initiate the client with the auth config\nclient = weaviate.Client(\"https://localhost:8080\", auth_client_secret=bearer_config)\n```\n\n## Custom headers\n\nYou can pass custom headers to the client, which are added at initialization:\n\n```python\nclient = weaviate.Client(\n  url=\"https://localhost:8080\",\n  additional_headers={\"HeaderKey\": \"HeaderValue\"},\n)\n```\n\n## Neural Search Frameworks\n\nThere is a variety of neural search frameworks that use Weaviate under the hood to store, search through, and retrieve vectors.\n\n- deepset's haystack\n- Jina's DocArray\n\n# References documentation\n\nOn this Weaviate documentation website, you will find how to use the Python client for all RESTful endpoints and GraphQL functions. For each reference, a code block is included with an example of how to use the function with the Python (and other) clients. The Python client, however, has additional functionalities, which are covered in the full client documentation on weaviate-python-client.readthedocs.io. Some of these additional functions are highlighted here below.\n\n### Example: client.schema.create(schema)\nInstead of adding classes one by one using the RESTful `v1/schema` endpoint, you can upload a full schema in JSON format at once using the Python client. Use the function `client.schema.create(schema)` as follows:\n\n```python\nimport weaviate\n\nclient = weaviate.Client(\"http://localhost:8080\")\n\nschema = {\n  \"classes\": [{\n    \"class\": \"Publication\",\n    \"description\": \"A publication with an online source\",\n    \"properties\": [\n      {\n        \"dataType\": [\n          \"text\"\n        ],\n        \"description\": \"Name of the publication\",\n        \"name\": \"name\"\n      },\n      {\n        \"dataType\": [\n          \"Article\"\n        ],\n        \"description\": \"The articles this publication has\",\n        \"name\": \"hasArticles\"\n      },\n      {\n        \"dataType\": [\n            \"geoCoordinates\"\n        ],\n        \"description\": \"Geo location of the HQ\",\n        \"name\": \"headquartersGeoLocation\"\n      }\n    ]\n  }, {\n    \"class\": \"Article\",\n    \"description\": \"A written text, for example a news article or blog post\",\n    \"properties\": [\n      {\n        \"dataType\": [\n          \"text\"\n        ],\n        \"description\": \"Title of the article\",\n        \"name\": \"title\"\n      },\n      {\n        \"dataType\": [\n          \"text\"\n        ],\n        \"description\": \"The content of the article\",\n        \"name\": \"content\"\n      }\n    ]\n  }, {\n    \"class\": \"Author\",\n    \"description\": \"The writer of an article\",\n    \"properties\": [\n      {\n        \"dataType\": [\n            \"text\"\n        ],\n        \"description\": \"Name of the author\",\n        \"name\": \"name\"\n      },\n      {\n        \"dataType\": [\n            \"Article\"\n        ],\n        \"description\": \"Articles this author wrote\",\n        \"name\": \"wroteArticles\"\n      },\n      {\n        \"dataType\": [\n            \"Publication\"\n        ],\n        \"description\": \"The publication this author writes for\",\n        \"name\": \"writesFor\"\n      }\n    ]\n  }]\n}\n\nclient.schema.create(schema)\n```\n\n#### Example: Blog Post on How to get started with Weaviate and the Python client\n\nA full example of how to use the Python client for Weaviate can be found in this article on Towards Data Science.\n\n## Batching\n\nBatching is a way of importing/creating `objects` and `references` in bulk using a single API request to the Weaviate server. With Python this can be done using 3 different methods:\n\n1. ***Auto-batching***\n2. ***Dynamic-batching***\n3. ***Manual-batching***\n\n### Multi-threading batch import\n\n\nMulti-threading Batch import works with both `Auto-batching` and `Dynamic-batching`.\n\nTo use it, set the number of workers (threads) using the `.configure(...)` (same as `.__call__(...)`) by setting the argument `num_workers` in the batch configuration. See also Batch configuration below.\n\nMultithreading is disabled by default (num_workers=1). Use with care to not overload your Weaviate instance.\n\n**Example**\n\n```python\nclient.batch(  # or client.batch.configure(\n  batch_size=100,\n  dynamic=True,\n  num_workers=4,\n)\n```\n\n### Auto-batching\n\nThis method allows the Python client to handle all the `object` and `reference` import/creation. This means that you do NOT have to explicitly import/create objects and cross-references. All you need to do is add everything you want imported/created to the `Batch`, and the `Batch` is going to take care of creating the objects and cross-references among them. To enable auto-batching we need to configure `batch_size` to be a positive integer (by default `None`) (see Batch configuration below for more information). The `Batch` is going to import/create objects, then create cross-references, if the number of objects + number of references == `batch_size`. See example below:\n\n```python\nimport weaviate\nfrom weaviate.util import generate_uuid5\nclient = weaviate.Client(\"http://localhost:8080\")\n\n# create schema\nschema = {\n  \"classes\": [\n    {\n      \"class\": \"Author\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"dataType\": [\"text\"]\n        },\n        {\n          \"name\": \"wroteBooks\",\n          \"dataType\": [\"Book\"]\n        }\n      ]\n    },\n    {\n      \"class\": \"Book\",\n      \"properties\": [\n        {\n          \"name\": \"title\",\n          \"dataType\": [\"text\"]\n        },\n        {\n          \"name\": \"ofAuthor\",\n          \"dataType\": [\"Author\"]\n        }\n      ]\n    }\n  ]\n}\n\nclient.schema.create(schema)\n\nauthor = {\n  \"name\": \"Jane Doe\",\n}\nbook_1 = {\n  \"title\": \"Jane's Book 1\"\n}\nbook_2 = {\n  \"title\": \"Jane's Book 2\"\n}\n\nclient.batch.configure(\n  batch_size=5, # int value for batch_size enables auto-batching, see Batch configuration section below\n)\n\nwith client.batch as batch:\n  # add author\n  uuid_author = generate_uuid5(author, \"Author\")\n  batch.add_data_object(\n    data_object=author,\n    class_name=\"Author\",\n    uuid=uuid_author,\n  )\n  # add book_1\n  uuid_book_1 = generate_uuid5(book_1, \"Book\")\n  batch.add_data_object(\n    data_object=book_1,\n    class_name=\"Book\",\n    uuid=uuid_book_1,\n  )\n  # add references author ---> book_1\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_1,\n    to_object_class_name=\"Book\",\n  )\n  # add references author  book_2\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_2,\n    to_object_class_name=\"Book\",\n  )\n  # add references author  book_1\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_1,\n    to_object_class_name=\"Book\",\n  )\n  # add references author  book_2\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_2,\n    to_object_class_name=\"Book\",\n  )\n  # add references author  book_1\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_1,\n    to_object_class_name=\"Book\",\n  )\n  # add references author  book_2\n  batch.add_reference(\n    from_object_uuid=uuid_author,\n    from_object_class_name=\"Author\",\n    from_property_name=\"wroteBooks\",\n    to_object_uuid=uuid_book_2,\n    to_object_class_name=\"Book\",\n  )\n  # add references author =3.9.0`.\n- `num_workers` - (`int`, default `1`): The maximal number of concurrent threads to run batch import. Only used for non-MANUAL batching. i.e. is used only with AUTO or DYNAMIC batching. ***Use with care to not overload your Weaviate instance.*** **NOTE:** Available in `weaviate-client>=3.9.0`.\n\nNOTE: You have to specify all the configurations that you want at each call of this method, otherwise some setting are going to be replaced by default values.\n```python\nclient.batch(\n  batch_size=100,\n  dynamic=False,\n  creation_time=5,\n  timeout_retries=3,\n  connection_error_retries=5,\n  callback=None,\n  num_workers=1,\n)\n```\n\n### Tips &amp; Tricks\n\n* There is no limit to how many objects/references one could add to a batch before committing/creating it. However a too large batch can lead to a TimeOut error, which means that Weaviate could not process and create all the objects from the batch in the specified time (the timeout configuration can be set like this or this). Note that setting a timeout configuration higher that 60s would require some changes to the docker-compose.yml/helm chart file.\n* The `batch` class in the Python Client can be used in three ways:\n    * Case 1: Everything should be done by the user, i.e. the user should add the objects/object-references and create them whenever the user wants. To create one of the data type use these methods of this class: `create_objects`, `create_references` and `flush`. This case has the Batch instance's batch_size set to None (see docs for the `configure` or `__call__` method). Can be used in a context manager, see below.\n    * Case 2: Batch auto-creates when full. This can be achieved by setting the Batch instance's batch_size set to a positive integer (see docs for the `configure` or `__call__` method). The batch_size in this case corresponds to the sum of added objects and references. This case does not require the user to create the batch/s, but it can be done. Also to create non-full batches (last batches) that do not meet the requirement to be auto-created use the `flush` method. Can be used in a context manager, see below.\n    * Case 3: Similar to Case II but uses dynamic batching, i.e. auto-creates either objects or references when one of them reached the `recommended_num_objects` or `recommended_num_references` respectively. See docs for the `configure` or `__call__` method for how to enable it.\n    * **Context-manager support**: Can be use with the with statement. When it exists the context-manager it calls the flush method for you. Can be combined with `configure` or `__call__` method, in order to set it to the desired Case.\n\n### Error Handling\n\nCreating objects in `Batch` is faster then creating each object/reference individually but it comes at the cost of skipping some validation steps. Skipping some validation steps at object/reference level can result in some objects that failed to create or some references that could not be added. In this case the `Batch` does not fail but individual objects/references might and we can make sure that everything was imported/created without errors by checking the returned value of the `batch.create_objects()` and `batch.create_references()`. Here are examples how to catch and handle errors on individual `Batch` objects/references.\n\nLets define a function that checks for such errors and prints them:\n```python\ndef check_batch_result(results: dict):\n  \"\"\"\n  Check batch results for errors.\n\n  Parameters\n  ----------\n  results : dict\n      The Weaviate batch creation return value.\n  \"\"\"\n\n  if results is not None:\n    for result in results:\n      if \"result\" in result and \"errors\" in result[\"result\"]:\n        if \"error\" in result[\"result\"][\"errors\"]:\n          print(result[\"result\"])\n```\n\nNow we can use this function to print the error messages at item (object/reference) level. Lets look how we can do it using Auto-/Dynamic-batching where we never implicitly call the `create` methods:\n\n```python\nclient.batch(\n  batch_size=100,\n  dynamic=True,\n  creation_time=5,\n  timeout_retries=3,\n  connection_error_retries=3,\n  callback=check_batch_result,\n)\n\n# done, easy as that\n```\n\nFor Manual-batching we can call the function on the returned value:\n```python\n# on objects\nresult = client.batch.create_object()\ncheck_batch_result(result)\n\n# on references\nresult = client.batch.create_references()\ncheck_batch_result(result)\n```\n\n## Design\n\n### GraphQL query builder pattern\n\nFor complex GraphQL queries (e.g. with filters), the client uses a builder pattern to form the queries. An example is the following query with multiple filters:\n\n```python\nimport weaviate\nclient = weaviate.Client(\"http://localhost:8080\")\n\nwhere_filter = {\n  \"path\": [\"wordCount\"],\n  \"operator\": \"GreaterThan\",\n  \"valueInt\": 1000\n}\n\nnear_text_filter = {\n  \"concepts\": [\"fashion\"],\n  \"certainty\": 0.7,\n  \"moveAwayFrom\": {\n    \"concepts\": [\"finance\"],\n    \"force\": 0.45\n  },\n  \"moveTo\": {\n    \"concepts\": [\"haute couture\"],\n    \"force\": 0.85\n  }\n}\n\nquery_result = client.query\\\n    .get(\"Article\", [\"title\"])\\\n    .with_where(where_filter)\\\n    .with_near_text(near_text_filter)\\\n    .with_limit(50)\\\n    .do()\n\nprint(query_result)\n```\n\nNote that you need to use the `.do()` method to execute the query.\n\nYou can use `.build()` to inspect the resulting GraphQL query\n\n```python\nquery_result = client.query\\\n    .get(\"Article\", [\"title\"])\\\n    .with_where(where_filter)\\\n    .with_near_text(near_text_filter)\\\n    .with_limit(50)\n\nquery_result.build()\n\n>>> '{Get{Article(where: {path: [\"wordCount\"] operator: GreaterThan valueInt: 1000} limit: 50 nearText: {concepts: [\"fashion\"] certainty: 0.7 moveTo: {force: 0.85 concepts: [\"haute couture\"]} moveAwayFrom: {force: 0.45 concepts: [\"finance\"]}} ){title}}}'\n\n```\n\n## Best practices and notes\n\n### Thread-safety\n\nWhile the Python client is fundamentally designed to be thread-safe, it's important to note that due to its dependency on the `requests` library, complete thread safety isn't guaranteed.\n\nThis is an area that we are looking to improve in the future.\n\nPlease be particularly aware that the batching algorithm within our client is not thread-safe. Keeping this in mind will help ensure smoother, more predictable operations when using our Python client in multi-threaded environments.\n\nIf you are performing batching in a multi-threaded scenario, ensure that only one of the threads is performing the batching workflow at any given time. No two threads can use the same `client.batch` object at one time.\n\n## Client releases\n\n\n\n\n## Change logs\n\nFor more detailed information on client updates, check the change logs. The logs\nare hosted here:\n\n- GitHub\n- Read the Docs\n\n\n\n\n", "type": "Documentation", "name": "client-libraries-python_v3", "path": "developers/weaviate/client-libraries/python_v3.md", "link": "https://weaviate.io/developers/weaviate/client-libraries/python_v3", "timestamp": "2023-11-13 10:40:23", "reader": "JSON", "meta": {}, "chunks": []}