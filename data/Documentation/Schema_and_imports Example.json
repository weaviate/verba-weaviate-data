{"text": "\n##  Overview\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nIt's time to put what we've learned into action! In this section, we will:\n\n- Download a small dataset,\n- Build a schema corresponding to the dataset, and\n- Import it to our WCS instance.\n\n###  Dataset used\n\nWe are going to use data from a popular quiz game show called *Jeopardy!*.\n\nThe original dataset can be found [here on Kaggle](https://www.kaggle.com/datasets/tunguz/200000-jeopardy-questions), but we'll use a [small subset from it, just containing 100 rows](https://raw.githubusercontent.com/weaviate-tutorials/edu-datasets/main/jeopardy_100.json).\n\nHere's a preview of a few rows of data.\n\n|    | Air Date   | Round            |   Value | Category         | Question                                                                                                             | Answer                                     |\n|---:|:-----------|:-----------------|--------:|:-----------------|:---------------------------------------------------------------------------------------------------------------------|:-------------------------------------------|\n|  0 | 2006-11-08 | Double Jeopardy! |     800 | AMERICAN HISTORY | Abraham Lincoln died across the street from this theatre on April 15, 1865                                           | Ford's Theatre (the Ford Theatre accepted) |\n|  1 | 2005-11-18 | Jeopardy!        |     200 | RHYME TIME       | Any pigment on the wall so faded you can barely see it                                                               | faint paint                                |\n|  2 | 1987-06-23 | Double Jeopardy! |     600 | AMERICAN HISTORY | After the original 13, this was the 1st state admitted to the union                                                  | Vermont                                    |\n\nFor now, let's keep it simple by populating Weaviate with just the `Round`, `Value`, `Question` and `Answer` columns.\n\nCan you remember what the next steps should be?\n\n##  Build a schema\n\nThe next step is to build a schema, making some decisions about how to represent our data in Weaviate.\n\n###  Add class names & properties\n\nFirst of all, we'll need a name. The name refers to each row or item (*note: singular*), so I called it `JeopardyQuestion`. Then, I need to define properties and types.\n\nYou saw above that we'll be populating Weaviate with `Round`, `Value`, `Question` and `Answer` columns. We need names for Weaviate `properties` - these names are sensible, but we follow the GraphQL convention of capitalizing classes and leaving properties as lowercases, so the names will be `round`, `value`, `question` and `answer`.\n\nThen, we should select datatypes. All of `round`, `question` and `answer` are text, so we can simply choose `text` as our datatype. `value` is a number, but I know that values in *Jeopardy!* represent dollar amounts, meaning that they are always integers. So we'll use `int`.\n\n\n\n\n\n\n\n###  Set & configure the vectorizer\n\nFor this example, we will obtain our object vectors using an inference service. So to do that, we must set the `vectorizer` for the class. We'll use `text2vec-openai` in this case, and we can configure the module also at the class-level.\n\n\n\n\n\n\n\n###  Skipping a property from vectorization\n\nYou might have noticed the property-level module configuration here:\n\n\n\n\n\n\n\nThis configuration will exclude the `round` property from the vectorized text. You might be asking - why might we choose to do this?\n\nWell, the answer is that whether the question belonged to \"Jeopardy!\", or \"Double Jeopardy!\" rounds simply do not add much to impact its meaning. You know by now that the vectorizer creates a vector representation of the object. In case of a text object, Weaviate first combines the text data according to an internal set of rules and your configuration.\n\nIt is the combined text that is vectorized. So, the difference between vectorizing the `round` property and skipping it would be something like this:\n\n```json\n// If the property is vectorized\nanswer {answer_text} question {question_text} category {category_text}\n```\n\nAgainst:\n\n```json\n// If the property is skipped\nanswer {answer_text} question {question_text}\n```\n\nMore specifically, something like the difference between:\n\n```json\n// If the property is vectorized\nanswer faint paint question any pigment on the wall so faded you can barely see it category double jeopardy!\n```\n\nAgainst:\n\n```json\n// If the property is skipped\nanswer faint paint question any pigment on the wall so faded you can barely see it\n```\n\nThe additional information is not particularly significant in capturing the meaning of the quiz item, which is mainly in the question and answer, as well as perhaps the category (not yet used).\n\nImportantly, excluding the `round` column from vectorization will have no impact on our ability to filter the results based on the `round` value. So if you wanted to only search a set of `Double Jeopardy!` questions, you still can.\n\n###  Create the class\n\nWe can now add the class to the schema.\n\n\n\n\n\n\n\nNow, you can check that the class has been created successfully by retrieving its schema:\n\n\n\n\n\n\n\n\n   See the full schema response\n\n\n\n\n\nAlthough we've defined a lot of details here, the retrieved schema is still longer. The additional details relate to the vector index, the inverted index, sharding and tokenization. We'll cover many of those as we go.\n\nIf you see a schema that is close to the example response - awesome! You're ready to import the data.\n\n##  Import data\n\nHere, we'll show you how to import the requisite data, including how to configure and use a batch.\n\n###  Load data\n\nWe've made the data available online - so, fetch and load it like so:\n\n\n\n###  Configure batch and import data\n\nAnd let's set up a batch import process. As mentioned earlier, the batch import process in Weaviate can send data in bulk and in parallel.\n\nIn Python, we recommend that you use a context manager like:\n\n\n\nNote the use of parameters `batch_size` and `num_workers`. They specify the number of objects sent per batch, as well as how many processes are used for parallelization.\n\nThen, the next step is to build data objects & add them to the batch process. We build objects (as Python dictionaries) by passing data from  corresponding columns to the right Weaviate property, and the client will take care of when to send them.\n\n\n\nThen, let's check that we've got the right number of objects imported:\n\n\n\nIf this assertion returns `True`, you've successfully populated your Weaviate instance!\n\n###  What happens if this runs again?\n\nBefore we go on, I have a question. What do you think will happen if you run the above import script again?\n\n\n   The answer is... \n\nThat you will end up with duplicate items!\n\nWeaviate does not check if you are uploading items with the same properties as ones that exist already. And since the import script did not provide an ID, Weaviate will simply assign a new, random ID, and create new objects.\n\n\n\n###  Specify object UUID\n\nYou could specify an object UUID at import time to serve as the object identifier. The Weaviate Python client, for example, provides a function to create a deterministic UUID based on an object. So, it could be added to our import script as shown below:\n\n\n\nWhat this will do is to create objects whose UUID is based on the object properties. Accordingly, if the object properties remain the same, so will the UUID.\n\nRunning the above script multiple times will *not* cause the number of objects to increase.\n\nBecause the UUID is based on the object properties, it will still create new objects in case some property has changed. So, when you design your import process, consider what properties might change, and how you would want Weaviate to behave in these scenarios.\n\nThen you could, for instance, design your UUID to be created based on a subset of unique properties, to have the objects be overwritten, or alternatively have the UUID be created from the entire set of properties to only prevent duplicates.\n\n###  Full import script\n\nPutting it all together, we get the following import script:\n\n\n\n##  Review\n\n###  Key takeaways\n\nWe have:\n- Downloaded a small dataset of Jeopardy! questions and answers.\n- Built a schema and imported our data.\n- Verified the successful import by checking the object count in Weaviate.\n\n\n", "type": "Documentation", "name": "Schema_and_imports Example", "path": "developers/academy/py/zero_to_mvp/103_schema_and_imports/40_example.mdx", "link": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/example", "timestamp": "2024-05-08 10:48:45", "reader": "JSON", "meta": {}, "chunks": []}