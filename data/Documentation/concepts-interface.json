{"text": "\n\n- References: GraphQL API\n- References: RESTful API.\n- References: Client Libraries.\n\n## Introduction\n\nYou can manage and use Weaviate through its APIs. Weaviate has a RESTful API and a GraphQL API. The client libraries in all languages support all API functions. Some clients, e.g. the Python client, have additional functionality, such as full schema management and batching operations. This way, Weaviate is easy to use in custom projects. Additionally, the APIs are intuitive, so it is easy to integrate into your existing data landscape.\n\nThis page contains information on how Weaviate's APIs are designed, and how you can use Weaviate Console to search through your Weaviate instance with GraphQL.\n\n## API Design\n\n### Design: UX & Weaviate Features\n\nUser Experience (UX) is one of our most valuable principles. Weaviate should be easy to understand, intuitive to use and valuable, desirable and usable to the community. The interaction with Weaviate is naturally very important for its UX. Weaviate's APIs are designed from the perspective of user needs, keeping the software features in mind. We do user research, user testing and prototyping to make sure all features resonate with our users. User requirements are continuously gathered during collaborative discussions. We match user needs with the functions of Weaviate. When there is a strong need from the user or application perspective, we may extend Weaviate's functions and APIs. When there is a new Weaviate function, this will naturally be accessible via (new) API functions.\n\nThe UX of Weaviate's APIs is designed following the UX Honeycomb usability rules, defined by Peter Morville.\n\n### RESTful API and GraphQL API\n\nWeaviate has both a RESTful API and a GraphQL API. Currently, there is no feature parity between both APIs (this will be implemented later, there is an issue on GitHub). The RESTful APIs are mostly used for DB management and CRUD operations. The GraphQL API is mostly used to access data objects in Weaviate, whether it's a simple lookup or a combination of scalar and vector search. The APIs support the following user needs, roughly speaking:\n\n* **Adding, retrieving, updating and deleting data CRUD** -> RESTful API\n* **Weaviate management operations** -> RESTful API\n* **Data search** -> GraphQL API\n* **Explorative data search** -> GraphQL API\n* **Data analysis (meta data)** -> GraphQL API\n* **Near real time on very large datasets in production** -> Client libraries (Python, Go, Java, JavaScript) using both APIs under the hood\n* **Easy to integrate in applications** -> Client libraries (Python, Go, Java, JavaScript) using both APIs under the hood\n\n## GraphQL\n\n### Why GraphQL?\nWe have chosen to use a GraphQL API, for multiple reasons:\n\n* **Data structure**.\n  * Data in Weaviate follows a class-property structure. Data objects can be queried by their class and properties with GraphQL.\n  * It is possible to link data in Weaviate with cross-references. A Graph query language like GraphQL is very useful here.\n* **Performance**.\n  * With GraphQL, there is no over/under-fetching. You get back exactly the information about data objects that you query, nothing more and nothing less. This is beneficial for performance.\n  * Reducing the number of requests. With GraphQl, you can make highly efficient and precise queries that usually require many more queries with a traditional RESTful API for the same results.\n* **User Experience**\n  * Reducing complexity.\n  * Less error-prone (because of its typed schema)\n  * Custom design\n  * Data exploration and fuzzy search is possible\n\n### GraphQL Design Principles\nGraphQL queries are designed to be intuitive and fit Weaviate's features. This article on Hackernoon tells you more about how GraphQL API was designed (note that examples show an older Weaviate and GraphQL API version). The following three points are key in the design:\n\n* **Natural language**. The GraphQL queries follow a natural language pattern as much as possible. The function of a query is easy to understand and queries are easy to write and remember. An example query where you can recognize human language is: \"*Get* the *title* of the *Articles* where the *wordcount* is *greater than* *1000*. The most important words in this query are also used in the GraphQL query:\n\n```graphql\n{\n  Get {\n    Article(where: {\n        path: [\"wordCount\"],    # Path to the property that should be used\n        operator: GreaterThan,  # operator\n        valueInt: 1000          # value (which is always = to the type of the path property)\n      }) {\n      title\n    }\n  }\n}\n```\n\nThere are currently three main functions in a GraphQL request: \"Get{}\", \"Explore{}\" and \"Aggregate{}\".\n\n* **Classes & properties**. Data in Weaviate has a class-property structure, where cross-references may appear between data object. The class name of the data to return is written one layer deeper than the 'main function'. The next layer consists of the properties and cross-reference properties to return per class:\n\n```graphql\n{\n   {\n       {\n        \n\n         {\n            ... on  {\n                \n            }\n        }\n\n        _ {\n            \n        }\n      }\n  }\n}\n```\n\n* **Query filters (search arguments) dependent on database setup**. You can add filters on class level to filter objects. Scalar (`where` filters) can be combined with vector (`near`) filters. Depending on your Weaviate setup (which modules you have connected), additional filters may be used. A filter can look like (using the `qna-transformers` module):\n\n```graphql\n{\n  Get {\n    Article(\n      ask: {\n        question: \"Who is the king of the Netherlands?\",\n        properties: [\"summary\"]\n      },\n      limit: 1\n    ) {\n      title\n      _additional {\n        answer {\n          result\n        }\n      }\n    }\n  }\n}\n```\n\n### GraphQL Design of Main Functions\n\n1. **Data search: `Get {}`**: to search for data objects when you know the class name of the data objects you're looking for.\n2. **Explorative & fuzzy search: `Explore {}`**: to search in a fuzzy way, when you don't know the data schema and class names.\n3. **Data analysis (meta data): `Aggregate {}`**: to search for meta data, and do data analysis of data aggregations.\n\n## gRPC API support\n\nStarting with version `1.19`, Weaviate is introducing support for the gRPC (gRPC Remote Procedure Calls) API, with the aim of making Weaviate even faster over time.\n\nThis will not result in any user-facing API changes. As of May 2023, gRPC has been added at a very small scale, with the goal of rolling it out further over time to the core library as well as the clients.\n\n## Weaviate Console\n\nThe Weaviate Console is a dashboard to manage Weaviate clusters from WCS, and access Weaviate instances running elsewhere. You can use the Query Module to make GraphQL queries.\n\nGraphQL Query Module in Weaviate Console\n\n## Weaviate Clients and CLI\n\nWeaviate has several client libraries: in Go, Java, Python and TypeScript/JavaScript. The client libraries in all languages support all API functions. Some clients, e.g. the Python client, have additional functionality, such as full schema management and batching operations. This way, Weaviate is easy to use in custom projects. The APIs are intuitive to use, so it is easy to integrate Weaviate into your existing data landscape.\n\nWeaviate also has a Command Line Interface, enabling basic management from the command line to your Weaviate instances.\n\n\n\n", "type": "Documentation", "name": "concepts-interface", "path": "developers/weaviate/concepts/interface.md", "link": "https://weaviate.io/developers/weaviate/concepts/interface", "timestamp": "2023-11-13 10:40:27", "reader": "JSON", "meta": {}, "chunks": []}