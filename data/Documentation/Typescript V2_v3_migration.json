{"text": "\n\n\n\n\n## Install \n\nTo install the TypeScript client v3, follow these steps: \n\n1. **Update Node.js**\n\n   The v3 client requires `Node v18` or higher. \n\n1. **Install the new client package**\n    \n  ```bash\n  npm install weaviate-client --tag next\n  ```\n\n1. **Upgrade Weaviate**\n\n   The v3 client requires Weaviate core `1.23.7` or higher. Whenever possible, use the latest versions of Weaviate core and the Weaviate client.\n\n1. **Open a gRPC port**\n\n   The default gRPC port is 50051.\n\n    \n      docker-compose.yml\n\n    To map the Weaviate gRPC port in your Docker container to a local port, add this code to your `docker-compose.yml` file:\n\n    ```yaml\n        ports:\n        - 8080:8080\n        - 50051:50051\n    ```\n    \n\n## Instantiate a client\n \nThe weaviate object is the main entry point for all API operations. The v3 client instantiates the weaviate object and [creates a connection](/developers/weaviate/starter-guides/connect) to your Weaviate instance.\n\nIn most cases, you should use one of the connection helper functions to connect to your Weaviate instance: \n\n- `connectToWCS`\n- `connectToLocal`\n\nYou can also use a custom configuration to instantiate the client directly:\n\n\n\n\n```ts\nimport weaviate from 'weaviate-client'\n\nconst client = await weaviate.connectToWCS(\n  'WEAVIATE_INSTANCE_URL', { // Replace WEAVIATE_INSTANCE_URL with your instance URL\n    authCredentials: new weaviate.ApiKey('WEAVIATE_INSTANCE_API_KEY'), \n    headers: {\n      'X-OpenAI-Api-Key': process.env.OPENAI_API_KEY || '',  // Replace with your inference API key\n    }\n  } \n)\n\nconsole.log(client)\n```\n\n\n\n\n```ts\nimport weaviate from 'weaviate-client'\n\nconst client = await weaviate.connectToLocal({\n    httpHost: 'localhost',\n    httpPort: 8080,\n    grpcHost: 'localhost',\n    grpcPort: 50051,\n    headers: {\n      'X-OpenAI-Api-Key': process.env.OPENAI_API_KEY || ''\n    }\n  }\n)\n \nconsole.log(client)\n```\n\n\n\n\n```ts\nimport weaviate from 'weaviate-client'\n\nconst client = await weaviate.client({\n    rest: {\n      host: 'WEAVIATE_INSTANCE_HOST_NAME',\n      port: 8080,\n      secure: true\n    },\n    grpc: {\n      host: 'WEAVIATE_INSTANCE_HOST_NAME',\n      port: 50051,\n      secure: true\n    },\n    auth: {\n      apiKey: process.env.WEAVIATE_API_KEY || ''\n    },\n    headers: {\n      'X-OpenAI-Api-Key': process.env.OPENAI_API_KEY || ''\n    }\n  }\n)\n \nconsole.log(client)\n```\n\n\n\n\n## Changes in v3\n\nThe v3 client introduces a new way to work with your data. Here are some of the important changes:\n\n- [Collection object replaces client object](#work-with-collections)\n- [Builder pattern is removed](#builder-pattern-is-removed)\n- [Bulk inserts](#bulk-inserts)\n- [Close clients explicitly](#client-close-method)\n- [Data filtering](#filter-data)\n- [Namespace for generative models](#generate-namespace)\n- [Update return object](#return-object)\n\n### Work with collections\n\nThe v2 client uses the `client` object for CRUD and search operations. In the v3 client, the `collection` object replaces the `client` object.\n\nAfter you create a connection, you do not have to specify the collection for each operation. This helps to reduce errors.\n\n\n\n\n```ts\nconst myCollection = client.collections.get('JeopardyQuestion');\n\nconst result = await myCollection.query.fetchObjects({\n  returnProperties: ['question'],\n})\n\nconsole.log(JSON.stringify(result.objects, null, 2));\n```\n\n\n\n\n```ts\nresult = await client\n  .graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withFields('question')\n  .do();\n\nconsole.log(JSON.stringify(result, null, 2));\n```\n\n\n\n\nNote here that the collection object can be re-used throughout the codebase.\n\n### Builder Pattern is removed\n\nThe v2 client uses builder patterns to construct queries. Builder patterns can be confusing and can lead to invalid queries. The v3 client doesn't use the builder pattern. The v3 client uses specific methods and method parameters instead.\n\n\n\n\n```ts\nlet result \nconst myCollection = client.collections.get('JeopardyQuestion');\n\nresult = await myCollection.query.nearText(['animals in movies'],{\n  limit: 2,\n  returnProperties: ['question', 'answer'],\n  returnMetadata: ['distance']\n})\n\nconsole.log(JSON.stringify(result.objects, null, 2));\n```\n\n\n\n\n```ts\nlet result;\n\nresult = await client.graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withNearText({ concepts: ['animals in movies'] })\n  .withLimit(2)\n  .withFields('question answer _additional { distance }')\n  .do();\n\nconsole.log(JSON.stringify(result, null, 2));\n```\n\n\n\n\n### Bulk Inserts\n\nThe `insertMany()` method replaces `objectBatcher()` to make batch insertions easier.\n\nFor more information on batch processing, see [Batch Inserts](/developers/weaviate/client-libraries/typescript/typescript-v3#batch-inserts).\n\n\n\n\n```ts\nconst questions = client.collections.get(\"CollectionName\")\nconst dataObject = [...]; // your data\n\nawait questions.data.insertMany(dataBatch);\n```\n\n\n\n\n```ts\nlet className = 'CollectionName';  // Replace with your collection name\nlet dataObjs = [...];\n\nlet batcher5 = client.batch.objectsBatcher();\nfor (const dataObj of dataObjs)\n  batcher5 = batcher5.withObject({\n    class: className,\n    properties: dataObj,\n  });\n\n// Flush\nawait batcher5.do();\n```\n\n\n\n\n### Client Close Method\n\n\n\n### Filter data\n\nThe `Filter` helper class makes it easier to use filters with conditions. The v3 client streamlines how you use `Filter` so your code is cleaner and more concise.\n\n\n\n\n```ts\nconst myCollection = client.collections.get('JeopardyQuestion');\n\nconst result = await myCollection.query.fetchObjects({\n  returnProperties: ['question', 'answer','round', 'points'],\n  filters: Filters.and(\n     myCollection.filter.byProperty('round').equal('Double Jeopardy!'),\n     myCollection.filter.byProperty('points').lessThan(600)\n    ),\n  limit: 3,\n })\n\nconsole.log(JSON.stringify(result, null, 2));\n```\n\n\n\n\n```ts\nresult = await client.graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withWhere({\n    operator: 'And',\n    operands: [\n      {\n        path: ['round'],\n        operator: 'Equal',\n        valueText: 'Double Jeopardy!',\n      },\n      {\n        path: ['points'],\n        operator: 'LessThan',\n        valueInt: 600,\n      },\n    ],\n  })\n  .withLimit(3)\n  .withFields('question answer round points')\n  .do();\n\nconsole.log(JSON.stringify(result, null, 2));\n```\n\n\n\n\n### Generate Namespace\n\nThe v3 client adds a new namespace, `generate`. Use the generate namespace like the query namespace to make queries.\n\n\n\n\n```ts\nconst generatePrompt = `Convert this quiz question: {question} and answer: {answer} into a trivia tweet.`;\n\nconst myCollection = client.collections.get('JeopardyQuestion');\nconst result = await myCollection.generate.nearText(['World history'],{\n    singlePrompt: generatePrompt,\n  },{\n    limit: 2,\n    returnProperties: ['round'],\n})\n\nconsole.log(JSON.stringify(result.objects, null, 2));\n```\n\n\n\n\n```ts\nlet result;\ngeneratePrompt = 'Convert this quiz question: {question} and answer: {answer} into a trivia tweet.';\n\nresult = await client.graphql\n  .get()\n  .withClassName('JeopardyQuestion')\n  .withGenerate({\n    singlePrompt: generatePrompt,\n  })\n  .withNearText({\n    concepts: ['World history'],\n  })\n  .withFields('round')\n  .withLimit(2)\n  .do();\n\nconsole.log(JSON.stringify(result, null, 2));\n```\n\n\n\n\n### Return object \n\nThe new client has a cleaner return object. It is easier to access important information like object UUIDs, object metadata, and generative query results.\n\n\n\n\n```ts\nresponse.objects[0].properties.title  // Get the `title` property of the first object\nresponse.objects[0].uuid  // Get the ID of the first object\nresponse.objects[0].generated  // Get the generated text from a `singlePrompt` request\nresponse.generated  // Get the generated text from a `groupedTask` request\nresponse.metadata?.creationTime // Get the creation time as a native JS Date value\n```\n\n\n\n\n```ts\nresponse.data?.Get?.Article?.[0].title  // Get the `title` property of the first object\nresponse.data?.Get?.Article?.[0]['_additional']?.id  // Get the ID of the first object\nresponse.data?.Get?.Article?.[0]['_additional']?.generate?.singleResult  // Get the generated text from a `singlePrompt` request\nresponse.data?.Get?.Article?.[0]['_additional']?.generate.groupedResult  // Get the generated text from a `groupedTask` request\nresponse.data?.Get?.Article?.[0]['_additional']?.creationTimeUnix // Get the timestamp when the object was created\n```\n\n\n\n\n## How to migrate your code\n\nFor code examples, see the pages here:\n\n- [Search](/developers/weaviate/search)\n- [Data management](/developers/weaviate/manage-data)\n- [Connect to Weaviate](/developers/weaviate/starter-guides/connect)\n\n## Client change logs\n\nSee the client [change logs on GitHub](https://github.com/weaviate/typescript-client/releases).\n\n\n", "type": "Documentation", "name": "Typescript V2_v3_migration", "path": "developers/weaviate/client-libraries/typescript/v2_v3_migration.md", "link": "https://weaviate.io/developers/weaviate/client-libraries/typescript/v2_v3_migration", "timestamp": "2024-05-08 10:49:41", "reader": "JSON", "meta": {}, "chunks": []}