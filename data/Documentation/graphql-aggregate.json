{"text": "\n\n\n\n\n## Aggregate{} syntax and query structure\n\nThis example shows how to aggregate over the entire database. Below you will find examples of how to dynamically retrieve objects using a vector search and then aggregating only the matches. The `Aggregate{}` function is structured as follows:\n\n```graphql\n{\n  Aggregate {\n     (groupBy:[]) {\n      groupedBy { # requires `groupBy` filter\n          path\n          value\n      }\n      meta {\n        count\n      }\n       {\n          count\n          type\n          topOccurrences {\n              value\n              occurs\n          }\n      }\n       {\n          count\n          type\n          topOccurrences {\n              value\n              occurs\n          }\n      }\n       {\n          count\n          type\n          minimum\n          maximum\n          mean\n          median\n          mode\n          sum\n      }\n       {\n          count\n          type\n          totalTrue\n          totalFalse\n          percentageTrue\n          percentageFalse\n      }\n      \n        pointingTo\n        type\n    }\n  }\n}\n```\n\nBelow is an example query to obtain meta information about the data in the class `Article`. Note that the data is not grouped yet, the meta information is about all the data objects found with the class `Article`.\n\n\n\n\nThe above query will result in something like the following:\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"Article\": [\n        {\n          \"inPublication\": {\n            \"pointingTo\": [\n              \"Publication\"\n            ],\n            \"type\": \"cref\"\n          },\n          \"meta\": {\n            \"count\": 4403\n          },\n          \"wordCount\": {\n            \"count\": 4403,\n            \"maximum\": 16852,\n            \"mean\": 966.0113558937088,\n            \"median\": 680,\n            \"minimum\": 109,\n            \"mode\": 575,\n            \"sum\": 4253348,\n            \"type\": \"int\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\nAs such, this `Aggregate` query will retrieve the total object count in a class.\n\n\n\n### groupBy argument\n\nYou can use a groupBy argument to get meta information about groups of data objects.\n\n\n\n\nThe `groupBy{}` argument is structured as follows for the `Aggregate{}` function:\n\n```graphql\n{\n  Aggregate {\n     ( groupBy: [\"\"] ) {\n      groupedBy {\n          path\n          value\n      }\n      meta {\n        count\n      }\n       {\n        count\n      }\n    }\n  }\n}\n```\n\nIn the following example, the articles are grouped by the property `inPublication`, referring to the article's publisher.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"Article\": [\n        {\n          \"groupedBy\": {\n            \"path\": [\n              \"inPublication\"\n            ],\n            \"value\": \"weaviate://localhost/Publication/16476dca-59ce-395e-b896-050080120cd4\"\n          },\n          \"meta\": {\n            \"count\": 829\n          },\n          \"wordCount\": {\n            \"mean\": 604.6537997587454\n          }\n        },\n        {\n          \"groupedBy\": {\n            \"path\": [\n              \"inPublication\"\n            ],\n            \"value\": \"weaviate://localhost/Publication/c9a0e53b-93fe-38df-a6ea-4c8ff4501783\"\n          },\n          \"meta\": {\n            \"count\": 618\n          },\n          \"wordCount\": {\n            \"mean\": 917.1860841423949\n          }\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### Additional filters\n\n`Aggregate{}` functions can be extended with search filters. Because the filters work on multiple core functions (like `Get{}`) there is a specific documentation page dedicated to filters.\n\n### `topOccurrences` property\n\nAggregating data makes the `topOccurrences` sub-property available. Note that the counts are not dependent on tokenization. The `topOccurrences` count is based on occurrences of the entire property, or one of the values if the property is an array.\n\n### Multi-tenancy\n\n\nWhere multi-tenancy is configured, the `Aggregate{}` function can be configured to aggregate results from a specific tenant.\n\nYou can do so by specifying the `tenant` parameter in the GraphQL query as shown below, or using the equivalent client function.\n\n```graphql\n{\n  Aggregate {\n    Article (\n      tenant: \"tenantA\"\n    ) {\n      meta {\n        count\n      }\n    }\n  }\n}\n```\n\nFor more information on using multi-tenancy, see the Multi-tenancy operations guide.\n\n## Aggregating a Vector Search / Faceted Vector Search\n\nThis feature was added in `v1.13.0`\n\nYou can combine a vector search (e.g. `nearObject`, `nearVector`, `nearText`, `nearImage`, etc.) with an aggregation. Internally, this is a two-step process where the vector search first finds the desired objects, then the results are aggregated.\n\n### Limiting the search space\n\nVector searches are different from keyword-based searches in the sense that they do not filter the result set, they just return the objects in a different order. Imagine having 1,000 objects and a vector search for `\"apple iphone\"`. If there was no explicit limit, every single object in the database would be a potential match. Some matches would have a very high score (certainty), and the last matches would most likely have a very low score. But nevertheless all 1,000 objects could potentially be scored. The value in this search is in the order. If we only look at the top 10 results, they will be very closely related to the query vector. Similarly, the last 10 objects on the list would be very unrelated. However, the order is not visible within an aggregation.\n\nAs a result, whenever the goal is to aggregate vector search results, there needs to be something that limits the search space. Otherwise the Aggregation results (over all matches) will look exactly like an Aggregation without any additional `near` operator.\n\nYou can achieve such a restriction of the search space in two different ways:\n\n* Set an explicit `objectLimit`, e.g. `objectLimit: 100`. This tells Weaviate to retrieve the top 100 objects related to your vector search query, then aggregate them. *This is useful when you know up front how many results you want to serve, for example in a recommendation scenario, where you want to produce 100 recommendations.*\n\n* Set an explicit `certainty`, e.g. `certainty: 0.7`. This tells Weaviate to retrieve all possible matches that have a certainty of 0.7 or higher. This list has no fixed length, it depends on how many objects were good matches. *This is useful in user-facing search scenarios, such as e-commerce. The user might be interested in all search results semantically similar to \"apple iphone\" and then generate facets.*\n\nIf neither an `objectLimit`, nor a `certainty` is set the query will error.\n\n### API\n\nBelow are examples for `nearObject`, `nearVector`, and `nearText`.\nAny `near` will work.\n\n#### nearObject\n\n\n\n\n#### nearVector\n\nTo run this query, replace the placeholder vector with a real vector from the same vectorizer that used to generate object vectors.\n\n\n\n\n#### nearText\n\nFor `nearText` to be available, a `text2vec-*` module must be installed with Weaviate.\n\n\n\n\n\n\n\n", "type": "Documentation", "name": "graphql-aggregate", "path": "developers/weaviate/api/graphql/aggregate.md", "link": "https://weaviate.io/developers/weaviate/api/graphql/aggregate", "timestamp": "2023-11-13 10:40:03", "reader": "JSON", "meta": {}, "chunks": []}