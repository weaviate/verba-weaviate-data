{"text": "\n\n\n- References: REST API: Backups\n\n## Introduction\n\nWeaviate's Backup feature is designed to feel very easy to use and work natively with cloud technology. Most notably, it allows:\n\n* Seamless integration with widely-used cloud blob storage, such as AWS S3, GCS or Azure\n* Backup and Restore between different storage providers\n* Single-command backup and restore from the REST API\n* Choice of backing up an entire instance, or selected classes only\n* Zero downtime & minimal impact for your users when backups are running\n* Easy Migration to new environments\n\n_The backup functionality was introduced in Weaviate `v1.15`, but for single-node instances only. Support for multi-node backups was introduced in `v1.16`_.\n\n\n## Configuration\n\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently `backup-s3`, `backup-gcs`, `backup-azure`, and `backup-filesystem` modules are available for S3, GCS, Azure or filesystem backups respectively.\n\nAs it is built on Weaviate's module system, additional providers can be added in the future.\n\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\n\n### S3 (AWS or S3-compatible)\n\nUse the `backup-s3` module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\n\nTo enable the module, add its name to the `ENABLE_MODULES` environment variable. Modules are comma-separated. To enable the module along with the `text2vec-transformers` module for example, set:\n\n```\nENABLE_MODULES=backup-s3,text2vec-transformers\n```\n\n#### S3 Configuration (vendor-agnostic)\nIn addition to enabling the module, you need to configure it using environment variables. This configuration applies to any S3-compatible backend.\n\n| Environment variable | Required | Description |\n| --- | --- | --- |\n| `BACKUP_S3_BUCKET` | yes | The name of the S3 bucket for all backups. |\n| `BACKUP_S3_PATH` | no | The root path inside your bucket that all your backups will be copied into and retrieved from. Optional, defaults to `\"\"` which means that the backups will be stored in the bucket root instead of a sub-folder. |\n| `BACKUP_S3_ENDPOINT` | no | The S3 endpoint to be used. Optional, defaults to `\"s3.amazonaws.com\"`. |\n| `BACKUP_S3_USE_SSL` | no | Whether the connection should be secured with SSL/TLS. Optional, defaults to `\"true\"`. |\n\n#### S3 Configuration (AWS-specific)\n\nIn addition to the vendor-agnostic configuration from above, you can set AWS-specific configuration for authentication. You can choose between access-key or ARN-based authentication:\n\n#### Option 1: With IAM and ARN roles\n\nThe backup module will first try to authenticate itself using AWS IAM. If the authentication fails then it will try to authenticate with `Option 2`.\n\n#### Option 2: With access key and secret access key\n\n| Environment variable | Description |\n| --- | --- |\n| `AWS_ACCESS_KEY_ID` | The id of the AWS access key for the desired account. |\n| `AWS_SECRET_ACCESS_KEY` | The secret AWS access key for the desired account. |\n| `AWS_REGION` | The AWS Region. If not provided, the module will try to parse `AWS_DEFAULT_REGION`. |\n\n\n### GCS (Google Cloud Storage)\n\nUse the `backup-gcs` module to enable backing up to and restoring from any Google Cloud Storage bucket.\n\nTo enable the module, add its name to the `ENABLE_MODULES` environment variable. Modules are comma-separated. To enable the module along with the `text2vec-transformers` module for example, set:\n\n```\nENABLE_MODULES=backup-gcs,text2vec-transformers\n```\n\nIn addition to enabling the module, you need to configure it using environment variables. There are bucket-related variables, as well as credential-related variables.\n\n#### GCS bucket-related variables\n\n| Environment variable | Required | Description |\n| --- | --- | --- |\n| `BACKUP_GCS_BUCKET` | yes | The name of the GCS bucket for all backups. |\n| `BACKUP_GCS_USE_AUTH` | no | Whether or not credentials will be used for authentication. Defaults to `true`. A case for `false` would be for use with a local GCS emulator. |\n| `BACKUP_GCS_PATH` | no | The root path inside your bucket that all your backups will be copied into and retrieved from. Optional, defaults to `\"\"` which means that the backups will be stored in the bucket root instead of a sub-folder. |\n\n#### Google Application Default Credentials\n\nThe `backup-gcs` module follows the Google Application Default Credentials best-practices. This means that credentials can be discovered through the environment, through a local Google Cloud CLI setup, or through an attached service account.\n\nThis makes it easy to use the same module in different setups. For example, you can use the environment-based approach in production, and the CLI-based approach on your local machine. This way you can easily pull a backup that was created in a remote environment to your local system. This can be helpful in debugging an issue, for example.\n\n#### Environment-based Configuration\n\n| Environment variable | Example value | Description |\n| --- | --- | --- |\n| `GOOGLE_APPLICATION_CREDENTIALS` | `/your/google/credentials.json` | The path to the secret GCP service account or workload identity file. |\n| `GCP_PROJECT` | `my-gcp-project` | Optional. If you use a service account with `GOOGLE_APPLICATION_CREDENTIALS` the service account will already contain a Google project. You can use this variable to explicitly set a project if you are using user credentials which may have access to more than one project. |\n\n### Azure Storage\n\nUse the `backup-azure` module to enable backing up to and restoring from any Microsoft Azure Storage container.\n\nTo enable the module, add its name to the `ENABLE_MODULES` environment variable. Modules are comma-separated. To enable the module along with the `text2vec-transformers` module for example, set:\n\n```\nENABLE_MODULES=backup-azure,text2vec-transformers\n```\n\nIn addition to enabling the module, you need to configure it using environment variables. There are container-related variables, as well as credential-related variables.\n\n#### Azure container-related variables\n\n| Environment variable | Required | Description |\n| --- | --- | --- |\n| `BACKUP_AZURE_CONTAINER` | yes | The name of the Azure container for all backups. |\n| `BACKUP_AZURE_PATH` | no | The root path inside your container that all your backups will be copied into and retrieved from. Optional, defaults to `\"\"` which means that the backups will be stored in the container root instead of a sub-folder. |\n\n#### Azure Credentials\n\nThere are two different ways to authenticate against Azure with `backup-azure`. You can use either:\n\n1. An Azure Storage connection string, or\n1. An Azure Storage account name and key.\n\nBoth options can be implemented using environment variables as follows:\n\n| Environment variable | Required | Description |\n| --- | --- | --- |\n| `AZURE_STORAGE_CONNECTION_STRING` | yes (*see note) | A string that includes the authorization information required (Azure documentation).  This variable is checked and used first before `AZURE_STORAGE_ACCOUNT`. |\n| `AZURE_STORAGE_ACCOUNT` | yes (*see note) | The name of your Azure Storage account. |\n| `AZURE_STORAGE_KEY` | no | An access key for your Azure Storage account. For anonymous access, specify `\"\"`. |\n\nIf both of `AZURE_STORAGE_CONNECTION_STRING` and `AZURE_STORAGE_ACCOUNT` are provided, Weaviate will use `AZURE_STORAGE_CONNECTION_STRING` to authenticate.\n\nAt least one of `AZURE_STORAGE_CONNECTION_STRING` or `AZURE_STORAGE_ACCOUNT` must be present.\n\n\n### Filesystem\n\n`backup-filesystem` is only compatible with single-node backups. Use `backup-gcs` or `backup-s3` if support for multi-node backups is needed.\n\nThe filesystem provider is not intended for production use, as its availability is directly tied to the node on which it operates.\n\nInstead of backing up to a remote backend, you can also back up to the local filesystem. This may be helpful during development, for example to be able to quickly exchange setups, or to save a state from accidental future changes.\n\nTo allow backups to the local filesystem, add `backup-filesystem` to the `ENABLE_MODULES` environment variable. Modules are comma-separated. To enable the module along with the `text2vec-transformers` module for example, set:\n\n```\nENABLE_MODULES=backup-filesystem,text2vec-transformers\n```\n\nIn addition to enabling the module, you need to configure it using environment variables:\n\n| Environment variable | Required | Description |\n| --- | --- | --- |\n| `BACKUP_FILESYSTEM_PATH` | yes | The root path that all your backups will be copied into and retrieved from |\n\n### Other Backup Backends\n\nWeaviate uses its module system to decouple the backup orchestration from the remote backup storage backends. It is easy to add new providers and use them with the existing backup API. If you are missing your desired backup module, you can open a feature request or contribute it yourself. For either option, join our Slack community to have a quick chat with us on how to get started.\n\n\n## API\n\n### Create Backup\n\nOnce the modules are enabled and the configuration is provided, you can start a backup on any running instance with a single HTTP request.\n\n#### Method and URL\n\n```js\nPOST /v1/backups/{backend}\n```\n\n#### Parameters\n\n##### URL Parameters\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `backend` | string | yes | The name of the backup provider module without the `backup-` prefix, for example `s3`, `gcs`, or `filesystem`. |\n\n##### Request Body\n\nThe request takes a JSON object with the following properties:\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `id` | string (lowercase letters, numbers, underscore, minus) | yes | The id of the backup. This string must be provided on all future requests, such as status checking or restoration. |\n| `include` | list of strings | no | An optional list of class names to be included in the backup. If not set, all classes are included. |\n| `exclude` | list of strings | no | An optional list of class names to be excluded from the backup. If not set, no classes are excluded. |\n\nYou cannot set `include` and `exclude` at the same time. Set none or exactly one of those.\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n\nWhile you are waiting for a backup to complete, Weaviate stays fully usable.\n\n\n#### Asynchronous Status Checking\n\nAll client implementations have a \"wait for completion\" option which will poll the backup status in the background and only return once the backup has completed (successfully or unsuccessfully).\n\nIf you set the \"wait for completion\" option to false, you can also check the status yourself using the Backup Creation Status API.\n\n```js\nGET /v1/backups/{backend}/{backup_id}\n```\n\n#### Parameters\n\n##### URL Parameters\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `backend` | string | yes | The name of the backup provider module without the `backup-` prefix, for example `s3`, `gcs`, or `filesystem`. |\n| `backup_id` | string | yes | The user-provided backup identifier that was used when sending the request to create the backup. |\n\nThe response contains a `\"status\"` field. If the status is `SUCCESS`, the backup is complete. If the status is `FAILED`, an additional error is provided.\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n\n### Restore Backup\nYou can restore any backup to any machine as long as the name and number of nodes between source and target are identical. The backup does not need to be created on the same instance. Once a backup backend is configured, you can restore a backup with a single HTTP request.\n\nNote that a restore fails if any of the classes already exist on this instance.\n\n#### Method and URL\n\n```js\nPOST /v1/backups/{backend}/{backup_id}/restore\n```\n\n#### Parameters\n\n##### URL Parameters\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `backend` | string | yes | The name of the backup provider module without the `backup-` prefix, for example `s3`, `gcs`, or `filesystem`. |\n| `backup_id` | string | yes | The user-provided backup identifier that was used when sending the request to create the backup. |\n\n##### Request Body\nThe request takes a json object with the following properties:\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `include` | list of strings | no | An optional list of class names to be included in the backup. If not set, all classes are included. |\n| `exclude` | list of strings | no | An optional list of class names to be excluded from the backup. If not set, no classes are excluded. |\n\n*Note 1: You cannot set `include` and `exclude` at the same time. Set none or exactly one of those.*\n\n*Note 2: `include` and `exclude` are relative to the classes contained in the backup. The restore process does not know which classes existed on the source machine if they were not part of the backup.*\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n\n#### Asynchronous Status Checking\n\nAll client implementations have a \"wait for completion\" option which will poll the restore status in the background and only return once the restore has completed (successfully or unsuccessfully).\n\nIf you set the \"wait for completion\" option to false, you can also check the status yourself using the Backup Restore Status API.\n\n```js\nGET /v1/backups/{backend}/{backup_id}/restore\n```\n\n#### Parameters\n\n##### URL Parameters\n\n| Name | Type | Required | Description |\n| ---- | ---- | ---- | ---- |\n| `backend` | string | yes | The name of the backup provider module without the `backup-` prefix, for example `s3`, `gcs`, or `filesystem`. |\n| `backup_id` | string | yes | The user-provided backup identifier that was used when sending the requests to create and restore the backup. |\n\nThe response contains a `\"status\"` field. If the status is `SUCCESS`, the restore is complete. If the status is `FAILED`, an additional error is provided.\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n\n## Technical Considerations\n\n### Read & Write requests while a backup is running\n\nThe backup process is designed to be minimally invasive to a running setup. Even on very large setups, where terabytes of data need to be copied, Weaviate stays fully usable during backup. It even accepts write requests while a backup process is running. This sections explains how backups work under the hood and why Weaviate can safely accept writes while a backup is copied.\n\nWeaviate uses a custom LSM Store for it's object store and inverted index. LSM stores are a hybrid of immutable disk segments and an in-memory structure called a memtable that accepts all writes (including updates and deletes). Most of the time, files on disk are immutable, there are only three situations where files are changed:\n\n1. Anytime a memtable is flushed. This creates a new segment. Existing segments are not changed.\n2. Any write into the memtable is also written into a Write-Ahead-Log (WAL). The WAL is only needed for disaster-recovery. Once a segment has been orderly flushed, the WAL can be discarded.\n3. There is an async background process called Compaction that optimizes existing segments. It can merge two small segments into a single larger segment and remove redundant data as part of the process.\n\nWeaviate's Backup implementation makes use of the above properties in the following ways:\n\n1. Weaviate first flushes all active memtables to disk. This process takes in the 10s or 100s of milliseconds. Any pending write requests simply waits for a new memtable to be created without any failing requests or substantial delays.\n2. Now that the memtables are flushed, there is a guarantee: All data that should be part of the backup is present in the existing disk segments. Any data that will be imported after the backup request ends up in new disk segments. The backup references a list of immutable files.\n3. To prevent a compaction process from changing the files on disk while they are being copied, compactions are temporarily paused until all files have been copied. They are automatically resumed right after.\n\nThis way the backup process can guarantee that the files that are transferred to the remote backend are immutable (and thus safe to copy) even with new writes coming in. Even if it takes minutes or hours to backup a very large setup, Weaviate stays fully usable without any user impact while the backup process is running.\n\nIt is not just safe - but even recommended - to create backups on live production instances while they are serving user requests.\n\n### Async nature of the Backup API\n\nThe backup API is built in a way that no long-running network requests are required. The request to create a new backup returns immediately. It does some basic validation, then returns to the user. The backup is now in status `STARTED`. To get the status of a running backup you can poll the status endpoint. This makes the backup itself resilient to network or client failures.\n\nIf you would like your application to wait for the background backup process to complete, you can use the \"wait for completion\" feature that is present in all language clients. The clients will poll the status endpoint in the background and block until the status is either `SUCCESS` or `FAILED`. This makes it easy to write simple synchronous backup scripts, even with the async nature of the API.\n\n## Other Use cases\n\n### Migrating to another environment\n\nThe flexibility around backup providers opens up new use cases. Besides using the backup & restore feature for disaster recovery, you can also use it for duplicating environments or migrating between clusters.\n\nFor example, consider the following situation: You would like to do a load test on production data. If you would do the load test in production it might affect users. An easy way to get meaningful results without affecting uses it to duplicate your entire environment. Once the new production-like \"loadtest\" environment is up, create a backup from your production environment and restore it into your \"loadtest\" environment. This even works if the production environment is running on a completely different cloud provider than the new environment.\n\n\n\n\n", "type": "Documentation", "name": "configuration-backups", "path": "developers/weaviate/configuration/backups.md", "link": "https://weaviate.io/developers/weaviate/configuration/backups", "timestamp": "2023-11-13 10:40:39", "reader": "JSON", "meta": {}, "chunks": []}