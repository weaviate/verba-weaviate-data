{"text": "\n\n\n\n## Data object nomenclature\n\nEach data object in Weaviate belongs to a `collection` and has one or more `properties`.\n\nWeaviate stores `data objects` in class-based collections. Data objects are represented as JSON-documents. Objects normally include a `vector` that is derived from a machine learning model. The vector is also called an `embedding` or a `vector embedding`.\n\nEach collection contains objects of the same `class`. The objects are defined by a common `schema`.\n\n### JSON documents as objects\n\nImagine we need to store information about an author named Alice Munro. In JSON format the data looks like this:\n\n```json\n{\n    \"name\": \"Alice Munro\",\n    \"age\": 91,\n    \"born\": \"1931-07-10T00:00:00.0Z\",\n    \"wonNobelPrize\": true,\n    \"description\": \"Alice Ann Munro is a Canadian short story writer who won the Nobel Prize in Literature in 2013. Munro's work has been described as revolutionizing the architecture of short stories, especially in its tendency to move forward and backward in time.\"\n}\n```\n\n### Vectors\n\nYou can also attach `vector` representations to your data objects. Vectors are arrays of numbers that are stored under the `\"vector\"` property.\n\nIn this example, the `Alice Munro` data object has a small vector. The vector is some information about Alice, maybe a story or an image, that a machine learning model has transformed into an array of numerical values.\n\n```json\n{\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Alice Munro\",\n        (...)\n    },\n    \"vector\": [\n        -0.16147631,\n        -0.065765485,\n        -0.06546908\n    ]\n}\n```\n\nTo generate vectors for your data, use one of Weaviate's vectorizer [modules](./modules.md). You can also use your own vectorizer.\n\n### Collections\n\nCollections are groups of objects that share a schema definition.\n\nIn this example, the `Author` collection holds objects that represent different authors.\n\n\n\nThe collection looks like this:\n\n```json\n[{\n    \"id\": \"dedd462a-23c8-32d0-9412-6fcf9c1e8149\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Alice Munro\",\n        \"age\": 91,\n        \"born\": \"1931-07-10T00:00:00.0Z\",\n        \"wonNobelPrize\": true,\n        \"description\": \"Alice Ann Munro is a Canadian short story writer who won the Nobel Prize in Literature in 2013. Munro's work has been described as revolutionizing the architecture of short stories, especially in its tendency to move forward and backward in time.\"\n    },\n    \"vector\": [\n        -0.16147631,\n        -0.065765485,\n        -0.06546908\n    ]\n}, {\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Paul Krugman\",\n        \"age\": 69,\n        \"born\": \"1953-02-28T00:00:00.0Z\",\n        \"wonNobelPrize\": true,\n        \"description\": \"Paul Robin Krugman is an American economist and public intellectual, who is Distinguished Professor of Economics at the Graduate Center of the City University of New York, and a columnist for The New York Times. In 2008, Krugman was the winner of the Nobel Memorial Prize in Economic Sciences for his contributions to New Trade Theory and New Economic Geography.\"\n    },\n    \"vector\": [\n        -0.93070928,\n        -0.03782172,\n        -0.56288009\n    ]\n}]\n```\n\nEvery collection has its own vector space. This means that different collections can have different embeddings of the same object.\n\nEvery object stored in Weaviate has a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier). The UUID guarantees uniqueness across all collections.\n\n### Cross-references\n\nIf data objects are related, use [cross-references](/weaviate/manage-data/cross-references.mdx) to represent the relationships. Cross-references in Weaviate are like links that help you retrieve related information. Cross-references capture relationships, but they do not change the vectors of the underlying objects.\n\nTo create a reference, use a property from one collection to specify the value of a related property in the other collection.\n\n#### Cross-reference example\n\nFor example, *\"Paul Krugman writes for the New York Times\"* describes a relationship between Paul Krugman and the New York Times. To capture that relationship, create a cross-reference between the `Publication` object that represents the New York Times and the `Author` object that represents Paul Krugman.\n\nThe New York Times `Publication` object looks like this. Note the UUID in the `\"id\"` field:\n\n```json\n{\n    \"id\": \"32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\",\n    \"class\": \"Publication\",\n    \"properties\": {\n        \"name\": \"The New York Times\"\n    },\n    \"vector\": [...]\n}\n```\n\nThe Paul Krugman `Author` object adds a new property, `writesFor`, to capture the relationship.\n\n```json\n{\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Paul Krugman\",\n        ...\n// highlight-start\n        \"writesFor\": [\n            {\n                \"beacon\": \"weaviate://localhost/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\",\n                \"href\": \"/v1/objects/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\"\n            }\n        ],\n// highlight-end\n    },\n    \"vector\": [...]\n}\n```\n\nThe value of the `beacon` sub-property is the `id` value from the New York Times `Publication` object.\n\nCross-reference relationships are directional. To make the link bi-directional, update the `Publication` collection to add a ``hasAuthors` property points back to the `Author` collection.\n\n### Multiple vectors\n\n\n\n## Weaviate Schema\n\nWeaviate requires a data schema before you add data. However, you don't have to create a data schema manually. If you don't provide one, Weaviate generates a schema based on the incoming data.\n\n\n\nA Weaviate data schema is slightly different from a taxonomy. A taxonomy has a hierarchy. Read more about how taxonomies, ontologies and schemas are related in this Weaviate [blog post](https://medium.com/semi-technologies/taxonomies-ontologies-and-schemas-how-do-they-relate-to-weaviate-9f76739fc695).\n\nSchemas fulfill several roles:\n\n1. Schemas define collections and properties.\n1. Schemas define cross-references that link collections, even collections that use different embeddings.\n1. Schemas let you configure module behavior, ANN index settings, reverse indexes, and other features on a collection level.\n\nFor details on configuring your schema, see the [schema tutorial](../starter-guides/schema.md) or [schema configuration](../manage-data/collections.mdx).\n\n## Multi-tenancy\n\n- Multi-tenancy added in `v1.20`\n- The tenant activity status setting added in `v1.21`\n\nTo separate data within a cluster, use multi-tenancy. Weaviate partitions the cluster into shards. Each shard holds data for a single tenant.\n\nSharding has several benefits:\n\n- Data isolation\n- Fast, efficient querying\n- Easy and robust setup and clean up\n\nStarting in `v1.20`, shards are more lightweight. You can easily have 50,000, or more, active shards per node. This means that you can support 1M concurrently active tenants with just 20 or so nodes.\n\nStarting in `v1.20.1`, you can specify tenants as active (`HOT`) or inactive (`COLD`). For more details on managing tenants, see [Multi-tenancy operations](../manage-data/multi-tenancy.md).\n\nMulti-tenancy is especially useful when you want to store data for multiple customers, or when you want to store data for multiple projects.\n\n### Tenancy and IDs\n\nEach tenancy is like a namespace, so different tenants could, in theory, have objects with the same IDs. To avoid naming problems, object IDs in multi-tenant clusters combine the tenant ID and the object ID to create an ID that is unique across tenants.\n\n### Tenancy and cross-references\n\nMulti-tenancy supports some cross-references.\n\nCross-references like these are supported:\n\n- From a multi-tenancy object to a non-multi-tenancy object.\n- From a multi-tenancy object to another multi-tenancy object, as long as they belong to the same tenant.\n\nCross-references like these are not supported:\n\n- From a non-multi-tenancy object to a multi-tenancy object.\n- From a multi-tenancy object to another multi-tenancy object if they belong to different tenants.\n\n### Key features\n\n- Each tenant has a dedicated, high-performance vector index. Dedicated indexes mean faster query speeds. Instead of searching a shared index space, each tenant responds as if it was the only user on the cluster.\n- Each tenant's data is isolated on a dedicated shard. This means that deletes are fast and do not affect other tenants.\n- To scale out, add a new node to your cluster. Weaviate does not redistribute existing tenants, however Weaviate adds new tenants to the node with the least resource usage.\n\n- [How-to: Manage Data | Multi-tenancy operations](../manage-data/multi-tenancy.md)\n- [Multi-tenancy blog](/blog/multi-tenancy-vector-search)\n\n### Monitoring metrics\n\nTo group tenants together for monitoring, set [`PROMETHEUS_MONITORING_GROUP = true`](../config-refs/env-vars.md) in your system configuration file.\n\n### Number of tenants per node\n\nThe number of tenants per node is limited by operating system constraints. The number of tenants cannot exceed the Linux open file limit per process.\n\nFor example, a 9-node test cluster built on `n1-standard-8` machines holds around 170k active tenants. There are 18,000 to 19,000 tenants per node.\n\nNote that these numbers relate to active tenants only. If you [set unused tenants as `inactive`](../manage-data/multi-tenancy.md#update-tenant-activity-status), the open file per process limit does not apply.\n\n### Lazy shard loading\n\n\nWhen Weaviate starts, it loads data from all of the shards in your deployment. This process can take a long time. Prior to v1.23, you have to wait until all of the shards are loaded before you can query your data. Since every tenant is a shard, multi-tenant deployments can have reduced availability after a restart.\n\nLazy shard loading allows you to start working with your data sooner. After a restart, shards load in the background. If the shard you want to query is already loaded, you can get your results sooner. If the shard is not loaded yet, Weaviate prioritizes loading that shard and returns a response when it is ready.\n\nTo enable lazy shard loading, set `DISABLE_LAZY_LOAD_SHARDS = false` in your system configuration file.\n\n### Tenant status\n\n\nTenants are `HOT` or `COLD`. Tenant status determines if Weaviate can access the shard.\n\n| Status | State | Description |\n| :-- | :-- | :-- |\n|`HOT`| Active | Weaviate can read and write. |\n|`COLD`| Inactive | Weaviate cannot read or write. Access attempts return an error message. |\n\n## Related pages\n\nFor more information, see the following:\n\n- [How-to manage data: Multi-tenancy operations](../manage-data/multi-tenancy.md)\n- [References: REST API: Schema](/developers/weaviate/api/rest#tag/schema)\n- [Configuration: Schema](../manage-data/collections.mdx)\n\n## Summary\n\n* The schema defines collections and properties.\n* Collections contain data objects that are describe in JSON documents.\n* Data objects can contain a vector and properties.\n* Vectors come from machine learning models.\n* Different collections represent different vector spaces.\n* Cross-references link objects between schemas.\n* Multi-tenancy isolates data for each tenant.\n\n\n", "type": "Documentation", "name": "Concepts Data", "path": "developers/weaviate/concepts/data.md", "link": "https://weaviate.io/developers/weaviate/concepts/data", "timestamp": "2024-05-08 10:49:42", "reader": "JSON", "meta": {}, "chunks": []}