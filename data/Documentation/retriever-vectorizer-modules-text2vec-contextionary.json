{"text": "\n\n\n## Overview\n\nThe `text2vec-contextionary` module enables Weaviate to obtain vectors locally using a lightweight model.\n\nKey notes:\n\n- This module is not available on Weaviate Cloud Services (WCS).\n- Enabling this module will enable the `nearText` search operator.\n- This module is based on FastText and uses a weighted mean of word embeddings (WMOWE) to produce the vector.\n- Available for multiple languages\n\nAs a lightweight model, it is well suited for testing purposes.\n\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\n\n## Weaviate instance configuration\n\nThis module is not available on Weaviate Cloud Services.\n\n### Docker Compose file\n\nTo use `text2vec-contextionary`, you must enable it in your Docker Compose file (e.g. `docker-compose.yml`).\n\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the `Docker Compose` file.\n\n#### Parameters\n\nWeaviate:\n\n- `ENABLE_MODULES` (Required): The modules to enable. Include `text2vec-contextionary` to enable the module.\n- `DEFAULT_VECTORIZER_MODULE` (Optional): The default vectorizer module. You can set this to `text2vec-contextionary` to make it the default for all classes.\n\nContextionary:\n\n* `EXTENSIONS_STORAGE_MODE`: Location of storage for extensions to the Contextionary\n* `EXTENSIONS_STORAGE_ORIGIN`: The host of the custom extension storage\n* `NEIGHBOR_OCCURRENCE_IGNORE_PERCENTILE`: this can be used to hide very rare words. If you set it to '5', this means the 5th percentile of words by occurrence are removed in the nearestNeighbor search (for example used in the GraphQL `_additional { nearestNeighbors }` feature).\n* `ENABLE_COMPOUND_SPLITTING`: see here.\n\n#### Example\n\nThis configuration enables `text2vec-contextionary`, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\n\n```yaml\n---\nversion: '3.4'\nservices:\n  weaviate:\n    command:\n    - --host\n    - 0.0.0.0\n    - --port\n    - '8080'\n    - --scheme\n    - http\n    image: semitechnologies/weaviate:||site.weaviate_version||\n    ports:\n    - 8080:8080\n    restart: on-failure:0\n    environment:\n      CONTEXTIONARY_URL: contextionary:9999\n      QUERY_DEFAULTS_LIMIT: 25\n      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'\n      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'\n      # highlight-start\n      ENABLE_MODULES: 'text2vec-contextionary'\n      DEFAULT_VECTORIZER_MODULE: 'text2vec-contextionary'\n      # highlight-end\n      CLUSTER_HOSTNAME: 'node1'\n  # highlight-start\n  contextionary:\n    environment:\n      OCCURRENCE_WEIGHT_LINEAR_FACTOR: 0.75\n      EXTENSIONS_STORAGE_MODE: weaviate\n      EXTENSIONS_STORAGE_ORIGIN: http://weaviate:8080\n      NEIGHBOR_OCCURRENCE_IGNORE_PERCENTILE: 5\n      ENABLE_COMPOUND_SPLITTING: 'false'\n    image: semitechnologies/contextionary:en0.16.0-v1.2.1\n    ports:\n    - 9999:9999\n  # highlight-end\n...\n```\n\n## Class configuration\n\nYou can configure how the module will behave in each class through the Weaviate schema.\n\n### Vectorization settings\n\nYou can set vectorizer behavior using the `moduleConfig` section under each class and property:\n\n#### Class-level\n\n- `vectorizer` - what module to use to vectorize the data.\n- `vectorizeClassName` \u2013 whether to vectorize the class name. Default: `true`.\n\n#### Property-level\n\n- `skip` \u2013 whether to skip vectorizing the property altogether. Default: `false`\n- `vectorizePropertyName` \u2013 whether to vectorize the property name. Default: `false`\n\n#### Example\n\n```json\n{\n  \"classes\": [\n    {\n      \"class\": \"Document\",\n      \"description\": \"A class called document\",\n      \"vectorizer\": \"text2vec-contextionary\",\n      \"moduleConfig\": {\n        // highlight-start\n        \"text2vec-contextionary\": {\n          \"vectorizeClassName\": false\n        }\n        // highlight-end\n      },\n      \"properties\": [\n        {\n          \"name\": \"content\",\n          \"dataType\": [\n            \"text\"\n          ],\n          \"description\": \"Content that will be vectorized\",\n          // highlight-start\n          \"moduleConfig\": {\n            \"text2vec-contextionary\": {\n              \"skip\": false,\n              \"vectorizePropertyName\": false\n            }\n          }\n          // highlight-end\n        }\n      ],\n    }\n  ]\n}\n```\n\n### Class/property names\n\nIf you are using this module and are vectorizing the class or property name, the name(s) must be a part of the `text2vec-contextionary`.\n\nTo use multiple words as a class or property definition, concatenate them as:\n- camel case (e.g. `bornIn`) for class or property names, or\n- snake case (e.g. `born_in`) for property names.\n\nFor example, the following are acceptable:\n\n```yaml\nPublication\n  name\n  hasArticles\nArticle\n  title\n  summary\n  wordCount\n  url\n  hasAuthors\n  inPublication        # CamelCase (all versions)\n  publication_date     # snake_case (from v1.7.2 on)\nAuthor\n  name\n  wroteArticles\n  writesFor\n```\n\n## Usage example\n\nThis is an example of a `nearText` query with `text2vec-contextionary`.\n\n\n\n\n## Additional information\n\n### Find concepts\n\nTo find concepts or words or to check if a concept is part of the Contextionary, use the `v1/modules/text2vec-contextionary/concepts/` endpoint.\n\n```js\nGET /v1/modules/text2vec-contextionary/concepts/\n```\n\n#### Parameters\n\nThe only parameter `concept` is a string that should be camelCased in case of compound words or a list of words.\n\n#### Response\n\nThe result contains the following fields:\n- `\"individualWords\"`: a list of the results of individual words or concepts in the query, which contains:\n  - `\"word\"`: a string of requested concept or single word from the concept.\n  - `\"present\"`: a boolean value which is `true` if the word exists in the Contextionary.\n  - `\"info\"`: an object with the following fields:\n    - `\"\"nearestNeighbors\"`: a list with the nearest neighbors, containing `\"word\"` and `\"distance\"` (between the two words in the high dimensional space). Note that `\"word\"` can also be a data object.\n    - `\"vector\"`: the raw 300-long vector value.\n  - `\"concatenatedWord\"`: an object of the concatenated concept.\n    - `\"concatenatedWord\"`: the concatenated word if the concept given is a camelCased word.\n      - `\"singleWords\"`: a list of the single words in the concatenated concept.\n      - `\"concatenatedVector\"`: a list of vector values of the concatenated concept.\n      - `\"concatenatedNearestNeighbors\"`: a list with the nearest neighbors, containing `\"word\"` and `\"distance\"` (between the two words in the high dimensional space). Note that `\"word\"` can also be a data object.\n\n#### Example\n\n```bash\ncurl http://localhost:8080/v1/modules/text2vec-contextionary/concepts/magazine\n```\n\nor (note the camelCased compound concept)\n\n\n\n\nwith a result similar to:\n\n```json\n{\n  \"individualWords\": [\n    {\n      \"inC11y\": true,\n      \"info\": {\n        \"nearestNeighbors\": [\n          {\n            \"word\": \"magazine\"\n          },\n          {\n            \"distance\": 6.186641,\n            \"word\": \"editorial\"\n          },\n          {\n            \"distance\": 6.372504,\n            \"word\": \"featured\"\n          },\n          {\n            \"distance\": 6.5695524,\n            \"word\": \"editor\"\n          },\n          {\n            \"distance\": 7.0328364,\n            \"word\": \"titled\"\n          },\n          ...\n        ],\n        \"vector\": [\n          0.136228,\n          0.706469,\n          -0.073645,\n          -0.099225,\n          0.830348,\n          ...\n        ]\n      },\n      \"word\": \"magazine\"\n    }\n  ]\n}\n```\n\n### Model details\n\n`text2vec-contextionary` (Contextionary) is Weaviate's own language vectorizer that is trained using fastText on Wiki and CommonCrawl data.\n\nThe `text2vec-contextionary` model outputs a 300-dimensional vector. This vector is computed by using a Weighted Mean of Word Embeddings (WMOWE) technique.\n\nThe vector is calculated based on the centroid of the words weighted by the occurrences of the individual words in the original training text-corpus (e.g., the word `\"has\"` is seen as less important than the word `\"apples\"`).\n\ndata to vector with contextionary\n\n### Available languages\n\nContextionary models are available for the following languages:\n\n* Trained with on CommonCrawl and Wiki, using GloVe\n  * English\n  * Dutch\n  * German\n  * Czech\n  * Italian\n* Trained on Wiki\n  * English\n  * Dutch\n\n### Extending the Contextionary\n\nCustom words or abbreviations (i.e., \"concepts\") can be added to `text2vec-contextionary` through the `v1/modules/text2vec-contextionary/extensions/` endpoint.\n\nUsing this endpoint will enrich the Contextionary with your own words, abbreviations or concepts in context by transfer learning. Using the `v1/modules/text2vec-contextionary/extensions/` endpoint adds or updates the concepts in real-time.\n\nNote that you need to introduce the new concepts in to Weaviate before adding the data, as this will note cause Weaviate to automatically update the vectors.\n\n#### Parameters\n\nA body (in JSON or YAML) with the extension word or abbreviation you want to add to the Contextionary with the following fields includes a:\n- `\"concept\"`: a string with the word, compound word or abbreviation\n- `\"definition\"`: a clear description of the concept, which will be used to create the context of the concept and place it in the high dimensional Contextionary space.\n- `\"weight\"`: a float with the relative weight of the concept (default concepts in the Contextionary have a weight of 1.0)\n\n#### Response\n\nThe same fields as the input parameters will be in the response body if the extension was successful.\n\n#### Example\n\nLet's add the concept `\"weaviate\"` to the Contextionary.\n\n\n\n\nYou can always check if the new concept exists in the Contextionary:\n\n```bash\ncurl http://localhost:8080/v1/modules/text2vec-contextionary/concepts/weaviate\n```\n\nNote that it is not (yet) possible to extend the Contextionary with concatenated words or concepts consisting of more than one word.\n\nYou can also overwrite current concepts with this endpoint. Let's say you are using the abbreviation `API` for `Academic Performance Index` instead of `Application Programming Interface`, and you want to reposition this concept in the Contextionary:\n\n```bash\ncurl \\\n  -X POST \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"concept\": \"api\",\n    \"definition\": \"Academic Performance Index a measurement of academic performance and progress of individual schools in California\",\n    \"weight\": 1\n  }' \\\n  http://localhost:8080/v1/modules/text2vec-contextionary/extensions\n```\n\nThe meaning of the concept `API` has now changed in your Weaviate setting.\n\n### Stopwords\n\nNote that stopwords are automatically removed from camelCased and CamelCased names.\n\n\n\n#### Vectorization behavior\n\nStopwords can be useful, so we don't want to encourage you to leave them out completely. Instead Weaviate will remove them during vectorization.\n\nIn most cases you won't even notice that this happens in the background, however, there are a few edge cases that might cause a validation error:\n\n* If your camelCased class or property name consists **only** of stopwords, validation will fail. Example: `TheInA` is not a valid class name, however, `TheCarInAField` is (and would internally be represented as `CarField`).\n\n* If your keyword list contains stop words, they will be removed. However, if every single keyword is a stop word, validation will fail.\n\n#### How does Weaviate decide whether a word is a stop word or not?\n\nThe list of stopwords is derived from the Contextionary version used and is published alongside the Contextionary files.\n\n### Compound splitting\n\nSometimes Weaviate's Contextionary does not understand words which are compounded out of words it would otherwise understand. This impact is far greater in languages that allow for arbitrary compounding (such as Dutch or German) than in languages where compounding is not very common (such as English).\n\n#### Effect\n\nImagine you import an object of class `Post` with content `This is a thunderstormcloud`. The arbitrarily compounded word `thunderstormcloud` is not present in the Contextionary. So your object's position will be made up of the only words it recognizes: `\"post\", \"this\"` (`\"is\"` and `\"a\"` are removed as stopwords).\n\nIf you check how this content was vectorized using the `_interpretation` feature, you will see something like the following:\n\n```json\n\"_interpretation\": {\n  \"source\": [\n    {\n      \"concept\": \"post\",\n      \"occurrence\": 62064610,\n      \"weight\": 0.3623903691768646\n    },\n    {\n      \"concept\": \"this\",\n      \"occurrence\": 932425699,\n      \"weight\": 0.10000000149011612\n    }\n  ]\n}\n```\n\nTo overcome this limitation the optional **Compound Splitting Feature** can be enabled in the Contextionary. It will understand the arbitrary compounded word and interpret your object as follows:\n\n  ```json\n\"_interpretation\": {\n  \"source\": [\n    {\n      \"concept\": \"post\",\n      \"occurrence\": 62064610,\n      \"weight\": 0.3623903691768646\n    },\n    {\n      \"concept\": \"this\",\n      \"occurrence\": 932425699,\n      \"weight\": 0.10000000149011612\n    },\n    {\n      \"concept\": \"thunderstormcloud (thunderstorm, cloud)\",\n      \"occurrence\": 5756775,\n      \"weight\": 0.5926488041877747\n    }\n  ]\n}\n  ```\n\nNote that the newly found word (made up of the parts `thunderstorm` and `cloud` has the highest weight in the vectorization. So this meaning, which would have been lost without Compound Splitting, can now be recognized.\n\n#### How to enable\nYou can enable Compound Splitting in the Docker Compose file of the `text2vec-contextionary`. See how this is done here.\n\n#### Trade-Off Import speed vs Word recognition\n\nCompound Splitting runs an any word that is otherwise not recognized. Depending on your dataset, this can lead to a significantly longer import time (up to 100% longer). Therefore, you should carefully evaluate whether the higher precision in recognition or the faster import times are more important to your use case. As the benefit is larger in some languages (e.g. Dutch, German) than in others (e.g. English) this feature is turned off by default.\n\n### Noise filtering\n\nSo called \"noise words\" are concatenated words of random words with no easily recognizable meaning. These words are present in the Contextionary training space, but are extremely rare and therefore distributed seemingly randomly. As a consequence, an \"ordinary\" result of querying features relying on nearest neighbors (additional properties `nearestNeighbors` or `semanticPath`) might contain such noise words as immediate neighbors.\n\nTo combat this noise, a neighbor filtering feature was introduced in the contextionary, which ignores words of the configured bottom percentile - ranked by occurrence in the respective training set. By default this value is set to the bottom 5th percentile. This setting can be overridden. To set another value, e.g. to ignore the bottom 10th percentile, provide the environment variable `NEIGHBOR_OCCURRENCE_IGNORE_PERCENTILE=10` to the `text2vec-contextionary` container, in the Docker Compose file.\n\n## Model license(s)\n\nThe `text2vec-contextionary` module is based on the `fastText` library, which is released under the MIT license. Please refer to the license file for more information.\n\nIt is your responsibility to evaluate whether the terms of its license(s), if any, are appropriate for your intended use.\n\n\n\n\n", "type": "Documentation", "name": "retriever-vectorizer-modules-text2vec-contextionary", "path": "developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary.md", "link": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary", "timestamp": "2023-11-13 10:41:10", "reader": "JSON", "meta": {}, "chunks": []}