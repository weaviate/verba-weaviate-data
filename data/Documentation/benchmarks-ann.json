{"text": "\n\n# About this benchmark\n\nThis benchmark is designed to measure and illustrate Weaviate's ANN performance for a range of real-life use cases.\n\nThis is not a comparative benchmark that runs Weaviate against competing\nsolutions.\n\nTo make the most of this benchmark, you can look at it from different perspectives:\n\n- **The overall performance** \u2013 Review the benchmark result section below to draw conclusions about what to expect from Weaviate in a production setting.\n- **Expectation for your use case** \u2013 Find the dataset closest to your production use case, and estimate Weaviate's expected performance for your use case.\n- **Fine Tuning** \u2013 If you don't get the results you expect. Find the optimal combinations of the config parameters (efConstruction, maxConnections and ef) to achieve the best results for your production configuration.\n\n## What is being measured?\n\nFor each benchmark test, we picked parameters of:\n- **efConstruction** - The HNSW build parameter that controls the quality of the\n  search at build time.\n- **maxConnections**\t - The HNSW build parameter controls how many outgoing\n  edges a node can have in the HNSW graph.\n- **ef** - The HNSW query time parameter that controls the quality of the search.\n\nFor each set of parameters we've run 10000 requests and we measured:\n\n- The **Recall@1**, **Recall@10**, **Recall@100** - by comparing Weaviate's results to the\n  ground truths specified in each dataset\n- **Multi-threaded Queries per Second (QPS)** - The overall throughput you can\n  achieve with each configuration\n- **Individual Request Latency (mean)** - The mean latency over all 10,000 requests\n- **P99 Latency** - 99% of all requests (9.900 out of 10.000) have a latency that\n  is lower than or equal to this number \u2013 this shows how fast\n- **Import time** - Since varying build parameters has an effect on import\n  time, the import time is also included\n\nBy request, we mean:\nAn unfiltered vector search across the entire dataset for the given test. All\nlatency and throughput results represent the end-to-end time that your\nusers would also experience. In particular, these means:\n\n* Each request time includes the network overhead for sending the results over the\n  wire. In the test setup, the client and server machines were located in the\n  same VPC.\n* Each request includes retrieving all the matched objects from disk. This is\n  a significant difference from `ann-benchmarks`, where the embedded libraries\n  only return the matched IDs.\n\n## Benchmark Setup\n\n### Scripts\n\nThis benchmark is produced using [open-source\nscripts](https://github.com/weaviate/weaviate-benchmarking), so you can reproduce it yourself.\n\n### Hardware\n\nSetup with Weaviate and benchmark machine\n\nFor the purpose of this benchmark we've used two GCP instances within the same VPC:\n\n* **Benchmark** \u2013 a `c2-standard-30` instance with 30 vCPU cores and 120 GB memory \u2013 to host Weaviate.\n* **Script** \u2013 a smaller instance with 8 vCPU \u2013 to run benchmarking scripts.\n\n\ud83d\udca1 the `c2-standard-30` was chosen for benchmarking for two reasons:\n\n* It is large enough to show that Weaviate is a highly-concurrent vector search\n  engine and scales well while running thousands of searches across multiple threads.\n* It is small enough to represent a typical production case without inducing\n  high costs.\n\nBased on your throughput requirements, it is very likely that you will run Weaviate\non a considerably smaller or larger machine in production.\n\nIn this section below\nwe have outlined what you should expect when altering the configuration or\nsetup parameters.\n\n### Experiment Setup\n\nThe selection of datasets is modeled after\nann-benchmarks. The same test\nqueries are used to test speed, throughput, and recall. The provided ground\ntruths are used to calculate the recall.\n\nThe imports were performed using Weaviate's python clients. The concurrent\n(multi-threaded) queries were measured using Go. Each language may have a\nslightly different performance, and you may experience different results if you\nsend your queries using another language. For the maximum throughput, we\nrecommend using the Go or\nJava clients.\n\nThe complete import and test scripts are available here.\n\n## Results\n\n   The following results section contains multiple datasets. To get the most of\n   this benchmark, pick the dataset that is closest to the use case that\n   reflects your data in production based on the following criteria:\n\n   \n     SIFT1M - A dataset containing 1 million objects of\n     128d and using l2 distance metrics. This dataset reflects a common\n     use case with a small number of objects.\n     Glove-25 - While similar in data size to SIFT1M, each\n     vector only has 25 dimensions in this dataset. Because of the smaller\n     vectors Weaviate can achieve the highest throghput on this dataset. The\n     distance metric used is angular (cosine distance).\n     Deep Image 96 - This dataset contains 10 million objects\n     at 96d, and is therefore about 10 times as large as SIFT1M. The throughput\n     is only slightly lower than that of the SIFT1M. This dataset gives you a\n     good indication of expected speeds and throughputs when datasets\n     grow.\n     GIST 960 - This dataset contains 1 million objects at\n     960d.  It has the lowest throughput of the datasets outlined. It\n     highlights the cost of vector comparisons with a lot of dimensions. Pick\n     this dataset if you run very high-dimensional loads.\n\n   \n\nFor each dataset, there is a highlighted configuration. The highlighted\nconfiguration is an opinionated pick about a good recall/latency/throughput\ntrade-off. The highlight sections will give you a good overview of Weaviate's\nperformance with the respective dataset. Below the highlighted configuration,\nyou can find alternative configurations.\n\n### SIFT1M (1M 128d vectors, L2 distance)\n\n#### Highlighted Configuration\n\n\n| **1.0M** | **128** | **l2** | **128** | **32** | **64** |\n| --- | --- | --- | --- | --- |\n| Dataset Size | Dimensions | Distance Metric | efConstruction | maxConnections | ef |\n\n| **98.83%** | **8905** | **3.31ms** | **4.49ms** |\n| --- | --- | --- | --- |\n| Recall@10 | QPS (Limit 10) | Mean Latency (Limit 10) | p99 Latency (Limit 10) |\n\n#### All Results\n\n#### QPS vs Recall\n\nSIFT1M Benchmark results\n\n\n\n\n\n\n\n### Glove-25 (1.2M 25d vectors, cosine distance)\n\n#### Highlighted Configuration\n\n| **1.28M** | **35** | **cosine** | **64** | **16** | **64** |\n| --- | --- | --- | --- | --- |\n| Dataset Size | Dimensions | Distance Metric | efConstruction | maxConnections | ef |\n\n| **95.56%** | **15003** | **1.93ms** | **2.94ms** |\n| --- | --- | --- | --- |\n| Recall@10 | QPS (Limit 10) | Mean Latency (Limit 10) | p99 Latency (Limit 10) |\n\n#### All Results\n\n#### QPS vs Recall\n\nGlove25 Benchmark results\n\n\n\n\n\n\n### Deep Image 96 (9.99M 96d vectors, cosine distance)\n\n#### Highlighted Configuration\n\n| **9.99M** | **96** | **cosine** | **128** | **32** | **64** |\n| --- | --- | --- | --- | --- |\n| Dataset Size | Dimensions | Distance Metric | efConstruction | maxConnections | ef |\n\n| **96.43%** | **6112** | **4.7ms** | **15.87ms** |\n| --- | --- | --- | --- |\n| Recall@10 | QPS (Limit 10) | Mean Latency (Limit 10) | p99 Latency (Limit 10) |\n\n#### All Results\n\n#### QPS vs Recall\n\nDeep Image 96 Benchmark results\n\n\n\n\n\n\n### GIST 960 (1.0M 960d vectors, cosine distance)\n\n#### Highlighted Configuration\n\n| **1.00M** | **960** | **cosine** | **512** | **32** | **128** |\n| --- | --- | --- | --- | --- |\n| Dataset Size | Dimensions | Distance Metric | efConstruction | maxConnections | ef |\n\n| **94.14%** | **1935** | **15.05ms** | **19.86ms** |\n| --- | --- | --- | --- |\n| Recall@10 | QPS (Limit 10) | Mean Latency (Limit 10) | p99 Latency (Limit 10) |\n\n#### All Results\n\n#### QPS vs Recall\n\nGIST 960 Benchmark results\n\n\n\n\n\n\n## Learn more & FAQ\n\n### What is the difference between latency and throughput?\n\nThe latency refers to the time it takes to complete a single request. This\nis typically measured by taking a mean or percentile distribution of all\nrequests. For example, a mean latency of 5ms means that a single request takes\non average 5ms to complete. This does not say anything about how many queries\ncan be answered in a given timeframe.\n\nIf Weaviate were single-threaded, the throughput per second would roughly equal\nto 1s divided by mean latency. For example, with a mean latency of 5ms, this\nwould mean that 200 requests can be answered in a second.\n\nHowever, in reality, you often don't have a single user sending one query after\nanother. Instead, you have multiple users sending queries. This makes the\nquerying-side concurrent. Similarly, Weaviate can handle concurrent incoming\nrequests. We can identify how many concurrent requests can be served by measuring\nthe throughput.\n\nWe can take our single-thread calculation from before and multiply it with the\nnumber of server CPU cores. This will give us a rough estimate of what the\nserver can handle concurrently. However, it would be best never to trust this\ncalculation alone and continuously measure the actual throughput. This is because\nsuch scaling may not always be linear. For example, there may be synchronization\nmechanisms used to make concurrent access safe, such as locks. Not only do\nthese mechanisms have a cost themselves, but if implemented incorrectly, they\ncan also lead to congestion which would further decrease the concurrent\nthroughput. As a result, you cannot perform a single-threaded benchmark and\nextrapolate what the numbers would be like in a multi-threaded setting.\n\nAll throughput numbers (\"QPS\") outlined in this benchmark are actual\nmulti-threaded measurements on a 30-core machine, not estimations.\n\n### What is a p99 latency?\n\nThe mean latency gives you an average value of all requests measured. This is a\ngood indication of how long a user will have to wait on average for\ntheir request to be completed. Based on this mean value, you cannot make any\npromises to your users about wait times. 90 out of 100 users might see a\nconsiderably better time, but the remaining 10 might see a significantly worse\ntime.\n\nTo give a more precise indication, percentile-based latencies are used. A\n99th-percentile latency - or \"p99 latency\" for short - indicates the slowest\nrequest that 99% of requests experience. In other words, 99% of your users will\nexperience a time equal to or better than the stated value. This is a much\nbetter guarantee than a mean value.\n\nIn production settings, requirements - as stated in SLAs - are often a\ncombination of throughput and a percentile latency. For example, the statement\n\"3000 QPS at p95 latency of 20ms\" conveys the following meaning.\n\n- 3000 requests need to be successfully completed per second\n- 95% of users must see a latency of 20ms or lower.\n- There is no assumption about the remaining 5% of users, implicitly tolerating\n  that they will experience higher latencies than 20ms.\n\nThe higher the percentile (e.g. p99 over p95) the \"safer\" the quoted\nlatency becomes. We have thus decided to use p99-latencies instead of\np95-latencies in our measurements.\n\n### What happens if I run with fewer or more CPU cores than on the example test machine?\n\nThe benchmark outlines a QPS per core measurement. This can help you make a\nrough estimation of how the throughput would vary on smaller or larger\nmachines. If you do not need the stated throughput, you can run with fewer CPU\ncores. If you need more throughput, you can run with more CPU cores.\n\nPlease note that there is a point of diminishing returns with adding more CPUs because of synchronization mechanisms, disk, and memory bottlenecks. Beyond that point, you can scale horizontally instead of vertically. Horizontal scaling with replication will be available in Weaviate soon.\n\n### What are ef, efConstruction, and maxConnections?\n\nThese parameters refer to the [HNSW build and query\nparameters](/developers/weaviate/configuration/indexes.md#how-to-configure-hnsw).\nThey represent a trade-off between recall, latency & throughput, index size, and\nmemory consumption. This trade-off is highlighted in the benchmark results.\n\n### I can't match the same latencies/throughput in my own setup, how can I debug this?\n\nIf you are encountering other numbers in your own dataset, here are a couple of\nhints to look at:\n\n* What CPU architecture are you using? The benchmarks above were run on a GCP\n  `c2` CPU type, which is based on `amd64` architecture. Weaviate also supports\n  `arm64` architecture, but not all optimizations are present. If your machine\n  shows maximum CPU usage but you cannot achieve the same throughput, consider\n  switching the CPU type to the one used in this benchmark.\n\n* Are you using an actual dataset or random vectors? HNSW is known to perform\n  considerably worse with random vectors than with real-world datasets. This is due\n  to the distribution of points in real-world datasets compared to randomly\n  generated vectors. If you cannot achieve the performance (or recall)\n  outlined above with random vectors, switch to an actual dataset.\n\n* Are your disks fast enough? While the ANN search itself is CPU-bound, the objects\n  must be read from disk after the search has been completed. Weaviate\n  uses memory-mapped files to speed this process up. However, if not enough\n  memory is present or the operating system has allocated the cached pages\n  elsewhere, a physical disk read needs to occur. If your disk is slow,\n  it could then be that your benchmark is bottlenecked by those disks.\n\n* Are you using more than 2 million vectors? If yes, make sure to set the\n  vector cache large enough\n  for maximum performance.\n\n### Where can I find the scripts to run this benchmark myself?\n\nThe repository is located here.\n\n\n\n", "type": "Documentation", "name": "benchmarks-ann", "path": "developers/weaviate/benchmarks/ann.md", "link": "https://weaviate.io/developers/weaviate/benchmarks/ann", "timestamp": "2023-11-13 10:40:16", "reader": "JSON", "meta": {}, "chunks": []}