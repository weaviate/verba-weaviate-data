{"text": "\n\n## Overview\n\n- Which Weaviate is right for me?\n- How-to: Generative search\n\nThis pages introduces you to generative search with Weaviate. It covers:\n\n- What generative search, or RAG, is.\n- How to configure Weaviate for generative search.\n- How to perform generative searches.\n- Importing data with generative search in mind.\n\n### Prerequisites\n\nThis guide assumes some familiarity with Weaviate, but it is not required. If you are new to Weaviate, we suggest starting with the Weaviate Quickstart guide.\n\n## Background\n\n### What is generative search?\n\nGenerative search is a powerful technique that retrieves relevant data to provide to large language models (LLMs) as context, along with the task prompt. It is also called retrieval augmented generation (RAG), or in-context learning in some cases.\n\n### Why generative search?\n\nLLM are incredibly powerful, but can suffer from two important limitations. These limitation are that:\n- They can confidently produce incorrect, or outdated, information (also called 'hallucination'); and\n- They might simply not be trained on the information you need.\n\nGenerative search remedies this problem with a two-step process.\n\nThe first step is to retrieve relevant data through a query. Then, in the second step, the LLM is prompted with a combination of the retrieve data with a user-provided query.\n\nThis provides in-context learning for the LLM, which causes it to use the relevant and up-to-date data rather than rely on recall from its training, or even worse, hallucinated outputs.\n\n### Weaviate and generative search\n\nWeaviate incorporates key functionalities to make generative search easier and faster.\n\nFor one, Weaviate's search capabilities make it easier to find relevant information. You can use any of similarity, keyword and hybrid searches, along with filtering capabilities to find the information you need.\n\nAdditionally, Weaviate has integrated generative search capabilities, so that the retrieval and generation steps are combined into a single query. This means that you can use Weaviate's search capabilities to retrieve the data you need, and then in the same query, prompt the LLM with the same data.\n\nThis makes it easier, faster and more efficient to implement generative search workflows in your application.\n\n## Examples of generative search\n\nLet's begin by viewing examples of generative search in action. We will then explore how to configure Weaviate for generative search.\n\nWe will use the publicly available `https://edu-demo.weaviate.network` instance, which you can access with the `learn-weaviate` read-only API key. These examples are configured with the `generative-openai` module and the `gpt-3.5-turbo` model, so you will need an OpenAI API key.\n\nConnect to the instance like so, remembering to replace the API key for the LLM used (OpenAI in this case) with your own API key:\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Data retrieval\n\nLet's take an illustrative example with passages from a book. Here, the Weaviate instance contains a collection of passages from the Pro Git book.\n\nBefore we can generate text, we need to retrieve relevant data. Let's retrieve the three most similar passages to the meaning of `history of git` with a semantic search.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis should return a set of results like the following (truncated for brevity):\n\n```\n{\n  \"data\": {\n    \"Get\": {\n      \"GitBookChunk\": [\n        {\n          \"chapter_title\": \"01-introduction\",\n          \"chunk\": \"=== A Short History of Git\\n\\nAs with many great things in life, Git began with a bit of creative ...\",\n          \"chunk_index\": 0\n        },\n        {\n          \"chapter_title\": \"01-introduction\",\n          \"chunk\": \"== Nearly Every Operation Is Local\\n\\nMost operations in Git need only local files and resources ...\",\n          \"chunk_index\": 2\n        },\n        {\n          \"chapter_title\": \"02-git-basics\",\n          \"chunk\": \"==\\nYou can specify more than one instance of both the `--author` and `--grep` search criteria...\",\n          \"chunk_index\": 2\n        },\n      ]\n    }\n  }\n}\n\n```\n\n### Transform result sets\n\nWe can transform this result set into new text using generative search with just a minor modification of the code. First, let's use a `grouped task` prompt to summarize this information.\n\nRun the following code snippet, and inspect the results:\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere is our generated text:\n\n```\n- Git began as a replacement for the proprietary DVCS called BitKeeper, which was used by the Linux kernel project.\n- The relationship between the Linux development community and BitKeeper broke down in 2005, leading to the development of Git by Linus Torvalds.\n- Git was designed with goals such as speed, simple design, strong support for non-linear development, and the ability to handle large projects efficiently.\n- Most operations in Git only require local files and resources, making them fast and efficient.\n- Git allows browsing project history instantly and can calculate differences between file versions locally.\n- Git allows offline work and does not require a network connection for most operations.\n- This book was written using Git version 2, but most commands should work in older versions as well.\n```\n\nIn a `grouped task` generative search, Weaviate:\n- Retrieves the three most similar passages to the meaning of `history of git`.\n- Then prompts the LLM with a combination of:\n    - Text from all of the search results, and\n    - The user-provided prompt, `Summarize the key information here in bullet points`.\n\nNote that the user-provided prompt did not contain any information about the subject matter. But because Weaviate retrieve the relevant data about the history of git, it was able to summarize the information relating to this subject matter using verifiable data.\n\nThat's how easy it is to use generative search in Weaviate.\n\nThere will be variability in the actual text that has been generated. This due to the randomness in LLMs' behaviors, and variability across models. This is perfectly normal.\n\n### Transform individual objects\n\nIn this example, we will take a look at how to transform individual objects. This is useful when you want to generate text for each object individually, rather than for the entire result set.\n\nHere we prompt the model to translate individual wine reviews into French, using emojis. The reviews is a subset from a publicly available dataset of wine reviews.\n\nNote that in this query, we apply a `single prompt` parameter. This means that the LLM is prompted with each object individually, rather than with the entire result set.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs the query was run with a limit of 5, you should see 5 objects returned, including generated texts.\n\nHere is our generated text for the first object, and the source text:\n\n```\n===== Generated text =====\n\ud83c\uddfa\ud83c\uddf8\ud83c\udf77\ud83c\udf3f\ud83c\udf51\ud83c\udf3c\ud83c\udf6f\ud83c\udf4a\ud83c\udf6e\ud83c\udf7d\ufe0f\ud83c\udf1f\n\nOrigine : \u00c9tats-Unis\nTitre : Schmitz 24 Brix 2012 Sauvignon Blanc (Sierra Foothills)\nCorps de la critique : Pas du tout un Sauvignon Blanc typique, il sent l'abricot et le ch\u00e8vrefeuille et a le go\u00fbt de la marmelade. Il est sec, mais a le go\u00fbt d'un vin de dessert tardif. Attendez-vous \u00e0 une petite aventure gustative ici.\n\n===== Original review =====\nCountry: US,\nTitle: Schmitz 24 Brix 2012 Sauvignon Blanc (Sierra Foothills)\nReview body Not at all a typical Sauvignon Blanc, this smells like apricot and honeysuckle and tastes like marmalade. It is dry, yet tastes like a late-harvest dessert wine. Expect a little taste adventure here.\n```\n\nHere, Weaviate has:\n- Retrieved five most similar wine reviews to the meaning of `fruity white wine`.\n- For each result, prompted the LLM with:\n    - The user-provided prompt, replacing `{country}`, `{title}`, and `{review_body}` with the corresponding text.\n\nIn both examples, you saw Weaviate return new text that is original, but grounded in the retrieved data. This is what makes generative search powerful, by combining the best of data retrieval and language generation.\n\n## Generative search, end-to-end\n\nNow, let's go through an end-to-end example for using Weaviate for generative search.\n\n### Your own Weaviate instance\n\nFor this example, you will need access to a Weaviate instance that you can write to. You can use any Weaviate instance, such as a local Docker instance, or a WCS instance.\n\n### Configure generative search\n\nCurrently, a generative module cannot be changed in the Weaviate collection definition once it has been set. We are looking to change this going forward.\n\n\nIf you would like for us to prioritize this issue, please go to GitHub here, and give it a thumbs up.\n\nTo use generative search, the appropriate `generative-xxx` module must be:\n- Enabled in Weaviate, and\n- Specified in the collection definition.\n\nEach module is tied to a specific group of LLMs, such as `generative-cohere` for Cohere models, `generative-openai` for OpenAI models and `generative-palm` for PaLM and Gemini models.\n\nIf you are using WCS, you will not need to do anything to enable modules.\n\n\n  How to list enabled modules\n\nYou can check which modules are enabled by viewing the `meta` information for your Weaviate instance, as shown below:\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe response will include a list of modules. Check that your desired module is enabled.\n\n\n\n\n  How to enable modules\n\nFor configurable deployments, you can specify enabled modules. For example, in a Docker deployment, you can do so by listing them on the `ENABLE_MODULES` environment variable, as shown below:\n\n```yaml\nservices:\n  weaviate:\n    environment:\n      ENABLE_MODULES: 'text2vec-cohere,text2vec-huggingface,text2vec-openai,text2vec-palm,generative-cohere,generative-openai,generative-palm'\n```\n\nCheck the specific documentation for your deployment method (Docker, Kubernetes, Embedded Weaviate) for more information on how to configure it.\n\n\n\n\n  How to configure the language model\n\nModel properties are exposed through the Weaviate module configuration. Accordingly, you can customize them through the `moduleConfig` parameter in the collection definition.\n\nFor example, the `generative-cohere` module has the following properties:\n\n```json\n    \"moduleConfig\": {\n        \"generative-cohere\": {\n            \"model\": \"command-xlarge-nightly\",  // Optional - Defaults to `command-xlarge-nightly`. Can also use`command-xlarge-beta` and `command-xlarge`\n            \"temperatureProperty\": ,  // Optional\n            \"maxTokensProperty\": ,  // Optional\n            \"kProperty\": , // Optional\n            \"stopSequencesProperty\": , // Optional\n            \"returnLikelihoodsProperty\": , // Optional\n        }\n    }\n```\n\nAnd the `generative-openai` module may be configured as follows:\n\n```json\n    \"moduleConfig\": {\n        \"generative-openai\": {\n            \"model\": \"gpt-3.5-turbo\",  // Optional - Defaults to `gpt-3.5-turbo`\n            \"temperatureProperty\": ,  // Optional, applicable to both OpenAI and Azure OpenAI\n            \"maxTokensProperty\": ,  // Optional, applicable to both OpenAI and Azure OpenAI\n            \"frequencyPenaltyProperty\": ,  // Optional, applicable to both OpenAI and Azure OpenAI\n            \"presencePenaltyProperty\": ,  // Optional, applicable to both OpenAI and Azure OpenAI\n            \"topPProperty\": ,  // Optional, applicable to both OpenAI and Azure OpenAI\n        },\n    }\n```\n\nPlease see the documentation for the appropriate module for more information on configurable properties.\n\n\n\n### Populate database\n\nAdding data to Weaviate for generative search is similar to adding data for other purposes. However, there are some important considerations to keep in mind, such as chunking and data structure.\n\nYou can read further discussions in the Best practices & tips section. Here, we will use a chunk length of 150 words and a 25-word overlap. We will also include the title of the book, the chapter it is from, and the chunk number. This will allow us to search through the chunks, as well as filter it.\n\n#### Download & chunk\n\nIn the following snippet, we download a chapter of the `Pro Git` book, clean it and chunk it.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will download the text from the chapter, and return a list/array of strings of 150 word chunks, with a 25-word overlap added in front.\n\n#### Create collection definitions\n\nWe can now create a collection definition for the chunks. To use generative search, your desired generative module must be specified at the collection level as shown below.\n\nThe below collection definition for the `GitBookChunk` collection specifies `text2vec-openai` as the vectorizer and `generative-openai` as the generative module. Note that the `generative-openai` parameter can have an empty dictionary/object as its value, which will use the default parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### Import data\n\nNow, we can import the data into Weaviate.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOnce this is done, you should have imported a collection of chunks from the chapter into Weaviate. You can check this by running a simple aggregation query:\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhich should indicate that there are `10` chunks in the database.\n\n### Generative queries\n\nNow that we have configured Weaviate and populated it with data, we can perform generative queries as you saw in the examples above.\n\n#### Single (per-object) prompts\n\nSingle prompts tell Weaviate to generate text based on each retrieved object and the user-provided prompt. In this example, we retrieve two objects and prompt the language model to write a haiku based on the text of each chunk.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIt should return haiku-like text, such as:\n\n```\n===== Object index: [1] =====\nGit's data stored\nAs snapshots of files, not changes\nEfficient and unique\n\n===== Object index: [6] =====\nGit has three states:\nUntracked, modified, staged.\nCommit to save changes.\n```\n\n#### Grouped tasks\n\nA grouped task is a prompt that is applied to a group of objects. This allows you to prompt the language model with the entire set of search results, such as source documents or relevant passages.\n\nIn this example, we prompt the language model to write a trivia tweet based on the result.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIt should return a factoid written for social media, such as:\n\n```\nDid you know? \ud83e\udd14 Git thinks of its data as snapshots, not just changes to files.\n\ud83d\udcf8 Every time you commit, Git takes a picture of all your files and stores a reference to that snapshot.\n\ud83d\udcc2\ud83d\udd17 #GitTrivia\n```\n\n#### Pairing with search\n\nGenerative search in Weaviate is a two-step process under the hood, involving retrieval of objects and then generation of text. This means that you can use the full power of Weaviate's search capabilities to retrieve the objects you want to use for generation.\n\nIn this example, we search the chapter for passages that relate to the states of git before generating a tweet as before.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis should return text like:\n\n```\n\ud83d\udcdd Did you know? Git has three main states for files: modified, staged, and committed.\n\ud83c\udf33\ud83d\udce6\ud83d\udcc2 Learn more about these states and how they affect your Git project!\n#GitBasics #Trivia\n```\n\nNow, simply by changing the search query, we can generate similar content about different topics.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this case, the result should be something like:\n\n```\nDid you know? \ud83e\udd14 Git stores everything by the hash value of its contents, not by file name!\n\ud83d\udcc1\ud83d\udd0d It's hard to lose data in Git, making it a joy to use!\n\ud83d\ude04\ud83d\udd12 Git thinks of its data as a stream of snapshots, making it more than just a VCS!\n\ud83d\udcf8\ud83c\udf1f Most Git operations are local, so no need for network latency!\n\ud83c\udf10\ud83d\udca8 #GitTrivia\n```\n\nAs you can see, Weaviate allows you to use the full power of search to retrieve the objects you want to use for generation. This allows you to ground the language model in the context of up-to-date information, which you can retrieve with the full power of Weaviate's search capabilities.\n\n## Best practices & tips\n\n\n### Chunking\n\nIn the context of language processing, \"chunking\" refers to the process of splitting texts into smaller pieces of texts, i.e. \"chunks\".\n\nFor generative search, chunking affects both the information retrieval and the amount of contextual information provided.\n\nWhile there is no one-size-fits all chunking strategy that we can recommend, we can provide some general guidelines. Chunking by semantic markers, or text length may both be viable strategies.\n\n#### Chunking by semantic markers\n\nUsing semantic markers, such as paragraphs, or sections can be a good strategy that will allows you to retain related information in each chunk. Some potential risks are that chunk lengths may vary significantly, and outlier conditions may occur common (e.g. chunks with headers that are not particularly meaningful).\n\n#### Chunking by text length\n\nUsing text length, such as 100-150 words, can be a robust baseline strategy. This will allow you to retrieve relevant information without having to worry about the exact length of the text. One potential risk is that chunks may be cut off where they are not semantically meaningful, cutting off important contextual information.\n\nYou could use a sliding window approach to mitigate this risk, by overlapping chunks. The length of each chunk can be adjusted to your needs, and based on any unit, such as words, tokens, or even characters.\n\nA baseline strategy could involve using chunks created with a 100-200 word sliding window and a 50-word overlap.\n\n#### Mixed-strategy chunking\n\nAnother, slightly more complicated strategy may be using paragraph-based chunks with a maximum and a minimum length, say of 200 words and 50 words respectively.\n\n### Data structure\n\nAnother important consideration is the data structure. For example, your chunk object could also contain any additional source-level data, such as the title of the book, the chapter it is from, and the chunk number.\n\nThis will allow you to search through the chunks, as well as filter it. Then, you could use this information to control the generation process, such as by prompting the LLM with contextual data (chunks) in the order that they appear in the source document.\n\nAdditionally, you could link the chunks to the source document, allowing you to retrieve the source document, or even the entire source document, if needed.\n\n### Complex prompts\n\nWhile the field of prompting is relatively new, it has seen significant advancements already.\n\nAs one example, a technique called \"chain-of-thought prompting\" can be an effective technique. It suggests that the prompt can be used to nudge the model towards producing intermediate reasoning steps, which improves the quality of the answer.\n\nWe recommend keeping up to date with the latest developments in the field, and experimenting with different techniques.\n\nOur own Connor Shorten's podcast is a great resource for keeping up with the research, as are resources such as Arxiv, and PapersWithCode.\n\n## Wrap-up\n\nWe've explored the dynamic capabilities of generative search in Weaviate, showcasing how it enhances large language models through retrieval-augmented generation.\n\nTo learn more about specific search capabilities, check out the How-to: search guide. And to learn more about individual modules, check out the Modules section.\n\n\n\n\n\n", "type": "Documentation", "name": "starter-guides-generative", "path": "developers/weaviate/starter-guides/generative.md", "link": "https://weaviate.io/developers/weaviate/starter-guides/generative", "timestamp": "2024-02-08 20:23:44", "reader": "JSON", "meta": {}, "chunks": []}