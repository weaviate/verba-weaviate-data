{"text": "\n\n\n\n\n## Overview\n\nConditional filters may be added to `Object-level` and `Aggregate` queries. The operator used for filtering is also called a `where` filter.\n\nA filter may consist of one or more conditions, which are combined using the `And` or `Or` operators. Each condition consists of a property path, an operator, and a value.\n\n\n## Single operand (condition)\n\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\n- The operator type,\n- The property path, and\n- The value as well as the value type.\n\nFor example, this filter will only allow objects from the class `Article` with a `wordCount` that is `GreaterThan` than `1000`.\n\n\n\n\n\n  Expected response\n\n```\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Anywhere but Washington: an eye-opening journey in a deeply divided nation\"\n        },\n        {\n          \"title\": \"The world is still struggling to implement meaningful climate policy\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n## Filter structure\n\nThe `where` filter is an algebraic object, which takes the following arguments:\n\n- `Operator` (which takes one of the following values)\n  - `And`\n  - `Or`\n  - `Equal`\n  - `NotEqual`\n  - `GreaterThan`\n  - `GreaterThanEqual`\n  - `LessThan`\n  - `LessThanEqual`\n  - `Like`\n  - `WithinGeoRange`\n  - `IsNull`\n  - `ContainsAny`  (*Only for array and text properties)\n  - `ContainsAll`  (*Only for array and text properties)\n- `Path`: Is a list of strings in XPath style, indicating the property name of the collection.\n  - If the property is a cross-reference, the path should be followed as a list of strings. For a `inPublication` reference property that refers to `Publication` collection, the path selector for `name` will be `[\"inPublication\", \"Publication\", \"name\"]`.\n- `valueType`\n  - `valueInt`: For `int` data type.\n  - `valueBoolean`: For `boolean` data type.\n  - `valueString`: For `string` data type (note: `string` has been deprecated).\n  - `valueText`: For `text`, `uuid`, `geoCoordinates`, `phoneNumber` data types.\n  - `valueNumber`: For `number` data type.\n  - `valueDate`: For `date` (ISO 8601 timestamp, formatted as RFC3339) data type.\n\nIf the operator is `And` or `Or`, the operands are a list of `where` filters.\n\n\n  Example filter structure (GraphQL)\n\n```graphql\n{\n  Get {\n    (where: {\n        operator: ,\n        operands: [{\n          path: [path],\n          operator: \n          : \n        }, {\n          path: [],\n          operator: ,\n          : \n        }]\n      }) {\n       {\n        \n        ... on  {\n          \n        }\n      }\n    }\n  }\n}\n```\n\n\n\n\n  Example response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Opinion | John Lennon Told Them \u2018Girls Don't Play Guitar.' He Was So Wrong.\"\n        }\n      ]\n    }\n  },\n  \"errors\": null\n}\n```\n\n\n\n### Filter behaviors\n\n#### Multi-word queries in `Equal` filters\n\nThe behavior for the `Equal` operator on multi-word textual properties in `where` filters depends on the `tokenization` of the property.\n\nSee the Schema property tokenization section for the difference between the available tokenization types.\n\n#### Stopwords in `text` filters\n\nStarting with `v1.12.0` you can configure your own stopword lists for the inverted index.\n\n## Multiple operands\n\nYou can set multiple operands or nest conditions.\n\nYou can filter datetimes similarly to numbers, with the `valueDate` given as `string` in RFC3339 format.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"China\\u2019s long-distance lorry drivers are unsung heroes of its economy\"\n        },\n        {\n          \"title\": \"\\u2018It\\u2019s as if there\\u2019s no Covid\\u2019: Nepal defies pandemic amid a broken economy\"\n        },\n        {\n          \"title\": \"A tax hike threatens the health of Japan\\u2019s economy\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n## Filter operators\n\n### `Like`\n\nThe `Like` operator filters `text` data based on partial matches. It can be used with the following wildcard characters:\n\n- `?` -> exactly one unknown character\n  - `car?` matches `cart`, `care`, but not `car`\n- `*` -> zero, one or more unknown characters\n  - `car*` matches `car`, `care`, `carpet`, etc\n  - `*car*` matches `car`, `healthcare`, etc.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Publication\": [\n        {\n          \"name\": \"The New York Times Company\"\n        },\n        {\n          \"name\": \"International New York Times\"\n        },\n        {\n          \"name\": \"New York Times\"\n        },\n        {\n          \"name\": \"New Yorker\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n#### `Like` - notes\n\nEach `Like` filter iterates over the entire inverted index for that property. The search time will go up linearly with the dataset size, and may become slow for large datasets.\n\n\n### `ContainsAny` / `ContainsAll`\n\nThe `ContainsAny` and `ContainsAll` operators filter objects using values of an array as criteria.\n\nBoth operators expect an array of values and return objects that match based on the input values.\n\n- The `ContainsAny` and `ContainsAll` operators treat texts as an array. The text is split into an array of tokens based on the chosen tokenization scheme, and the search is performed on that array.\n- When using `ContainsAny` or `ContainsAll` with the REST api for batch deletion, the text array must be specified with the `valueTextArray` argument. This is different from the usage in search, where the `valueText` argument that can be used.\n\n\n#### `ContainsAny`\n\n`ContainsAny` returns objects where at least one of the values from the input array is present.\n\nConsider a dataset of `Person`, where each object represents a person with a `languages_spoken` property with a `text` datatype.\n\nA `ContainsAny` query on a path of `[\"languages_spoken\"]` with a value of `[\"Chinese\", \"French\", \"English\"]` will return objects where at least one of those languages is present in the `languages_spoken` array.\n\n#### `ContainsAll`\n\n`ContainsAll` returns objects where all the values from the input array are present.\n\nUsing the same dataset of `Person` objects as above, a `ContainsAll` query on a path of `[\"languages_spoken\"]` with a value of `[\"Chinese\", \"French\", \"English\"]` will return objects where all three of those languages are present in the `languages_spoken` array.\n\n## Filter performance\n\n\n\n\n## Special cases\n\n### By id\n\nYou can filter object by their unique id or uuid, where you give the `id` as `valueText`.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Backs on the rack - Vast sums are wasted on treatments for back pain that make it worse\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n### By timestamps\n\nFiltering can be performed with internal timestamps as well, such as `creationTimeUnix` and `lastUpdateTimeUnix`. These values can be represented either as Unix epoch milliseconds, or as RFC3339 formatted datetimes. Note that epoch milliseconds should be passed in as a `valueText`, and an RFC3339 datetime should be a `valueDate`.\n\nFiltering by timestamp requires the target class to be configured to index  timestamps. See here for details.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Army builds new body armor 14-times stronger in the face of enemy fire\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By property length\n\nFiltering can be performed with the length of properties.\n\nThe length of properties is calculated differently depending on the type:\n- array types: the number of entries in the array is used, where null (property not present) and empty arrays both have the length 0.\n- strings and texts: the number of characters (unicode characters such as \u4e16 count as one character).\n- numbers, booleans, geo-coordinates, phone-numbers and data-blobs are not supported.\n\n```graphql\n{\n  Get {\n    (\n      where: {\n        operator: ,\n        valueInt: ,\n        path: [\"len()\"]\n      }\n    )\n  }\n}\n```\nSupported operators are `(not) equal` and `greater/less than (equal)` and values need to be 0 or larger.\n\nNote that the `path` value is a string, where the property name is wrapped in `len()`. For example, to filter for objects based on the length of the `title` property, you would use `path: [\"len(title)\"]`.\n\nTo filter for `Article` class objects with `title` length greater than 10, you would use:\n\n```graphql\n{\n  Get {\n    Article(\n      where: {\n        operator: GreaterThan,\n        valueInt: 10,\n        path: [\"len(title)\"]\n      }\n    )\n  }\n}\n```\n\nFiltering by property length requires the target class to be configured to index the length.\n\n### By cross-references\n\nYou can also search for the value of the property of a cross-references, also called beacons.\n\nFor example, these filters select based on the class Article but who have `inPublication` set to New Yorker.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"inPublication\": [\n            {\n              \"name\": \"New Yorker\"\n            }\n          ],\n          \"title\": \"The Hidden Costs of Automated Thinking\"\n        },\n        {\n          \"inPublication\": [\n            {\n              \"name\": \"New Yorker\"\n            }\n          ],\n          \"title\": \"The Real Deal Behind the U.S.\\u2013Iran Prisoner Swap\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By count of reference\n\nAbove example shows how filter by reference can solve straightforward questions like \"Find all articles that are published by New Yorker\". But questions like \"Find all articles that are written by authors that wrote at least two articles\", cannot be answered by the above query structure. It is however possible to filter by reference count. To do so, simply provide one of the existing compare operators (`Equal`, `LessThan`, `LessThanEqual`, `GreaterThan`, `GreaterThanEqual`) and use it directly on the reference element. For example:\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Author\": [\n        {\n          \"name\": \"Agam Shah\",\n          \"writesFor\": [\n            {\n              \"name\": \"Wall Street Journal\"\n            },\n            {\n              \"name\": \"Wall Street Journal\"\n            }\n          ]\n        },\n        {\n          \"name\": \"Costas Paris\",\n          \"writesFor\": [\n            {\n              \"name\": \"Wall Street Journal\"\n            },\n            {\n              \"name\": \"Wall Street Journal\"\n            }\n          ]\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By geo coordinates\n\nA special case of the `Where` filter is with geoCoordinates. This filter is only supported by the `Get{}` function. If you've set the `geoCoordinates` property type, you can search in an area based on kilometers.\n\nFor example, this curious returns all in a radius of 2KM around a specific geo-location:\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Publication\": [\n        {\n          \"headquartersGeoLocation\": {\n            \"latitude\": 51.512737,\n            \"longitude\": -0.0962234\n          },\n          \"name\": \"Financial Times\"\n        },\n        {\n          \"headquartersGeoLocation\": {\n            \"latitude\": 51.512737,\n            \"longitude\": -0.0962234\n          },\n          \"name\": \"International New York Times\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\nNote that `geoCoordinates` uses a vector index under the hood.\n\n### By null state\n\nUsing the `IsNull` operator allows you to do filter for objects where given properties are `null` or `not null`. Note that zero-length arrays and empty strings are equivalent to a null value.\n\n```graphql\n{\n  Get {\n    (where: {\n        operator: IsNull,\n        valueBoolean: \n        path: []\n  }\n}\n```\n\nFiltering by null-state requires the target class to be configured to index this. See here for details.\n\n\n## Related pages\n\n- How-to search: Filters\n\n\n\n\n\n", "type": "Documentation", "name": "graphql-filters", "path": "developers/weaviate/api/graphql/filters.md", "link": "https://weaviate.io/developers/weaviate/api/graphql/filters", "timestamp": "2024-02-08 21:20:44", "reader": "JSON", "meta": {}, "chunks": []}