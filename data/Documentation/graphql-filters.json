{"text": "\n\n\n\n\n\n## Overview\n\nConditional filters can be added to queries on the class level. The operator used for filtering is also called a `where` filter.\n -->\n\n- How-to search: Filters\n\n## Single operand (condition)\n\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\n- The GraphQL property path,\n- The operator type, and\n- The valueType with the value.\n\nFor example, this filter will only allow objects from the class `Article` with a `wordCount` that is `GreaterThan` than `1000`.\n\n\n\n\n\n  Expected response\n\n```\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Anywhere but Washington: an eye-opening journey in a deeply divided nation\"\n        },\n        {\n          \"title\": \"The world is still struggling to implement meaningful climate policy\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n## Filter structure\n\nSupported by the `Get{}` and `Aggregate{}` functions.\n\nThe `where` filter is an algebraic object, which takes the following arguments:\n\n- `Operator` (which takes one of the following values)\n  - `And`\n  - `Or`\n  - `Equal`\n  - `NotEqual`\n  - `GreaterThan`\n  - `GreaterThanEqual`\n  - `LessThan`\n  - `LessThanEqual`\n  - `Like`\n  - `WithinGeoRange`\n  - `IsNull`\n  - `ContainsAny`  (*Only for array and text properties)\n  - `ContainsAll`  (*Only for array and text properties)\n- `Operands`: Is a list of `Operator` objects of this same structure, only used if the parent `Operator` is set to `And` or `Or`.\n- `Path`: Is a list of strings in XPath style, indicating the property name of the class.\n  If the property is a beacon (i.e., cross-reference), the path should be followed to the property of the beacon which should be specified as a list of strings. For a schema structure like:\n ```json\n {\n   \"inPublication\": {\n     \"Publication\": {\n       \"name\": \"Wired\"\n     }\n   }\n }\n ```\n  Here, the path selector for `name` will be `[\"inPublication\", \"Publication\", \"name\"]`.\n\n- `valueType`\n\n### Example filter structure\n\n```graphql\n{\n  Get {\n    (where: {\n        operator: ,\n        operands: [{\n          path: [path],\n          operator: \n          : \n        }, {\n          path: [],\n          operator: ,\n          : \n        }]\n      }) {\n       {\n        \n        ... on  {\n          \n        }\n      }\n    }\n  }\n}\n```\n\n### Available `valueType` values\n\n- `valueInt`: The integer value that the last property in the `Path` selector should be compared to.\n- `valueBoolean`: The boolean value that the last property in `Path` should be compared to.\n- `valueString`: The string value that the last property in `Path` should be compared to. (Note: `string` has been deprecated.)\n- `valueText`: The text value that the last property in `Path` should be compared to.\n- `valueNumber`: The number (float) value that the last property in `Path` should be compared to.\n- `valueDate`: The date (ISO 8601 timestamp, formatted as RFC3339) value that the last property  in `Path` should be compared to.\n\n### Filter behavior of multi-word queries in `Equal` operator\n\nThe behavior for the `Equal` operator on multi-word textual properties in `where` filters depends on the `tokenization` of the property.\n\nSee the Schema property tokenization section for the difference between the available tokenization types.\n\n### Stopwords in `text`/`string` filter values\n\nStarting with `v1.12.0` you can configure your own stopword lists for the inverted index.\n\n### Example response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Opinion | John Lennon Told Them \u2018Girls Don't Play Guitar.' He Was So Wrong.\"\n        }\n      ]\n    }\n  },\n  \"errors\": null\n}\n```\n\n## Multiple operands\n\nYou can set multiple operands by providing an array, and you can also nest conditions.\n\nFor example, these filters select based on the class Article with a wordCount higher than 1000 and who are published before January 1st 2020.\n\nYou can filter datetimes similarly to numbers, with the `valueDate` given as `string` in RFC3339 format.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"China\\u2019s long-distance lorry drivers are unsung heroes of its economy\"\n        },\n        {\n          \"title\": \"\\u2018It\\u2019s as if there\\u2019s no Covid\\u2019: Nepal defies pandemic amid a broken economy\"\n        },\n        {\n          \"title\": \"A tax hike threatens the health of Japan\\u2019s economy\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n## Filter operators\n\n### `Like`\n\nUsing the `Like` operator allows you to do string searches based on partial match. The capabilities of this operator are:\n\n- `?` -> exactly one unknown character\n  - `car?` matches `cart`, `care`, but not `car`\n- `*` -> zero, one or more unknown characters\n  - `car*` matches `car`, `care`, `carpet`, etc\n  - `*car*` matches `car`, `healthcare`, etc.\n\n\n\n\n#### `Like` - notes\n\nEach query using the `Like` operator iterates over the entire inverted index for that property. The search time will go up linearly with the dataset size. Be aware that there might be a point where this query is too expensive and will not work anymore. We will improve this implementation in a future release. You can leave feedback or feature requests in a GitHub issue.\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Publication\": [\n        {\n          \"name\": \"The New York Times Company\"\n        },\n        {\n          \"name\": \"International New York Times\"\n        },\n        {\n          \"name\": \"New York Times\"\n        },\n        {\n          \"name\": \"New Yorker\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n### `ContainsAny` / `ContainsAll`\n\nThe `ContainsAny` and `ContainsAll` operators filter objects using values of an array as criteria.\n\nBoth operators expect an array of values and return objects that match based on the input values.\n\nThe `ContainsAny` and `ContainsAll` operators treat texts as an array. The text is split into an array of tokens based on the chosen tokenization scheme, and the search is performed on that array.\n\n#### Use with batch delete\n\nWhen using `ContainsAny` or `ContainsAll` with the REST api for batch deletion, the text array must be specified with the `valueTextArray` argument. This is different from the GraphQL usage such as in search, where the `valueText` argument that can be used.\n\n#### `ContainsAny`\n\n`ContainsAny` returns objects where at least one of the values from the input array is present.\n\nConsider a dataset of `Person`, where each object represents a person with a `name` and a `languages_spoken` property.\n\nUsing `ContainsAny`, you can fetch all people who speak at least one of the provided languages.\n\n```graphql\n{\n  Get {\n    Person (\n      where: {\n        path: [\"languages_spoken\"],\n        operator: ContainsAny,\n        valueText: [\"Chinese\", \"French\", \"English\"]\n      }\n    )\n    {\n      languages_spoken\n      name\n    }\n  }\n}\n```\n\nThis query fetches individuals who speak **one or more of the specified languages**. That is, at least one of `Chinese`, `French`, or `English`.\n\n#### `ContainsAll`\n\n`ContainsAll` returns objects where all the values from the input array are present.\n\n```graphql\n{\n  Get {\n    Person (\n      where: {\n        path: [\"languages_spoken\"],\n        operator: ContainsAll,\n        valueText: [\"Chinese\", \"French\", \"English\"]\n      }\n    )\n    {\n      languages_spoken\n      name\n    }\n  }\n}\n```\n\nThis query fetches individuals who can speak **all three languages**: `Chinese`, `French`, and `English`.\n\n## Special cases\n\n### By id\n\nYou can filter object by their unique id or uuid, where you give the `id` as `valueText`.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Backs on the rack - Vast sums are wasted on treatments for back pain that make it worse\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n### By timestamps\n\nFiltering can be performed with internal timestamps as well, such as `creationTimeUnix` and `lastUpdateTimeUnix`. These values can be represented either as Unix epoch milliseconds, or as RFC3339 formatted datetimes. Note that epoch milliseconds should be passed in as a `valueText`, and an RFC3339 datetime should be a `valueDate`.\n\nFiltering by timestamp requires the target class to be configured to index  timestamps. See here for details.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"title\": \"Army builds new body armor 14-times stronger in the face of enemy fire\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By property length\n\nFiltering can be performed with the length of properties.\n\nThe length of properties is calculated differently depending on the type:\n- array types: the number of entries in the array is used, where null (property not present) and empty arrays both have the length 0.\n- strings and texts: the number of characters (unicode characters such as \u4e16 count as one character).\n- numbers, booleans, geo-coordinates, phone-numbers and data-blobs are not supported.\n\n```graphql\n{\n  Get {\n    (\n      where: {\n        operator: ,\n        valueInt: ,\n        path: [\"len()\"]\n      }\n    )\n  }\n}\n```\nSupported operators are `(not) equal` and `greater/less than (equal)` and values need to be 0 or larger.\n\nNote that the `path` value is a string, where the property name is wrapped in `len()`. For example, to filter for objects based on the length of the `title` property, you would use `path: [\"len(title)\"]`.\n\nTo filter for `Article` class objects with `title` length greater than 10, you would use:\n\n```graphql\n{\n  Get {\n    Article(\n      where: {\n        operator: GreaterThan,\n        valueInt: 10,\n        path: [\"len(title)\"]\n      }\n    )\n  }\n}\n```\n\nFiltering by property length requires the target class to be configured to index the length.\n\n### By cross-references\n\nYou can also search for the value of the property of a cross-references, also called beacons.\n\nFor example, these filters select based on the class Article but who have `inPublication` set to New Yorker.\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Article\": [\n        {\n          \"inPublication\": [\n            {\n              \"name\": \"New Yorker\"\n            }\n          ],\n          \"title\": \"The Hidden Costs of Automated Thinking\"\n        },\n        {\n          \"inPublication\": [\n            {\n              \"name\": \"New Yorker\"\n            }\n          ],\n          \"title\": \"The Real Deal Behind the U.S.\\u2013Iran Prisoner Swap\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By count of reference\n\nAbove example shows how filter by reference can solve straightforward questions like \"Find all articles that are published by New Yorker\". But questions like \"Find all articles that are written by authors that wrote at least two articles\", cannot be answered by the above query structure. It is however possible to filter by reference count. To do so, simply provide one of the existing compare operators (`Equal`, `LessThan`, `LessThanEqual`, `GreaterThan`, `GreaterThanEqual`) and use it directly on the reference element. For example:\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Author\": [\n        {\n          \"name\": \"Agam Shah\",\n          \"writesFor\": [\n            {\n              \"name\": \"Wall Street Journal\"\n            },\n            {\n              \"name\": \"Wall Street Journal\"\n            }\n          ]\n        },\n        {\n          \"name\": \"Costas Paris\",\n          \"writesFor\": [\n            {\n              \"name\": \"Wall Street Journal\"\n            },\n            {\n              \"name\": \"Wall Street Journal\"\n            }\n          ]\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n\n\n### By geo coordinates\n\nA special case of the `Where` filter is with geoCoordinates. This filter is only supported by the `Get{}` function. If you've set the `geoCoordinates` property type, you can search in an area based on kilometers.\n\nFor example, this curious returns all in a radius of 2KM around a specific geo-location:\n\n\n\n\n\n  Expected response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"Publication\": [\n        {\n          \"headquartersGeoLocation\": {\n            \"latitude\": 51.512737,\n            \"longitude\": -0.0962234\n          },\n          \"name\": \"Financial Times\"\n        },\n        {\n          \"headquartersGeoLocation\": {\n            \"latitude\": 51.512737,\n            \"longitude\": -0.0962234\n          },\n          \"name\": \"International New York Times\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n### By null state\n\nUsing the `IsNull` operator allows you to do filter for objects where given properties are `null` or `not null`. Note that zero-length arrays and empty strings are equivalent to a null value.\n\n```graphql\n{\n  Get {\n    (where: {\n        operator: IsNull,\n        valueBoolean: \n        path: []\n  }\n}\n```\n\nFiltering by null-state requires the target class to be configured to index this. See here for details.\n\n\n\n\n\n", "type": "Documentation", "name": "graphql-filters", "path": "developers/weaviate/api/graphql/filters.md", "link": "https://weaviate.io/developers/weaviate/api/graphql/filters", "timestamp": "2023-11-02 10:52:20", "reader": "JSON", "meta": {}, "chunks": []}