{"text": "\n# Contributor guidelines\n\nThere are currently four clients developed for Weaviate's APIs:\n* Python\n* Go\n* TypeScript/JavaScript\n* Java\n\nThese clients, and all future clients are and will be developed according to the following guidelines:\n\n1. Every client *must* reflect all features of the RESTful API one-to-one.\n2. Every client *must* reflect all functions of GraphQL API (1-1 where possible).\n3. Clients *can* have client-specific, extra or unique features:\n   1. These features on top of the 1-1 RESTful and GraphQL functionalities must be defined through a user story, which will also be reflected in the documentation.\n   2. These features can be solved in a client's native way (follow the current design of the client for consistency)\n   3. Preferably the functionalities are consistent across clients.\n4. Keep the design (nomenclature and builder structures) as consistent as possible, with the nomenclature of the RESTful and GraphQL API functions as base, then adopting names from similar functions in a client in another language.\n5. Clients must at the minimum contain journey-tests to be considered complete. See \"Testing\" below.\n\n# Design philosophy and API patterns\n\nAs a rule of thumb it is more important that a client feels native to\ndevelopers used to a specific language than it is to have all clients exactly\nidentical. When developers make their first contact with a Weaviate client,\nthey should think \"This feels like proper Java [Go/Python/JavaScript...]\", as\nopposed to \"I guess it was designed like this to be consistent with other\nlanguage clients\". Therefore you should design clients in a way that feels\nnative to those with experience in that language.\n\nThis can also mean that specific patterns deviate from one client to another.\nFor example, python has keyword arguments next to positional arguments. This\nmakes it easy to add optional arguments with defaults. Golang, on the other\nhand, has a fixed set of arguments per function call making it much better\nsuited for a builder pattern.\n\nCasing in object, property and method names should follow best-practicies for\nthe respective language.\n\n# Testing\n\nTest coverage is very important for clients to make it possible to easily test\nthe client against various Weaviate versions. As a client is an integration\npoint to Weaviate, the Test pyramid\nwill look upside down.\n\nContrary to Weaviate Core it is most important that [Journey\nTests](../weaviate-core/tests.md#journey-tests) are present, which verify all\nactual integration points with a real Weaviate instance. Feel free to add\nadditional Integration, Component or [Unit\nTests](../weaviate-core/tests.md#unit-tests) as they make sense, e.g. for\nedge cases or language-speficic sources of error. As a rule of thumb, a\ndynamically typed language will probably require more unit-level testing than a\nstatically typed one. Note, however, that we can only use Journey tests\ninvolving an actual Weaviate instance to verify if a client is 100% compatible\nwith Weaviate in general and a specific Weaviate version.\n\nFor inspiration of how to write great tests for your client, take a look at the\ntests of the JavaScript client\n(Example)\nor Go client\n(Example).\n\n# How to get started\n\nWe recommend that you first identify which existing client uses a language most\nsimilar to the one you've picked. For example, criteria could include:\n\n* Is the language dynamically or statically typed?\n* Is the language compiled or interpreted?\n* How are optional arguments typically handled?\n* How verbose are patterns in the language?\n\nThen you can take a look at an existing client which matches your language the\nclosest and get inspried.\n\nFor example, if you plan to implement a client in C#, it might make sense to look at the\nJava and\nGo clients.\n\nThen we recommend to start porting one of the existing test suites and start\nimplementing the client methods until all tests are passed. If you use the same\ntests as the existing clients (running against an actual Weaviate instance in\ndocker-compose) you will have the guarantee that your new client is working\ncorrectly.\n\nEventually, as you have ported all tests and implemented all features to make\nthem pass, you have the guarantee that your client is feature-complete and\nwon't break on future updates.\n", "type": "Documentation", "name": "contributor-guide-weaviate-clients", "path": "developers/contributor-guide/weaviate-clients/index.md", "link": "https://weaviate.io/developers/contributor-guide/weaviate-clients", "timestamp": "2023-11-13 10:39:45", "reader": "JSON", "meta": {}, "chunks": []}