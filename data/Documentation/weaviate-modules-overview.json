{"text": "\n## Weaviate Module System\n\nThe Module system in Weaviate is a way to extend Weaviate's functionality.\nModules often provide access to various machine-learning models which can be\nused to turn media into vectors at query and import time. However, that's not\nthe only thing a module can do; any extension on functionality can be\nincorporated into a module.\n\nThe user decides which modules are activated at startup through configuration.\nSome modules can be combined with each other, others might be conflicting. In\nthis case startup will fail.\n\n## High level architecture\n\nA module is essentially code which compiles with Weaviate, but a module can\nalso communicate with other services. We are going through the\n`text2vec-transformers` module as an example.\n\nFrom a high level, the motivation for a user to enable this module would be to\nhave their imported data vectorized with a transformer module (e.g. BERT,\netc.). Additionally, at query time, the query string should also be vectorized\nin the same way.\n\nFrom a tech level this module therefore has to provide some capabilities. See\nArchitecture for details of what capabilities are and\nhow a module can provide such a capability. The capabilities we need are:\n\n- **Vectorizer** The module must be able to turn the text of an object to a\n  vector at import time.\n\n- **GraphQLArguments** The module must provide text-specific graphQL-Searcher\n  arguments, such as `nearText`. Additionally the module needs to hook into the\n  query process and turn user-specified text into a search-vector which\n  Weaviate can use for the nearest-neighbor search.\n\n### What happens when the Vectorizer gets called?\n\nWeaviate is written in Go and so is the module. But what happens if our model\nonly has Python bindings? The module can decide to make RPC calls (REST, gRPC,\netc.) to other services. In the case of the `text2vec-transformers` module, the\nmodule also provides a python container which wraps the respective model with\na simple REST API, which it can then call from within the module.\n\nThis split into several containers (often referred to as a microservice\npattern) is not just to abstract programming languages away. We obtain several\nother benefits from running the container as a separate service. Most notably:\n\n- **Hardware requirements**\n  Neural-network-based models, such as BERT & friends, typically require GPUs\n  to run efficiently. Weaviate however is very fast on cheap CPU-based\n  machines. Thus instead of requiring expensive GPU-machines for the entire\n  setup, we can use GPU-machines only for the model interference part. On\n  Kubernetes this could be achieved through node affinity, for example. Thus,\n  even if running on the same cluster, you can schedule your Weaviate pods on\n  CPU-only nodes and have the inference pods run on GPU-enabled nodes.\n\n- **Independent scalability**\n  This separation of concerns allows to scale each concern depending on load.\n  For example, if you have a read-heavy workload, Weaviate Core might be the\n  bottleneck. If you have a write-heavy workload with very long objects, model\n  inference might be the bottleneck. By having these concerns separated, you\n  can individually scale based on your needs.\n\n- **Exchangability**\n  Most transformer models have the same API and usage principles. They only\n  differ in use case and training data. By having the model inference run in a\n  separate container, you can quickly exchange models. E.g. from BERT to\n  DistilRoBERTa - only by exchanging Docker containers.\n\n## Module characteristics\n\nA module is a custom code that can extend Weaviate by hooking into specific lifecycle hooks. As Weaviate is written in Go, so module code must also be written in Go. However, some existing modules make use of independent services which can be written in any language, as is often the case with vectorizer modules which bring along model inference containers often written in Python.\n\nModules can be \"vectorizers\" (defines how the numbers in the vectors are chosen from the data) or other modules providing additional functions like question answering, custom classification, etc. Modules have the following characteristics:\n- Naming convention:\n  - Vectorizer: `2vec--`, for example `text2vec-contextionary`, `image2vec-RESNET` or `text2vec-transformers`.\n  - Other modules: `--`.\n  - A module name must be url-safe, meaning it must not contain any characters which would require url-encoding.\n  - A module name is not case-sensitive. `text2vec-bert` would be the same module as `text2vec-BERT`.\n- Module information is accessible through the `v1/modules//` RESTful endpoint.\n- General module information (which modules are attached, version, etc.) is accessible through Weaviate's `v1/meta` endpoint.\n- Modules can add `additional` properties in the RESTful API and `_additional` properties in the GraphQL API.\n- A module can add filters in GraphQL queries.\n- Which vectorizer and other modules are applied to which data classes is configured in the schema.\n", "type": "Documentation", "name": "weaviate-modules-overview", "path": "developers/contributor-guide/weaviate-modules/overview.md", "link": "https://weaviate.io/developers/contributor-guide/weaviate-modules/overview", "timestamp": "2024-02-08 21:20:26", "reader": "JSON", "meta": {}, "chunks": []}