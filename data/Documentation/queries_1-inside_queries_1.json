{"text": "\n## &nbsp;&nbsp;Overview\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nIn this unit, we have looked at various ways to construct a vector search.\n\nWe started by learning how to use `Get` and `Aggregate` vector search functions, adding search operators such as `nearVector`, `nearObject` and `nearText`, before wrapping up with various filters such as `where`, `limit` and `offset`.\n\nNow let's stop to take a look at how these searches are actually performed, starting with the vector search process.\n## &nbsp;&nbsp;The vector search process\n\n### &nbsp;&nbsp;Vector search, behind the scenes\n\nAs the name suggests, vector search relies on vectors to perform its operations. When you perform a vector search in Weaviate, regardless of whether `nearVector`, `nearObject` or `nearText` is used, the input is converted to a vector.\n\nThe input vector is then compared to the stored vectors in Weaviate to return the most relevant objects.\n\nFor queries using the `nearVector` operator, Weaviate simply takes the provided vector and performs the vector search.\n\nFor queries such as `nearObject` and `nearText` where the vector is not directly provided, Weaviate obtains the vector using a suitable method.\n\n#### `nearObject`\n\nIf the `nearObject` operator is used, Weaviate retrieves the associated vector for the object, which becomes the input vector.\n\nLet's confirm this by performing a vector search using the `nearObject` operator, and replicating it with an equivalent `nearVector` operator.\n\nHere is the `nearObject` query:\n\n\n\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"JeopardyQuestion\": [\n        {\n          \"_additional\": {\n            \"distance\": 3.5762787e-07,\n            \"id\": \"d53fd7ea-35c1-5f8d-a35a-e53511db1a2a\"\n          },\n          \"answer\": \"meerkats\",\n          \"question\": \"Group of mammals seen here:  [like Timon in The Lion King]\"\n        },\n        {\n          \"_additional\": {\n            \"distance\": 0.12663543,\n            \"id\": \"9eaf38fe-e7f0-5da3-b703-6b44c49faf7d\"\n          },\n          \"answer\": \"hyena\",\n          \"question\": \"It's the amused African mammal heard here\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\nNow, try running this `nearVector` query and compare the results:\n\n\n\n\n\n  See the full `meerkat_vector`\n\n\n\n\n\n\n\n   Explain this query\n\nIf you run the second (`nearVector`) query, you will see that it returns the same results as the `nearObject` query. The distances are also identical. This is because the vector of object in the `nearObject` query is identical to the vector you specify in the `nearVector` query.\n\n\n\n#### `nearText`\n\nIf the `nearText` operator is used, Weaviate converts the input text to a vector to use as the input. The specific method would depend on the `vectorizer` applicable to the relevant class. Depending on the setting, Weaviate may use the `text2vec-openai` module or the `text2vec-transformers` module to do this.\n\nWe will cover how to set the vectoriser in the next section.\n\n\n\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"JeopardyQuestion\": [\n        {\n          \"_additional\": {\n            \"distance\": 0.1800943,\n            \"id\": \"92710bd6-de3c-5220-a60a-d386b2748e28\"\n          },\n          \"answer\": \"Two Guys and a Girl\",\n          \"question\": \"In 1999 an ABC sitcom dropped \\\"a Pizza Place\\\" from its name, which changed to this\"\n        },\n        {\n          \"_additional\": {\n            \"distance\": 0.18657643,\n            \"id\": \"7e7a6572-02bd-529f-8943-38ccd4a2a90b\"\n          },\n          \"answer\": \"Beavis & Butthead of the Class\",\n          \"question\": \"2 MTV cartoon teens join Howard Heh-Heh-Hesseman's honors program on '80's TV\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\nNow, try running this `nearVector` query and compare the results:\n\n\n\n\n\n  See the full `popular_90s_comedy_vector`\n\n\n\n\n\n\n\n   Explain this query\n\nWhen you run the second (`nearVector`) query, once again the query returns the same objects as the `nearText` query as well as distances.\n\nIn this case, Weaviate vectorizes the input text using the `text2vec-openai` module, which relies on the OpenAI inference API to convert the input to a vector. The vectorization process is deterministic, meaning that the same input text will always result in the same vector. For the `nearVector` query, we generated the vector directly using the OpenAI API and used it as the input vector, leading to the same results.\n\n\n\n### &nbsp;&nbsp;Filtering\n\nFilters can be applied during the vector search process to further refine the results.\n\nUnder the hood, Weaviate implements \"pre-filtering\". This means that Weaviate applies the filter on the entire database to end up with an \"allow list\", from which vector search results are returned.\n\nThis, combined with efficient filtering methods, allows Weaviate to easily return the right number of results even under challenging conditions, such as when restrictive filters are applied to a large database.\n\n### &nbsp;&nbsp;Conceptual diagram (filtering + vector search)\n\nThe conceptual diagram below shows how the vector search process works. When an input is provided containing filters and search operators, Weaviate first performs a pre-filtering step to obtain an \"allow list\" of objects.\n\nThe input is used to determine an input vector, which may involve an additional step, such as retrieving the object's vector with `nearObject` or vectorizing the input text with `nearText`. The input vector is then compared to perform a vector search, returning the most relevant objects from the allow list.\n\n\n\n\n## &nbsp;&nbsp;Review\n\n### &nbsp;&nbsp;Review exercise\n\n- Replicate a `nearObject` query with a `nearVector` query.\n- Replicate a `nearText` query with a `nearVector` query.\n\n### &nbsp;&nbsp;Key takeaways\n\n- nearObject operator retrieves the associated vector for an object, while nearText converts input text to a vector based on a specified vectorizer.\n- You have seen how to create equivalent `nearVector` queries to `nearObject` or `nearText` queries.\n- Weaviate uses \"pre-filtering\", meaning that filters are applied on the entire database prior to performing vector search.\n\nimport Quiz from '/src/components/Academy/quiz.js'\nconst varName = [{\n  questionText: 'questionText',\n  answerOptions: [\n    {\n      answerText: 'answerOne',\n      isCorrect: false,\n      feedback: 'feedbackOne',\n    },\n    {\n      answerText: 'answerTwo',\n      isCorrect: false,\n      feedback: 'feedbackTwo',\n    },\n    {\n      answerText: 'answerThree',\n      isCorrect: false,\n      feedback: 'feedbackThree',\n    },\n  ]\n}];\n\n\n\n", "type": "Documentation", "name": "queries_1-inside_queries_1", "path": "developers/academy/zero_to_mvp/102_queries_1/80_inside_queries_1.mdx", "link": "https://weaviate.io/developers/academy/zero_to_mvp/queries_1/inside_queries_1", "timestamp": "2024-02-08 20:21:17", "reader": "JSON", "meta": {}, "chunks": []}