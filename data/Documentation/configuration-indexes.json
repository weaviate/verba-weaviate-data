{"text": "\n\n\n## Vector indexes\n\nWeaviate uses a vector index to facilitate efficient, vector-first data storage and retrieval. A vector index is a data structure that stores vectors and supports fast similarity searches.\n\nWeaviate supports the Hierarchical Navigable Small Worlds (HNSW) indexing algorithm.\n\nIf you want to contribute to developing a new index type at Weaviate, please contact us or make a pull request in our GitHub project. Stay tuned for updates!\n\n### Index configuration parameters\n\nThese parameters configure Weaviate indexing across index types. The `vectorIndexConfig` parameter provides a way to configure specific details for different types of index. Currently the only index type available is HNSW.\n\n| Parameter | Type | Default | Details |\n| :-- | :-- | :-- | :-- |\n| `vectorIndexType` | string | `hnsw` | Optional. The algorithm that creates your index. HNSW is the only index type currently available. |\n| `vectorIndexConfig` | object | - | Optional. Set parameters that are specific to the vector index type. See HSNW specific parameters |\n\n\n## HNSW vector indexes\nHNSW indexes are scalable and super fast at query time, but HNSW algorithms are costly when you add data during the index building process. \n\nFor an alternative approach to building indexes that may help with some use cases, see Asynchronous indexing.\n\n### HNSW index parameters\n\nHNSW indexes use a combination of techniques to improve search speed. At build time, the HNSW algorithm creates a series of layers. At query time, the HNSW algorithm uses the layers to build a list of approximate nearest neighbors (ANN) quickly and efficiently. This two-phase approach means you can update some HNSW parameters at run time, but others cannot be modified after you create your collection. \n\nThe `ef` parameter controls the size of the nearest neighbors list and helps to balance search speed and recall. You can set an explicit `ef` value or let Weaviate set a dynamic `ef`. These parameters let you tune `ef`, dynamic `ef`, and other aspects of the HNSW algorithm.\n\n| Parameter | Type | Default | Changeable | Details |\n| :-- | :-- | :-- | :-- | :-- |\n| `cleanupIntervalSeconds` | integer | 300 | Yes | Cleanup frequency. This value does not normally need to be adjusted. A higher value means cleanup runs less frequently, but it does more in a single batch. A lower value means cleanup is more frequent, but it may be less efficient on each run. |\n| `distance` | string | `cosine` | No | Distance metric. The metric that measures the distance between two arbitrary vectors. For available distance metrics, see supported distance metrics. |\n| `ef` | integer | -1 | Yes |  Balance search speed and recall. `ef` is the size of the dynamic list that the HNSW uses during search. Search is more accurate when `ef` is higher, but it is also slower. `ef` values greater than 512 show diminishing improvements in recall.Dynamic `ef`. Weaviate automatically adjusts the `ef` value and creates a dynamic `ef` list when `ef` is set to -1. For more details, see dynamic ef. |\n| `efConstruction` | integer | 128 | No | Balance index search speed and build speed. A high `efConstruction` value means you can lower your `ef` settings, but importing is slower.`efConstruction` must be greater than 0. |\n| `maxConnections` | integer | 64 | No | Maximum number of connections per element. `maxConnections` is the connection limit per layer for layers above the zero layer. The zero layer can have (2 * maxConnections) connections.  `maxConnections` must be greater than 0. |\n| `dynamicEfMin` | integer | 100 | Yes | *New in `v1.10.0`.*  Lower bound for dynamic `ef`. Protects against a creating search list that is too short.This setting is only used when `ef` is -1. |\n| `dynamicEfMax` | integer | 500 | Yes | *New in `v1.10.0`.*  Upper bound for dynamic `ef`. Protects against creating a search list that is too long. If `dynamicEfMax` is higher than the limit, `dynamicEfMax` does not have any effect. In this case, `ef` is the limit.This setting is only used when `ef` is -1. |\n| `dynamicEfFactor` | integer | 8 | Yes | *New in `v1.10.0`.*  Multiplier for dynamic `ef`. Sets the potential length of the search list. This setting is only used when `ef` is -1. |\n| `flatSearchCutoff` | integer | 40000 | Yes | Optional. Threshold for the flat-search cutoff. To force a vector index search, set `\"flatSearchCutoff\": 0`. |\n| `skip` | boolean | `false` | No | When true, do not index the collection.  Weaviate decouples vector creation and vector storage. If you skip vector indexing, but a vectorizer is configured (or a vector is provided manually), Weaviate logs a warning each import.  To skip indexing and vector generation, set `\"vectorizer\": \"none\"` when you set `\"skip\": true`.  See When to skip indexing. |\n| `vectorCacheMaxObjects`| integer | `1e12` | Yes | Maximum number of objects in the memory cache. By default, this limit is set to one trillion (`1e12`) objects when a new collection is created. For sizing recommendations, see Vector cache considerations. |\n| `pq` |document| -- | Yes | Enable and configure product quantization (PQ) compression.  PQ assumes some data has already been loaded. You should have 10,000 to 100,000 vectors per shard loaded before you enable PQ.  For PQ configuration details, see PQ configuration parameters. |\n\n### PQ configuration parameters\n\nProduct quantization (PQ) is a form of data compression that reduces the memory footprint of the index. HNSW is an in-memory index, so enabling PQ lets you work with larger datasets. For a discussion of how PQ saves memory, see this blog post.\n\nPQ relies on a codebook to compress the original vectors. The codebook defines 'centroids' that are used to calculate the compressed vector. Weaviate\u2019s PQ implementation uses existing data to train the codebook. You must have some vectors loaded before you enable PQ so Weaviate can use them to define the centroids. You should have 10,000 to 100,000 vectors loaded per shard before you enable PQ.\n\nThese parameters let you fine tune `pq`.\n \n| Parameter | Type | Default | Details |\n| :-- | :-- | :-- | :-- |\n| `enabled` | boolean | `false` |  Enable PQ. Weaviate use product quantization (PQ) compression when `true`. |\n| `trainingLimit` | integer | 100000 |  Object limit. The maximum number of objects, per shard, used to fit the centroids. Larger values increase the time it takes to fit the centroids. |\n| `segments` | integer | -- |T he number of segments to use. By default `segments` is equal to the number of vector dimensions. Reducing the number of segments reduces the size of the quantized (PQ compressed) vectors.  The number of segments must be divisible by the number of dimensions in each vector. |\n| `centroids` | integer | 256 | The number of centroids to use. Reducing the number of centroids reduces the size of the quantized (PQ compressed) vectors at the price of recall.  If you use the `kmeans` encoder, `centroids` is set to 256 (one byte) by default. |\n| `encoder` | string | `kmeans` | Encoder specification. There are two encoders. You can specify the `type` of encoder as either `kmeans`(default) or `tile`. | \n|`distribution`|string|`log-normal`| Encoder distribution type. Only used with the `tile` encoder. If you use the `tile` encoder, you can specify the `distribution` as `log-normal` (default) or `normal`. |\n\n### Collection configuration example \n\nThis is a sample of collection that shows the data schema:\n  \n\n```json\n{\n  \"class\": \"Article\",\n  \"description\": \"string\",\n  \"properties\": [\n    {\n      \"name\": \"title\",\n      \"description\": \"string\",\n      \"dataType\": [\"text\"]\n    }\n  ],\n  \"vectorIndexType\": \"hnsw\",\n  \"vectorIndexConfig\": {\n    \"skip\": false,\n    \"ef\": 100,\n    \"efConstruction\": 128,\n    \"maxConnections\": 64,\n  }\n}\n```\n\n### Dynamic ef\n\nThe `ef` parameter controls the size of the approximate nearest neighbors (ANN) list at query time. You can configure a specific list size or else let Weaviate configure the list dynamically. If you choose dynamic `ef`, Weaviate provides several options to control the size of the ANN list.\n\nThe length of the list is determined by the query response limit that you set in your query. Weaviate uses the query limit as an anchor and modifies the size of ANN list according to the values you set for the `dynamicEf` parameters.\n\n- `dynamicEfMin` sets a lower bound on the list length.\n- `dynamicEfMax` sets an upper bound on the list length.\n- `dynamicEfFactor` sets a range for the list.\n\nTo keep search recall high, the actual dynamic `ef` value stays above `dynamicEfMin` even if the query limit is small enough to suggest a lower value.\n\nTo keep search speed reasonable even when retrieving large result sets, the dynamic `ef` value is limited to `dynamicEfMax`. Weaviate doesn't exceed `dynamicEfMax` even if the query limit is large enough to suggest a higher value. If the query limit is higher than `dynamicEfMax`, `dynamicEfMax` does not have any effect. In this case, dynamic `ef` value is equal to the query limit.\n\nTo determine the length of the ANN list, Weaviate multiples the query limit by `dynamicEfFactor`. The list range is modified by `dynamicEfMin` and `dynamicEfMax`.\n\nConsider this GraphQL query that sets a limit of 4.\n\n```graphql\n{\n  Get {\n    JeopardyQuestion(limit: 4) {\n      answer\n      question\n    }\n  }\n}\n```\n\nImagine the collection has dynamic `ef` configured.\n\n```json\n  \"vectorIndexConfig\": {\n     \"ef\": -1,\n     \"dynamicEfMin\": 5\n     \"dynamicEfMax\": 25\n     \"dynamicEfFactor\": 10\n  }\n```\n\nThe resulting search list has these characteristics.\n\n- A potential length of 40 objects ( (\"dynamicEfFactor\": 10) * (limit: 4) ).\n- A minimum length of 5 objects (\"dynamicEfMin\": 5).\n- A maximum length of 25 objects (\"dynamicEfMax\": 25).\n- An actual size of 5 to 25 objects.\n\nIf you use the `docker-compose.yml` file from Weavaite to run your local instance, the `QUERY_DEFAULTS_LIMIT` environment variable sets a reasonable default query limit. To prevent out of memory errors,`QUERY_DEFAULTS_LIMIT` is significantly lower than `QUERY_MAXIMUM_RESULTS`.\n\nTo change the default limit, edit the value for `QUERY_DEFAULTS_LIMIT` when you configure your Weaviate instance.\n\n### Configuration tips\n\nTo determine reasonable settings for your use case, consider the following questions and compare your answers in the table below:\n\n1. How many queries do you expect per second?\n1. Do you expect a lot of imports or updates?\n1. How high should the recall be?\n\n| Number of queries | Many imports or updates | Recall level | Configuration suggestions |\n| --- | --- | --- | --- |\n| not many | no | low | This is the ideal scenario. Keep both the `ef` and `efConstruction` settings low. You don't need a big machine and you will still be happy with the results. |\n| not many | no | high | Here the tricky thing is that your recall needs to be high. Since you're not expecting a lot of requests or imports, you can increase both the `ef` and `efConstruction` settings. Keep increasing them until you are happy with the recall. In this case, you can get pretty close to 100%. |\n| not many | yes | low | Here the tricky thing is the high volume of imports and updates. Be sure to keep `efConstruction` low. Since you don't need a high recall, and you're not expecting a lot of queries, you can adjust the `ef` setting until you've reached the desired recall. |\n| not many | yes | high | The trade-offs are getting harder. You need high recall _and_ you're dealing with a lot of imports or updates. This means you need to keep the `efConstruction` setting low, but you can significantly increase your `ef` setting because your queries per second rate is low. |\n| many | no | low | Many queries per second means you need a low `ef` setting. Luckily you don't need high recall so you can significantly increase the `efConstruction` value. |\n| many | no | high | Many queries per second means a low `ef` setting. Since you need a high recall but you are not expecting a lot of imports or updates, you can increase your `efConstruction` until you've reached the desired recall. |\n| many | yes | low | Many queries per second means you need a low `ef` setting. A high number of imports and updates also means you need a low `efConstruction` setting. Luckily your recall does not have to be as close to 100% as possible. You can set `efConstruction` relatively low to support your input or update throughput, and you can use the `ef` setting to regulate the query per second speed. |\n| many | yes | high | Aha, this means you're a perfectionist _or_ you have a use case that needs the best of all three worlds. Increase your `efConstruction` value until you hit the time limit of imports and updates. Next, increase your `ef` setting until you reach your desired balance of queries per second versus recall.  While many people think they need maximize all three dimensions, in practice that's usually not the case. We leave it up to you to decide, and you can always ask for help in our forum. |\n\nThis set of values is a good starting point for many use cases.\n\n|Parameter|Value|\n|:--|:--|\n|`ef`|`64`|\n|`efConstruction`|`128`|\n|`maxConnections`|`32`|\n\n## Vector index types \n\nThe `vectorIndexType` parameter only specifies how the vectors of data objects are *indexed*. The index is used for data retrieval and similarity search. \n\nThe `vectorizer` parameter determines how the data vectors are created (which numbers the vectors contain). `vectorizer` specifies a module, such as `text2vec-contextionary`, that Weaviate uses to create the vectors. (You can also set to `vectorizer` to `none` if you want to import your own vectors).\n\nTo learn more about configuring the data schema, see How to configure a schema.\n\n## Vector cache considerations\nFor optimal search and import performance, previously imported vectors need to be in memory. A disk lookup for a vector is orders of magnitudes slower than memory lookup, so the disk cache should be used sparingly. However, Weaviate can limit the number of vectors in memory. By default, this limit is set to one trillion (`1e12`) objects when a new collection is created.\n\nDuring import set `vectorCacheMaxObjects` high enough that all vectors can be held in memory. Each import requires multiple searches. Import performance drops drastically when there isn't enough memory to hold all of the vectors in the cache.\n\nAfter import, when your workload is mostly querying, experiment with vector cache limits that are less than your total dataset size.\n\nVectors that aren't currently in cache are added to the cache if there is still room. If the cache fills, Weaviate drops the whole cache. All future vectors have to be read from disk for the first time. Then, subsequent queries run against the cache until it fills again and the procedure repeats. Note that the cache can be a very valuable tool if you have a large dataset, and a large percentage of users only query a specific subset of vectors. In this case you might be able to serve the largest user group from cache while requiring disk lookups for \"irregular\" queries.\n\n## Deletions\n\nCleanup is an async process runs that rebuilds the HNSW graph after deletes and updates. Prior to cleanup, objects are marked as deleted, but they are still connected to the HNSW graph. During cleanup, the edges are reassigned and the objects are deleted for good.\n\n## When to skip indexing\n\nThere are situations where it doesn't make sense to vectorize a collection. For example, if the collection consists solely of references between two other collections, or if the collection contains mostly duplicate elements.\n\nImporting duplicate vectors into HNSW is very expensive. The import algorithm checks early on if a candidate vector's distance is greater than the worst candidate's distance. When there are lots of duplicate vectors, this early exit condition is never met so each import or query results in an exhaustive search.\n\nTo avoid indexing a collection, set `\"skip\"` to `\"true\"`. By default, collections are indexed.\n\n## Asynchronous indexing (experimental)\n\nAvailable starting in `v1.22`. This is an experimental feature. Please use with caution.\n\nStarting in Weaviate `1.22`, you can use asynchronous indexing by opting in.\n\nAsynchronous indexing decouples object creation from vector index updates. Objects are created faster, and the vector index updates in the background. Asynchronous indexing is especially useful for importing large amounts of data.\n\nAsynchronous indexing is off by default. To enable asynchronous indexing, set the `ASYNC_INDEXING` environment variable to `true` in your Weaviate configuration (the `docker-compose.yml` file if you use Docker Compose). This setting enables asynchronous indexing for all collections.\n\n\n  Example Docker Compose configuration\n\n```yaml\n---\nversion: '3.4'\nservices:\n  weaviate:\n    command:\n    - --host\n    - 0.0.0.0\n    - --port\n    - '8080'\n    - --scheme\n    - http\n    image: semitechnologies/weaviate:||site.weaviate_version||\n    restart: on-failure:0\n    ports:\n     - \"8080:8080\"\n     - \"50051:50051\"\n    environment:\n      QUERY_DEFAULTS_LIMIT: 25\n      QUERY_MAXIMUM_RESULTS: 10000\n      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'\n      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'\n      DEFAULT_VECTORIZER_MODULE: 'text2vec-openai'\n      ENABLE_MODULES: 'text2vec-cohere,text2vec-huggingface,text2vec-openai,text2vec-palm,generative-cohere,generative-openai,generative-palm'\n      CLUSTER_HOSTNAME: 'node1'\n      AUTOSCHEMA_ENABLED: 'false'\n      ASYNC_INDEXING: 'true'\n...\n```\n\n\n\nWhile the vector index is updating, Weaviate can search a maximum of 100,000 un-indexed objects by brute force, that is, without using the vector index. This means that the search performance is slower until the vector index has been fully updated. Also, any additional new objects beyond the first 100,000 in the queue are not include in the search.\n\nTo get the index status, call the node status endpoint. The `nodes/shards/vectorQueueLength` field shows the number of objects that still have to be indexed.\n\n\n\n\nThen, you can check the status of the vector index queue by inspecting the output. The `vectorQueueLength` field will show the number of remaining objects to be indexed. In the example below, the vector index queue has 425 objects remaining to be indexed on the `TestArticle` shard, out of a total of 1000 objects.\n\n```json\n{\n  \"nodes\": [\n    {\n      \"batchStats\": {\n        \"ratePerSecond\": 0\n      },\n      \"gitHash\": \"e6b37ce\",\n      \"name\": \"weaviate-0\",\n      \"shards\": [\n        {\n          \"class\": \"TestArticle\",\n          \"name\": \"nq1Bg9Q5lxxP\",\n          \"objectCount\": 1000,\n          // highlight-start\n          \"vectorIndexingStatus\": \"INDEXING\",\n          \"vectorQueueLength\": 425\n          // highlight-end\n        },\n      ],\n      \"stats\": {\n        \"objectCount\": 1000,\n        \"shardCount\": 1\n      },\n      \"status\": \"HEALTHY\",\n      \"version\": \"1.22.1\"\n    },\n  ]\n}\n```\n\n## Inverted index\n\n### Configure the inverted index\n\nThere are two indexes for filtering or searching the data, where the first (filterable) is for building a fast, Roaring Bitmaps index, and the second (searchable) index is for a BM25 or hybrid search.\n\nThe `indexFilterable` and `indexSearchable` keys can be set to `true` (on) or `false` (off) on a property level. Both are _on_ by default.\n\nThe filterable index is only capable of filtering, while the searchable index can be used for both searching and filtering (though not as fast as the filterable index).\n\nSo, setting `\"indexFilterable\": false` and `\"indexSearchable\": true` (or not setting it at all) will have the trade-off of worse filtering performance but faster imports (due to only needing to update one index) and lower disk usage.\n\nYou can set these keys in the schema like shown below, at a property level:\n\n```json\n{\n    \"class\": \"Author\",\n    \"properties\": [ // \n", "type": "Documentation", "name": "configuration-indexes", "path": "developers/weaviate/configuration/indexes.md", "link": "https://weaviate.io/developers/weaviate/configuration/indexes", "timestamp": "2023-11-13 10:40:40", "reader": "JSON", "meta": {}, "chunks": []}