{"text": "\n**Kubernetes** is an open-source *container orchestration* platform. It means that you can use Kubernetes to deploy, scale, and manage [containerized](https://www.docker.com/resources/what-container/) applications.\n\nIn production, Kubernetes is used to manage a cluster of nodes, such as those located on cloud providers like AWS, Google Cloud, or Azure, or on your own on-premises infrastructure.\n\nHere, you learn how to do this using **Minikube**, a handy tool that allows you to run a Kubernetes cluster on your local machine for development and testing purposes.\n\nIf you are looking to deploy Weaviate on a production Kubernetes cluster, the steps are similar. You will just need to replace Minikube with your production Kubernetes cluster.\n\nAs there are many variations in Kubernetes deployments, we recommend you follow the deployment instructions provided by your cloud provider or Kubernetes distribution for this purpose.\n\n##  Prerequisites\n\nFor this tutorial, you will need the following tools:\n\n- **Minikube**: a tool that runs a Kubernetes cluster on your local machine. It is used to test Kubernetes deployments locally.\n- **kubectl**: the Kubernetes command-line tool. It is used to interact with the Kubernetes cluster.\n- **Docker**: a platform that allows you to develop, ship, and run applications in containers. We install Docker as the Minikube [*driver*](https://minikube.sigs.k8s.io/docs/drivers/) to virtualize the Kubernetes cluster on your local machine. Your Minikube may use a different driver, but Docker is the most common one.\n- **Helm**: a package manager for Kubernetes. It is used to install and manage applications on Kubernetes.\n\n###  Installation\n\nIf you don't have any of these tools installed, you can follow the installation instructions for each, by following the links below:\n\n- [Minikube](https://minikube.sigs.k8s.io/docs/start/)\n- [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)\n- [Docker](https://docs.docker.com/get-docker/)\n- [helm](https://helm.sh/docs/intro/install/)\n\nOnce you've done so, confirm installation by running the following commands:\n\n```bash\nminikube version\nkubectl version --client\ndocker --version\nhelm version\n```\n\nYou should see an output like:\n\n```bash\nminikube version: v1.32.0\ncommit: 8220a6eb95f0a4d75f7f2d7b14cef975f050512d\nClient Version: v1.28.2\nKustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3\nDocker version 24.0.7, build afdd53b\nversion.BuildInfo{Version:\"v3.12.2\", GitCommit:\"1e210a2c8cc5117d1055bfaa5d40f51bbc2e345e\", GitTreeState:\"clean\", GoVersion:\"go1.20.6\"}\n```\n\nIf you see similar output, you are ready to proceed.\n\nNote that the versions may differ from the ones shown above. Please make sure you have the latest versions installed.\n\n##  Run Minikube\n\nYou are now ready to start Minikube. Run the following command:\n\n```bash\nminikube start\n```\n\nThen, you might see an output like this:\n\n```bash\n\ud83d\ude04  minikube v1.32.0 on Darwin 14.4.1 (arm64)\n\u2728  Automatically selected the docker driver. Other choices: vmware, ssh\n\ud83d\udccc  Using Docker Desktop driver with root privileges\n\ud83d\udc4d  Starting control plane node minikube in cluster minikube\n\ud83d\ude9c  Pulling base image ...\n\ud83d\udcbe  Downloading Kubernetes v1.28.3 preload ...\n    > preloaded-images-k8s-v18-v1...:  341.16 MiB / 341.16 MiB  100.00% 42.00 M\n    > gcr.io/k8s-minikube/kicbase...:  410.56 MiB / 410.58 MiB  100.00% 42.28 M\n\ud83d\udd25  Creating docker container (CPUs=2, Memory=8100MB) ...\n\ud83d\udc33  Preparing Kubernetes v1.28.3 on Docker 24.0.7 ...\n    \u25aa Generating certificates and keys ...\n    \u25aa Booting up control plane ...\n    \u25aa Configuring RBAC rules ...\n\ud83d\udd17  Configuring bridge CNI (Container Networking Interface) ...\n\ud83d\udd0e  Verifying Kubernetes components...\n    \u25aa Using image gcr.io/k8s-minikube/storage-provisioner:v5\n\ud83c\udf1f  Enabled addons: storage-provisioner, default-storageclass\n\ud83c\udfc4  Done! kubectl is now configured to use \"minikube\" cluster and \"default\" namespace by default\n```\n\nGreat! You have started a Kubernetes cluster using Minikube. Note the last comment that says `kubectl is now configured to use \"minikube\" cluster and \"default\" namespace by default`. So, you can now use `kubectl` to interact with the Kubernetes cluster.\n\n###  Verify the cluster\n\nIf you run the following command:\n\n```bash\nkubectl get pods -A\n```\n\nThis will show you the pods running in the cluster. You should see something like this:\n\n```bash\nNAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE\nkube-system   coredns-5dd5756b68-qhfch           1/1     Running   0          26s\nkube-system   etcd-minikube                      1/1     Running   0          42s\nkube-system   kube-apiserver-minikube            1/1     Running   0          40s\nkube-system   kube-controller-manager-minikube   1/1     Running   0          42s\nkube-system   kube-proxy-xwdgf                   1/1     Running   0          26s\nkube-system   kube-scheduler-minikube            1/1     Running   0          40s\nkube-system   storage-provisioner                1/1     Running   0          39s\n```\n\nIf your output is similar to the one above, then congratulations! You have successfully spun up a Kubernetes cluster on your local machine using Minikube.\n\nNext, you will learn how to deploy Weaviate to the Kubernetes cluster using Helm.\n\n\n\n", "type": "Documentation", "name": "K8s Kubernetes_basics", "path": "developers/academy/deployment/k8s/10_kubernetes_basics.mdx", "link": "https://weaviate.io/developers/academy/deployment/k8s/kubernetes_basics", "timestamp": "2024-05-08 10:47:30", "reader": "JSON", "meta": {}, "chunks": []}