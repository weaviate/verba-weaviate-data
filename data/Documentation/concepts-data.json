{"text": "\n\n\n\n- Configuration: Schema\n\n## Overview\n\nThis document lays out how Weaviate deals with data objects, including how they are stored, represented, and linked to each other.\n\n## Data object nomenclature\n\nEach data object in Weaviate always belongs to a Class, and has one or more Properties.\n\nWeaviate stores _data objects_ (represented as JSON-documents) in _class-based collections_, where each object can be represented by a machine learning _vector_ (i.e., an embedding).\n\nEach _class-based collection_ contains objects of the same _class_, which are defined by a common _schema_.\n\nLet's unpack this with an example.\n\n### JSON documents as objects\n\nImagine we need to store information about the following author: Alice Munro.\n\nThe data about this author can be represented in JSON like this:\n\n```json\n{\n    \"name\": \"Alice Munro\",\n    \"age\": 91,\n    \"born\": \"1931-07-10T00:00:00.0Z\",\n    \"wonNobelPrize\": true,\n    \"description\": \"Alice Ann Munro is a Canadian short story writer who won the Nobel Prize in Literature in 2013. Munro's work has been described as revolutionizing the architecture of short stories, especially in its tendency to move forward and backward in time.\"\n}\n```\n\n### Vectors\n\nAs mentioned earlier, we can also attach `vector` representations to our data objects. This is represented as an array of numbers under a `\"vector\"` property, like this:\n\n```json\n{\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Alice Munro\",\n        (...)\n    },\n    \"vector\": [\n        -0.16147631,\n        -0.065765485,\n        -0.06546908\n    ]\n}\n```\n\nYou can generate vectors yourself outside of Weaviate, or use one of Weaviate's vectorizer modules.\n\n### Class Collections\n\nWeaviate groups all Authors under the `Author` class and places them in the same _class collection_.\n\n\n\nFollowing on our author example, Weaviate can store multiple authors like this:\n\n```json\n[{\n    \"id\": \"dedd462a-23c8-32d0-9412-6fcf9c1e8149\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Alice Munro\",\n        \"age\": 91,\n        \"born\": \"1931-07-10T00:00:00.0Z\",\n        \"wonNobelPrize\": true,\n        \"description\": \"Alice Ann Munro is a Canadian short story writer who won the Nobel Prize in Literature in 2013. Munro's work has been described as revolutionizing the architecture of short stories, especially in its tendency to move forward and backward in time.\"\n    },\n    \"vector\": [\n        -0.16147631,\n        -0.065765485,\n        -0.06546908\n    ]\n}, {\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Paul Krugman\",\n        \"age\": 69,\n        \"born\": \"1953-02-28T00:00:00.0Z\",\n        \"wonNobelPrize\": true,\n        \"description\": \"Paul Robin Krugman is an American economist and public intellectual, who is Distinguished Professor of Economics at the Graduate Center of the City University of New York, and a columnist for The New York Times. In 2008, Krugman was the winner of the Nobel Memorial Prize in Economic Sciences for his contributions to New Trade Theory and New Economic Geography.\"\n    },\n    \"vector\": [\n        -0.93070928,\n        -0.03782172,\n        -0.56288009\n    ]\n}]\n```\n\nEvery object stored in Weaviate has a UUID, which guarantees uniqueness across all collections.\n\n### Cross-references\n\nCreating cross-references does not affect object vectors in either direction.\n\nWhere data objects have relationships with each other, they can be represented in Weaviate with cross-references.\n\nFor example, let's say that we want to represent the fact that *\"Paul Krugman writes for the New York Times\"*. We can do this by establishing a cross-reference relationship that Paul Krugman writes for the New York Times. More specifically, a `Publication` object representing the New York Times can have a cross-reference to an `Author` object representing Paul Krugman.\n\nSo, given the following `Publication` object for the New York Times:\n\n```json\n{\n    \"id\": \"32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\",\n    \"class\": \"Publication\",\n    \"properties\": {\n        \"name\": \"The New York Times\"\n    },\n    \"vector\": [...]\n}\n```\n\nWe can identify it with its `UUID`, and specify it in the `writesFor` property for the `Author`. An object containing a cross-reference may look like this:\n\n```json\n{\n    \"id\": \"779c8970-0594-301c-bff5-d12907414002\",\n    \"class\": \"Author\",\n    \"properties\": {\n        \"name\": \"Paul Krugman\",\n        ...\n// highlight-start\n        \"writesFor\": [\n            {\n                \"beacon\": \"weaviate://localhost/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\",\n                \"href\": \"/v1/objects/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6\"\n            }\n        ],\n// highlight-end\n    },\n    \"vector\": [...]\n}\n```\n\nEach cross-reference relationship in Weaviate is directional.\n\nSo, in addition to the `Author` class having a `writesFor` property that points to the `Publication` class, you could have a `hasAuthors` property in the `Publication` class that points to the `Author` class.\n\nCross-references in Weaviate can be best thought of as links to help you retrieve related information. Cross-references do not affect the vector of the `from`, or the `to` object.\n\n## Weaviate Schema\n\nWeaviate requires a data schema to be built before adding data.\n\n\n\n\nDesigning and adding a data schema does not need to be done manually. In the absence of a data schema specification, Weaviate will generate a schema automatically from the provided data.\n\nA Weaviate data schema is slightly different from a taxonomy, which has a hierarchy. Read more about how taxonomies, ontologies and schemas are related to Weaviate in this blog post.\n\nTo learn how to build a schema, see our schema tutorial, or how-to on schema configuration.\n\nFor now, what's important to know is this:\n\n1. Classes and properties (as explained above) are defined in the schema.\n1. Every class has its own vector space, which means that you can attach vectors from different models to different classes.\n1. You can link classes (even if they use different embeddings) by setting cross-references.\n1. You can configure module behavior, ANN index settings, reverse index types, etc. In the schema as well (more about this in the schema tutorial).\n\n## Multi-tenancy\n\n- How-to manage data: Multi-tenancy operations\n- References: REST API: Schema: Multi-tenancy\n\n- Multi-tenancy added in `v1.20`\n- Tenant activity status setting added in `v1.21`\n\nIf you want to use a single Weaviate cluster to store data that is segregated from other data in the cluster, use multi-tenancy. Every class can be configured to isolate data for a `tenant` by providing a tenant key.\n\nWhen multi-tenancy is enabled, Weaviate uses partition shards to store each tenant's data. Sharding has several benefits:\n\n- Data isolation\n- Fast, efficient querying\n- Easy and robust setup and clean up\n\nStarting in `v1.20`, shards are more lightweight. You can easily have 50,000, or more, active shards per node. This means that you can support 1M concurrently active tenants with just 20 or so nodes.\n\nStarting in `v1.20.1`, you can specify tenants as active (`HOT`) or inactive (`COLD`). For more details on managing tenants, see Multi-tenancy operations.\n\nMulti-tenancy is especially useful when you want to store data for multiple customers, or when you want to store data for multiple projects.\n\n### Tenancy and IDs\n\nEach tenancy works like a namespace. So, different tenants could have objects with the same IDs. What makes an object\u2019s ID unique is not just the object ID itself, but the combination of the tenant and the object ID.\n\n### Tenancy and cross-references\n\nWhen using multi-tenancy, cross-references can be made as follows:\n\n- From a multi-tenancy object to a non-multi-tenancy object.\n- From a multi-tenancy object to a multi-tenancy object, as long as they belong to the same tenant.\n\nYou **cannot** create cross-references:\n\n- From a non-multi-tenancy object to a multi-tenancy object, or\n- From a multi-tenancy object to a multi-tenancy object, if they belong to different tenants.\n\n### Key features\n\n- Each tenant has a dedicated high-performance vector index providing query speeds as if the tenant was the only user on the cluster.\n- As each tenant's data is isolated to a dedicated shard, deletes are fast, easy and do not affect other tenants.\n- To scale up, add a new node to your cluster. Weaviate will automatically schedule new tenants on the node with the least resource usage.\n\n- How-to: Manage Data | Multi-tenancy operations\n- Multi-tenancy blog\n\n### Monitoring metrics with multi-tenancy\n\nWhen using multi-tenancy, we suggest setting the `PROMETHEUS_MONITORING_GROUP` environment variable as `true` so that data across all tenants are grouped together for monitoring.\n\n### Tenancy size per node\n\nAlthough there is no inherent limit of tenants per node, the current limit is from Linux's open file limit per process. With a class with 6 properties, we could store ~70,000 tenants on a single node before running out of file descriptors.\n\nConcretely, a 9-node cluster using `n1-standard-8` machines in our tests could hold around 170k active tenants, with 18-19k tenants per node.\n\nNote that these numbers relate to active tenants only. The size of tenants per node can be increased by setting unused tenants as inactive.\n\n### Lazy shard loading\n\n\nWhen Weaviate starts up, it loads data from all of the shards in your deployment. This process can take a long time. Prior to v1.23, you have to wait until all of the shards are loaded before you can query your data. Since every tenant is a shard, multi-tenant deployments can have reduced availability after a restart.\n\nLazy shard loading allows you to start working with your data sooner. After a restart, shards load in the background. If the shard you want to query is already loaded, you can get your results sooner. If the shard is not loaded yet, Weaviate prioritizes loading that shard and returns a response when it is ready.\n\nTo enable lazy shard loading, set `DISABLE_LAZY_LOAD_SHARDS = false` in your system configuration file.\n\n### Tenant status\n\n\nA tenant status can be `HOT` or `COLD`. If `HOT`, the tenant's shard is active, and if `COLD`, the tenant's shard is inactive. An inactive shard is turned off to save resources, meaning Weaviate can not read from or write to the shard in that state. Any attempt to access it will result in an error, with a message that tenant is not active\n\n## Recap\n\n* Inside Weaviate, you can store _data objects_ which can be represented by a machine learning vector.\n* Weaviate represents data objects as JSON documents.\n* Every data object can contain a vector.\n* You can set cross-references as datatypes to link to other objects.\n* You will define classes and properties in a schema.\n* Different classes can represent different vector spaces.\n* The schema has a class-property data structure.\n* You define classes and properties in the schema.\n* We can query using the GraphQL-interface or -in some cases- the RESTful API.\n* Vectors come from machine learning models that you inference yourself or through a Weaviate module.\n* You can use multi-tenancy to isolate data for each tenant.\n\n\n\n\n", "type": "Documentation", "name": "concepts-data", "path": "developers/weaviate/concepts/data.md", "link": "https://weaviate.io/developers/weaviate/concepts/data", "timestamp": "2024-02-08 20:22:32", "reader": "JSON", "meta": {}, "chunks": []}