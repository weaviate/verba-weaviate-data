{"text": "\n## &nbsp;&nbsp;Vectors in action\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nLet's take a look at a few more examples of what you can do with Weaviate.\n\nFirst, we will try vector searches by searching through our demo database. You will learn how to use Weaviate to retrieve objects based on their similarity, using various query types such as an input text, vector, or object.\n\nYou will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two techniques through the use of filters.\n\n### &nbsp;&nbsp;Vector search demo\n\nFor our first example, let's search our demo dataset. It contains a small sample of questions from the quiz show *Jeopardy!*.\n\nImagine that you're running a quiz night, and you want to get some questions about \"animals in movies\". In a traditional database you could look for word matches, perhaps something like:\n\n```sql\nSELECT question, answer\nFROM jeopardy_questions\nWHERE (\n         question LIKE '%animal%'\n         OR question LIKE '%creature%'\n         OR question LIKE '%beast%'\n      )\nAND (\n       question LIKE '%movie%'\n       OR question LIKE '%film%'\n       OR question LIKE '%picture%'\n       OR question LIKE '%cinema%'\n    )\n\n```\n\nThis is a difficult query to write. Even worse, you would probably have to add the names of specific animals to the query as well.\n\nThe Weaviate query is much more intuitive. See what happens when we run the following query:\n\nanimals in movies\n\n\n   See the full query\n\n```graphql\n{\n  Get {\n    JeopardyQuestion (\n      nearText: {\n        concepts: [\"animals in movies\"]\n      }\n      limit: 3\n    ) {\n      question\n      answer\n    }\n  }\n}\n```\n\n\n\nWeaviate retrieved these as the top answers:\n\n- **meerkats**: Group of mammals seen here like Timon in *The Lion King*\n- **dogs**: Scooby-Doo, Goofy & Pluto are cartoon versions\n- **The Call of the Wild Thornberrys**: Jack London story about the dog Buck who joins a Nick cartoon about Eliza, who can talk to animals\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"JeopardyQuestion\": [\n        {\n          \"answer\": \"meerkats\",\n          \"question\": \"Group of mammals seen here:  [like Timon in The Lion King]\"\n        },\n        {\n          \"answer\": \"dogs\",\n          \"question\": \"Scooby-Doo, Goofy & Pluto are cartoon versions\"\n        },\n        {\n          \"answer\": \"The Call of the Wild Thornberrys\",\n          \"question\": \"Jack London story about the dog Buck who joins a Nick cartoon about Eliza, who can talk to animals\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\nNote how relevant the results are, despite none of them including the word \"animal\" or the word \"movie\", let alone both!\n\nThis is exactly why vector searches are so useful. They can identify related objects without the need to match exact text.\n\n### &nbsp;&nbsp;Vector similarities demo\n\nIf we run *this* query, you might expect to see responses like the ones we saw earlier.\n\n```graphql\n{\n  Get {\n    JeopardyQuestion (\n      nearText: {\n        concepts: [\"European geography\"]\n      }\n      limit: 3\n    ) {\n      question\n      answer\n      _additional {\n        distance\n      }\n    }\n  }\n}\n```\n\nBut, take a look at this response. Do you notice any additional information?\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"JeopardyQuestion\": [\n        {\n          \"_additional\": {\n            \"distance\": 0.15916324\n          },\n          \"answer\": \"Bulgaria\",\n          \"question\": \"A European republic: Sofia\"\n        },\n        ...\n      ]\n    }\n  }\n}\n\n```\n\n\n   See the full JSON response from Weaviate\n\n```json\n{\n  \"data\": {\n    \"Get\": {\n      \"JeopardyQuestion\": [\n        {\n          \"_additional\": {\n            \"distance\": 0.15916324\n          },\n          \"answer\": \"Bulgaria\",\n          \"question\": \"A European republic: Sofia\"\n        },\n        {\n          \"_additional\": {\n            \"distance\": 0.16247147\n          },\n          \"answer\": \"Balkan Peninsula\",\n          \"question\": \"The European part of Turkey lies entirely on this peninsula\"\n        },\n        {\n          \"_additional\": {\n            \"distance\": 0.16832423\n          },\n          \"answer\": \"Mediterranean Sea\",\n          \"question\": \"It's the only body of water with shores on the continents of Asia, Africa & Europe\"\n        }\n      ]\n    }\n  }\n}\n\n```\n\n\n\nThe difference is that the response contains a `distance` value.\n\nA `distance` is indicative of the degree of similarity between the returned object and the query.\n\nIf you're wondering exactly what that means, and who decides how similar any two objects or concepts are, those are great questions! We will cover those in more detail later.\n\nFor now, just keep in mind that smaller distances mean two objects are more similar to each other.\n\n## &nbsp;&nbsp;Review\n\n -->\n\n&nbsp;&nbsp;Review exercise\n\nCan you describe, in your own sentence, XXX?\n\nInput box for user to put answer in and get back a similarity score & our definition?\n??\n\n### &nbsp;&nbsp;Key takeaways\n\n- Vector searches can identify related objects without the need for exact text matches.\n- In vector searches, distance values indicate the degree of similarity between the returned object and the query.\n- Smaller distances indicate greater similarity.\n- Vector searches can be combined with keyword searches and filtering techniques for more refined search results.\n\n\n\n", "type": "Documentation", "name": "hello_weaviate-examples_1", "path": "developers/academy/zero_to_mvp/101_hello_weaviate/20_examples_1.mdx", "link": "https://weaviate.io/developers/academy/zero_to_mvp/hello_weaviate/examples_1", "timestamp": "2024-02-08 21:19:46", "reader": "JSON", "meta": {}, "chunks": []}