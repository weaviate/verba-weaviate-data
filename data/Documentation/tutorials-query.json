{"text": "\n\n## Overview\n\nIn this section, we will explore different queries that you can perform with Weaviate. Here, we will expand on the `nearText` queries that you may have seen in the Quickstart tutorial to show you different query types, filters and metrics that can be used.\n\nBy the end of this section, you will have performed vector and scalar searches separately as well as in combination to retrieve individual objects and aggregations.\n\n## Prerequisites\n\nWe recommend you complete the Quickstart tutorial first.\n\nBefore you start this tutorial, you should follow the steps in the Quickstart to have:\n\n- An instance of Weaviate running (e.g. on the Weaviate Cloud Services),\n- An API key for your preferred inference API, such as OpenAI, Cohere, or Hugging Face,\n- Installed your preferred Weaviate client library,\n- Set up a `Question` class in your schema, and\n- Imported the `jeopardy_tiny.json` data.\n\n## Object retrieval with `Get`\n\nWeaviate's queries are built using GraphQL. If this is new to you, don't worry. We will take it step-by-step and build up from the basics. Also, in many cases, the GraphQL syntax is abstracted by the client.\n\nYou can query Weaviate using one or a combination of a semantic (i.e. vector) search and a lexical (i.e. scalar) search. As you've seen, a vector search allows for similarity-based searches, while scalar searches allow filtering by exact matches.\n\nFirst, we will start by making queries to Weaviate to retrieve **Question** objects that we imported earlier.\n\nThe Weaviate function for retrieving objects is `Get`.\n\nThis might be familiar for some of you. If you have completed our Imports in detail tutorial, you may have performed a `Get` query to confirm that the data import was successful. Here is the same code as a reminder:\n\n\n\n\nThis query simply asks Weaviate for *some* objects of this (`Question`) class.\n\nOf course, in most cases we would want to retrieve information on some criteria. Let's build on this query by adding a vector search.\n\n### `Get` with `nearText`\n\nThis is a vector search using a `Get` query.\n\nimport CodeAutoschemaNeartext from '/_includes/code/quickstart/neartext.mdx'\n\n\n\nThis might also look familiar, as it was used in the Quickstart tutorial. But let's break it down a little.\n\nHere, we are using a `nearText` operator. What we are doing is to provide Weaviate with a query `concept` of `biology`. Weaviate then converts this into a vector through the inference API (OpenAI in this particular example) and uses that vector as the basis for a vector search.\n\nAlso note here that we pass the API key in the header. This is required as the inference API is used to vectorize the input query.\n\nAdditionally, we use the `limit` argument to only fetch a maximum of two (2) objects.\n\nIf you run this query, you should see the entries on *\"DNA\"* and *\"species\"* returned by Weaviate.\n\n### `Get` with `nearVector`\n\nIn some cases, you might wish to input a vector directly as a search query. For example, you might be running Weaviate with a custom, external vectorizer. In such a case, you can use the `nearVector` operator to provide the query vector to Weaviate.\n\nFor example, here is an example Python code obtaining an OpenAI embedding manually and providing it through the `nearVector` operator:\n\n```python\nimport openai\n\nopenai.api_key = \"YOUR-OPENAI-API-KEY\"\nmodel=\"text-embedding-ada-002\"\noai_resp = openai.Embedding.create(input = [\"biology\"], model=model)\n\noai_embedding = oai_resp['data'][0]['embedding']\n\nresult = (\n    client.query\n    .get(\"Question\", [\"question\", \"answer\"])\n    .with_near_vector({\n        \"vector\": oai_embedding,\n        \"certainty\": 0.7\n    })\n    .with_limit(2)\n    .do()\n)\n\nprint(json.dumps(result, indent=4))\n```\n\nAnd it should return the same results as above.\n\nNote that we used the same OpenAI embedding model (`text-embedding-ada-002`) here so that the vectors are in the same vector \"space\".\n\nYou might also have noticed that we have added a `certainty` argument in the `with_near_vector` method. This lets you specify a similarity threshold for objects, and can be very useful for ensuring that no distant objects are returned.\n\n## Additional properties\n\nWe can ask Weaviate to return `_additional` properties for any returned objects. This allows us to obtain properties such as the `vector` of each returned object as well as the actual `certainty` value, so we can verify how close each object is to our query vector. Here is a query that will return the `certainty` value:\n\nimport CodeQueryNeartextAdditional from '/_includes/code/quickstart.query.neartext.additional.mdx'\n\n\n\nTry it out, and you should see a response like this:\n\n```json\n{\n    \"data\": {\n        \"Get\": {\n            \"Question\": [\n                {\n                    \"_additional\": {\n                        \"certainty\": 0.9030631184577942\n                    },\n                    \"answer\": \"DNA\",\n                    \"category\": \"SCIENCE\",\n                    \"question\": \"In 1953 Watson & Crick built a model of the molecular structure of this, the gene-carrying substance\"\n                },\n                {\n                    \"_additional\": {\n                        \"certainty\": 0.900638073682785\n                    },\n                    \"answer\": \"species\",\n                    \"category\": \"SCIENCE\",\n                    \"question\": \"2000 news: the Gunnison sage grouse isn't just another northern sage grouse, but a new one of this classification\"\n                }\n            ]\n        }\n    }\n}\n```\n\nYou can try modifying this query to see if you retrieve the vector (note - it will be a looooong response \ud83d\ude09).\n\nWe encourage you to also try out different queries and see how that changes the results and distances not only with this dataset but also with different datasets, and/or vectorizers.\n\n## Filters\n\nAs useful as it is, sometimes vector search alone may not be sufficient. For example, you may actually only be interested in **Question** objects in a particular category, for instance.\n\nIn these cases, you can use Weaviate's scalar filtering capabilities - either alone, or in combination with the vector search.\n\nTry the following:\n\nimport CodeQueryWhere1 from '/_includes/code/quickstart.query.where.1.mdx'\n\n\n\nThis query asks Weaviate for **Question** objects whose category contains the string `ANIMALS`. You should see a result like this:\n\n```json\n{\n    \"data\": {\n        \"Get\": {\n            \"Question\": [\n                {\n                    \"answer\": \"the diamondback rattler\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"Heaviest of all poisonous snakes is this North American rattlesnake\"\n                },\n                {\n                    \"answer\": \"Elephant\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"It's the only living mammal in the order Proboseidea\"\n                },\n                {\n                    \"answer\": \"the nose or snout\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"The gavial looks very much like a crocodile except for this bodily feature\"\n                },\n                {\n                    \"answer\": \"Antelope\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"Weighing around a ton, the eland is the largest species of this animal in Africa\"\n                }\n            ]\n        }\n    }\n}\n```\n\nNow that you've seen a scalar filter, let's see how it can be combined with vector search functions.\n\n### Vector search with scalar filters\n\nCombining a filter with a vector search is an additive process. Let us show you what we mean by that.\n\nimport CodeQueryWhere2 from '/_includes/code/quickstart.query.where.2.mdx'\n\n\n\nThis query asks Weaviate for **Question** objects that are closest to \"biology\", but within the category of `ANIMALS`. You should see a result like this:\n\n```json\n{\n    \"data\": {\n        \"Get\": {\n            \"Question\": [\n                {\n                    \"_additional\": {\n                        \"certainty\": 0.8918434679508209\n                    },\n                    \"answer\": \"the nose or snout\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"The gavial looks very much like a crocodile except for this bodily feature\"\n                },\n                {\n                    \"_additional\": {\n                        \"certainty\": 0.8867587149143219\n                    },\n                    \"answer\": \"Elephant\",\n                    \"category\": \"ANIMALS\",\n                    \"question\": \"It's the only living mammal in the order Proboseidea\"\n                }\n            ]\n        }\n    }\n}\n```\n\nNote that the results are confined to the choices from the 'animals' category. Note that these results, while not being cutting-edge science, are biological factoids.\n\n## Metadata with `Aggregate`\n\nAs the name suggests, the `Aggregate` function can be used to show aggregated data such as on entire classes or groups of objects.\n\nFor example, the following query will return the number of data objects in the `Question` class:\n\nimport CodeQueryAggregate1 from '/_includes/code/quickstart.query.aggregate.1.mdx'\n\n\n\nAnd you can also use the `Aggregate` function with filters, just as you saw with the `Get` function above. For example, this query will return the number of **Question** objects with the category \"ANIMALS\".\n\nimport CodeQueryAggregate2 from '/_includes/code/quickstart.query.aggregate.2.mdx'\n\n\n\nAnd as you saw above, there are four objects that match the query filter.\n\n```json\n{\n    \"data\": {\n        \"Aggregate\": {\n            \"Question\": [\n                {\n                    \"meta\": {\n                        \"count\": 4\n                    }\n                }\n            ]\n        }\n    }\n}\n```\n\nHere, Weaviate has identified the same objects that you saw earlier in the similar `Get` queries. The difference is that instead of returning the individual objects you are seeing the requested aggregated statistic (count) here.\n\nAs you can see, the `Aggregate` function can return handy aggregated, or metadata, information from the Weaviate database.\n\n## Recap\n\n* `Get` queries are used for retrieving data objects.\n* `Aggregate` queries can be used to retrieve metadata, or aggregated data.\n* Operators such as `nearText` or `nearVector` can be used for vector queries.\n* Scalar filters can be used for exact filtering, taking advantage of inverted indexes.\n* Vector and scalar filters can be combined, and are available on both `Get` and `Aggregate` queries\n\n## Suggested reading\n\n- Tutorial: Schemas in detail\n- Tutorial: Import in detail\n- Tutorial: Introduction to modules\n- Tutorial: Introduction to Weaviate Console\n\n## Notes\n\n### How is certainty calculated?\n\n`certainty` in Weaviate is a measure of distance from the vector to the data objects. You can also calculate the cosine similarity based on the certainty as described here.\n\n\n\n\n", "type": "Documentation", "name": "tutorials-query", "path": "developers/weaviate/tutorials/query.md", "link": "https://weaviate.io/developers/weaviate/tutorials/query", "timestamp": "2024-02-08 21:22:09", "reader": "JSON", "meta": {}, "chunks": []}