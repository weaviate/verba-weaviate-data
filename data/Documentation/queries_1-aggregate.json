{"text": "\n## &nbsp;&nbsp;Overview\n\nimport ReactPlayer from 'react-player/lazy'\n\n\n\n\nNow that you have seen how to retrieve individual objects with `Get`, let's take a look at how to compile information with `Aggregate`.\n\n`Aggregate` is a powerful function that allows you to combine information from multiple objects into a single result to get a quick overview of the results.\n\n## &nbsp;&nbsp;About `Aggregate` queries\n\n### &nbsp;&nbsp;`Aggregate` function syntax\n\nWhile the overall structure of `Aggregate` queries is similar to `Get` queries, there are some important differences as the queries relate to sets of results.\n\nThe basic syntax for `Aggregate` queries is as follows:\n\n\n\n\nUnlike a `Get` query, available properties in `Aggregate` differ according to data types of the property being queried.\n\nThese reflect the possible operations that can be performed on different data types. For example, the available properties for a `String` property are different from those for an `Integer` property or a cross-reference.\n\nLet's try out some `Aggregate` queries.\n\nAs a reminder, our objects include the following schema:\n\n\n  See relevant schema\n\n\n\n\n\n\n## &nbsp;&nbsp;Standalone `Aggregate` queries\n\n### &nbsp;&nbsp;Example 1\n\nTake a look at this query:\n\n\n\n\nWhat kind of results do you expect to come back?\n\nNow, try it out yourself.\n\nYour query should return something like this:\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"JeopardyQuestion\": [\n        {\n          \"meta\": {\n            \"count\": 10000\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n### &nbsp;&nbsp;Response object from Weaviate\n\nThis response includes an object to represent the `meta` information requested from `JeopardyQuestion` class. The `meta` object contains a `count` property, which is the total number of objects in the class.\n\n\n   Explain this query\n\nThis query aggregates the objects in the `JeopardyQuestion` class to obtain the total count. Since there are no restrictions, it returns the total number of objects which is 10,000.\n\n\n\n### &nbsp;&nbsp;`meta` property\n\nIn the above `Aggregate` query we requested a `meta` property, for the count of the objects. Note that this is not an available property of the object class itself. This is a key difference between `Aggregate` and `Get` queries.\n\nA `Get` query retrieves a set of individual results, so we can select properties (e.g. `id`, or one of the properties unique to the data, such as `answer`) that apply to each of those individual results.\n\nAn `Aggregate` query, on the other hand, returns an aggregation of the results. Accordingly, we must specify a sub-property that applies to the entire set of results.\n\nThe `meta` property is one such property. It is available for all data types, and can be used with the `count` sub-property to return the number of retrieved objects.\n\n\n### &nbsp;&nbsp;Example 2\n\nTake a look at this query:\n\n\n\n\nWhat fields do you expect back in the results?\n\nNow, try it out yourself.\n\nYour query should return something like this:\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"JeopardyQuestion\": [\n        {\n          \"answer\": {\n            \"count\": 10000,\n            \"topOccurrences\": [\n              {\n                \"occurs\": 19,\n                \"value\": \"Australia\"\n              },\n              {\n                \"occurs\": 18,\n                \"value\": \"Hawaii\"\n              },\n              {\n                \"occurs\": 16,\n                \"value\": \"Boston\"\n              },\n              {\n                \"occurs\": 15,\n                \"value\": \"French\"\n              },\n              {\n                \"occurs\": 15,\n                \"value\": \"India\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n   Explain this query\n\nThis response includes an object to represent aggregations from the `answer` property requested from `JeopardyQuestion` class. Because the property contains textual information, we can aggregate `topOccurrences` information, such as the `value` property, which is the token, as well as the number of times it `occurs`.\n\n\n\nThe list of available properties can be found on this page in our documentation.\n\n## &nbsp;&nbsp;`Aggregate` with a search operator\n\nAs we did with `Get` queries, we can also use search operators such as `nearText` in an `Aggregate` query. Take a look:\n\n### &nbsp;&nbsp;Example (with `nearText`)\n\nFor example, let's say that now instead of individual questions, we would like to know something more holistic about the answers. Like how many questions might be related to this query:\n\n\n\n\nBefore looking at the response, or running the query, think about the following:\n- How many results do you expect to be returned?\n- Can you guess how an increase in the `distance` parameter would change the number of results returned?\n\nNow, try it out yourself. The query should return something like this:\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"JeopardyQuestion\": [\n        {\n          \"meta\": {\n            \"count\": 9\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n\n   Explain this query\n\nThis query aggregates the results that were restricted using the `distance` argument. This argument is a threshold that restricts the returned results to those that are relevant to the input. Without it, the search results would potentially include the entire class.\n\nThis is called \"limiting the search space\".\n\n\n\n### &nbsp;&nbsp;Limit search space\n\nIn order to produce meaningful aggregations with a vector search, you must limit the search space.\n\nThis is different from aggregations in, say, a relational database. In a relational database, grouping or aggregating data can be done using `groupby` with functions such as SUM, AVG, MIN, MAX, etc. This allows you to find a result set and then aggregate the results.\n\nHowever, a vector search does not inherently exclude any results. This is because a vector search retrieves results based on *degrees* of similarity.\n\n**Accordingly, the search space must be limited** so that only relevant results are included in the aggregation. This can be done by setting an explicit `limit` or a threshold (`distance` or `certainty`) in the query.\n\n## &nbsp;&nbsp;`Aggregate` with `groupBy`\n\nSo far, we have seen how to use `Aggregate` queries to compile information relating one set of results. This can be extended with the `groupBy` argument to compile information from multiple, subsets of results.\n\n### &nbsp;&nbsp;Example\n\nFor example, let's say we want to know how many questions there are for each available `value` property. We can do this by adding the `groupBy` argument to the query:\n\n\n\n\nWhat do you expect to see here? How will the results differ, now that we've added the `groupBy` argument? Do you notice what else has changed to the query?\n\nNow, try it out yourself. The query should return something like this:\n\n\n   See the JSON response\n\n```json\n{\n  \"data\": {\n    \"Aggregate\": {\n      \"JeopardyQuestion\": [\n        {\n          \"groupedBy\": {\n            \"path\": [\n              \"round\"\n            ],\n            \"value\": \"Double Jeopardy!\"\n          },\n          \"meta\": {\n            \"count\": 5\n          }\n        },\n        {\n          \"groupedBy\": {\n            \"path\": [\n              \"round\"\n            ],\n            \"value\": \"Jeopardy!\"\n          },\n          \"meta\": {\n            \"count\": 3\n          }\n        },\n        {\n          \"groupedBy\": {\n            \"path\": [\n              \"round\"\n            ],\n            \"value\": \"Final Jeopardy!\"\n          },\n          \"meta\": {\n            \"count\": 1\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n\n\n\n   Explain this query\n\nThis query supplies an additional `groupedBy` argument, as a result of which the counts are of each `round`. The query also requests `groupedBy` a property so that each count is identifiable by the `value` of each `round` group.\n\n\n\n### &nbsp;&nbsp;`groupBy` + `groupedBy`\n\nResults identified by an `Aggregate` query can be further grouped by using a `groupBy` argument. This argument takes a list of properties as an argument, and will group the results by the values of those properties.\n\nThis is a particularly useful query pattern for identifying characteristics for subsets of results of a vector search.\n\nWhen the `groupBy` argument is used, additional property `groupedBy` is made available. This property and its sub-properties can be used to identify the group that the result belongs to.\n\nTry out the above query again, with these changes.\n- Instead of `round` try grouping by the `points` property.\n- Instead of `distance`, try adding an `.with_object_limit(9)` in the method chain. Are the results the same?\n\n## &nbsp;&nbsp;Review\n\n### &nbsp;&nbsp;Review exercise\n\nTry out the above `nearText` query again, with these changes.\n- Change the distance to another value - say, to 0.1, 0.19, 0.21 or 0.25 - how do the results change? Are they in line with your expectations?\n\n### &nbsp;&nbsp;Key takeaways\n\n- The `Aggregate` function is used to compile information from multiple objects, providing an overview.\n- Search operators, like `nearText`, can be used in `Aggregate` queries.\n    - To produce meaningful aggregations, the search space must be limited by setting an explicit limit or a threshold (distance or certainty) in the query.\n- The `groupBy` argument can be used to compile information from multiple subsets of results, refining the aggregation.\n- When using the groupBy argument, the additional property groupedBy is made available, helping to identify the group that the result belongs to.\n\nimport Quiz from '/src/components/Academy/quiz.js'\nconst varName = [{\n  questionText: 'questionText',\n  answerOptions: [\n    {\n      answerText: 'answerOne',\n      isCorrect: false,\n      feedback: 'feedbackOne',\n    },\n    {\n      answerText: 'answerTwo',\n      isCorrect: false,\n      feedback: 'feedbackTwo',\n    },\n    {\n      answerText: 'answerThree',\n      isCorrect: false,\n      feedback: 'feedbackThree',\n    },\n  ]\n}];\n\n\n\n", "type": "Documentation", "name": "queries_1-aggregate", "path": "developers/academy/zero_to_mvp/102_queries_1/40_aggregate.mdx", "link": "https://weaviate.io/developers/academy/zero_to_mvp/queries_1/aggregate", "timestamp": "2023-11-02 10:51:29", "reader": "JSON", "meta": {}, "chunks": []}