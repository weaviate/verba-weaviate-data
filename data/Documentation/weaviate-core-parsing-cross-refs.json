{"text": "\n## Overview\n\nObjects are parsed twice:\n\n* First, closest to disk, immediately after reading-in the byte blob, all\n  non-reference props are parsed and their respective Golang types (e.g.\n  `*models.GeoCoordinates` or `*models.PhoneNumber`) are returned.\n\n* A second time at the root level of the `db.DB` type, the whole request is\n  parsed again (recursively) and cross-refs are resolved as requested by the\n  user (through `traverser.SelectProperties`)\n\nreturning objects with references\n\n## Motivation behind split-parsing\n\nGenerally, shards (and also indices) are self-contained units. It is thus\nnatural that they return objects which work in isolation and can be interpreted\nby the rest of the application (usually in the form of a `search.Result` or\n`search.Results`, both defined as `entities`)\n\nHowever, cross-references aren't predictable. They could point to an item in\nanother shard or even to an item of another index (because they are a different\nuser-facing `Class`). When running in multi-node mode (horizontal replication)\nthe shards could be distributed on any node in the cluster.\n\nFurthermore it is more efficient (see cached resolver) to resolve references\nfor a list of objects as opposed to a single object. At shard-level we do not\nknow if a specific object is part of a list and if this list spans across\nshards or indices.\n\nThus the second parsing - to enrich the desired cross-references - happens at\nthe outermost layer of the persistence package in the `db.DB` **after**\nassembling the index/shards parts.\n\n## Cached Resolver Logic\n\nThe cached resolver is a helper struct with a two-step process:\n\n1. **Cacher**: The input object list is (in form of a `search.Results`) is analyzed for\n   references. This is a recursive process, as each resolved references might\n   be pointing to another object which the user (as specified through the\n   `traverser.SelectProperties`) wants to resolve. However Step 1 (\"the\n   cacher\") stores all results in a flat list (technically a map). This saves\n   on complexity as only the \"finding references\" part is recursive, but the\n   storage part is simple.\n\n2. **Resolver**: In a second step, the schema is parsed recursively again where each\n   reference pointer (in the form of a `*models.SingleRef` containing a\n   `Beacon` string) is replaced with the resolved reference content (in the\n   form of a `search.LocalRef`). If the result again contains such reference\n   pointers to other objects, these are resolved in the same fashion -\n   recursively until everything that the user requested is resolved.\n\n## Relevant Code\n\n* The reference Cacher and its unit tests\n* The reference Resolver and its unit tests\n* Integration tests for nested refs and refs of different types\n\n## More Resources\n\n\n\n", "type": "Documentation", "name": "weaviate-core-parsing-cross-refs", "path": "developers/contributor-guide/weaviate-core/parsing-cross-refs.md", "link": "https://weaviate.io/developers/contributor-guide/weaviate-core/parsing-cross-refs", "timestamp": "2024-02-08 21:20:22", "reader": "JSON", "meta": {}, "chunks": []}